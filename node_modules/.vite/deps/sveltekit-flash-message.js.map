{
  "version": 3,
  "sources": ["../../sveltekit-flash-message/dist/cookie-es-main/index.js", "../../sveltekit-flash-message/dist/client.js", "../../sveltekit-flash-message/dist/flashMessage.js", "../../sveltekit-flash-message/dist/options.js", "../../sveltekit-flash-message/dist/router.js"],
  "sourcesContent": ["/**\n * Module letiables.\n * @private\n */\nconst decode = decodeURIComponent;\nconst encode = encodeURIComponent;\nconst pairSplitRegExp = /; */;\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n/**\n * Parse an HTTP Cookie header string and returning an object of all cookie\n * name-value pairs.\n *\n * @param str the string representing a `Cookie` header value\n * @param [options] object containing parsing options\n */\nexport function parse(str, options) {\n    if (typeof str !== 'string') {\n        throw new TypeError('argument str must be a string');\n    }\n    let obj = {};\n    let opt = options || {};\n    let pairs = str.split(pairSplitRegExp);\n    let dec = opt.decode || decode;\n    for (let i = 0; i < pairs.length; i++) {\n        let pair = pairs[i];\n        let eq_idx = pair.indexOf('=');\n        // skip things that don't look like key=value\n        if (eq_idx < 0) {\n            continue;\n        }\n        let key = pair.substr(0, eq_idx).trim();\n        let val = pair.substr(++eq_idx, pair.length).trim();\n        // quoted values\n        if ('\"' == val[0]) {\n            val = val.slice(1, -1);\n        }\n        // only assign once\n        if (undefined == obj[key]) {\n            obj[key] = tryDecode(val, dec);\n        }\n    }\n    return obj;\n}\n/**\n * Serialize a cookie name-value pair into a `Set-Cookie` header string.\n *\n * @param name the name for the cookie\n * @param value value to set the cookie to\n * @param [options] object containing serialization options\n * @throws {TypeError} when `maxAge` options is invalid\n */\nexport function serialize(name, value, options) {\n    let opt = options || {};\n    let enc = opt.encode || encode;\n    if (typeof enc !== 'function') {\n        throw new TypeError('option encode is invalid');\n    }\n    if (!fieldContentRegExp.test(name)) {\n        throw new TypeError('argument name is invalid');\n    }\n    let encodedValue = enc(value);\n    if (encodedValue && !fieldContentRegExp.test(encodedValue)) {\n        throw new TypeError('argument val is invalid');\n    }\n    let str = name + '=' + encodedValue;\n    if (null != opt.maxAge) {\n        let maxAge = opt.maxAge - 0;\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\n            throw new TypeError('option maxAge is invalid');\n        }\n        str += '; Max-Age=' + Math.floor(maxAge);\n    }\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError('option domain is invalid');\n        }\n        str += '; Domain=' + opt.domain;\n    }\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError('option path is invalid');\n        }\n        str += '; Path=' + opt.path;\n    }\n    if (opt.expires) {\n        if (typeof opt.expires.toUTCString !== 'function') {\n            throw new TypeError('option expires is invalid');\n        }\n        str += '; Expires=' + opt.expires.toUTCString();\n    }\n    if (opt.httpOnly) {\n        str += '; HttpOnly';\n    }\n    if (opt.secure) {\n        str += '; Secure';\n    }\n    if (opt.sameSite) {\n        let sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n        switch (sameSite) {\n            case true:\n                str += '; SameSite=Strict';\n                break;\n            case 'lax':\n                str += '; SameSite=Lax';\n                break;\n            case 'strict':\n                str += '; SameSite=Strict';\n                break;\n            case 'none':\n                str += '; SameSite=None';\n                break;\n            default:\n                throw new TypeError('option sameSite is invalid');\n        }\n    }\n    return str;\n}\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\nfunction tryDecode(str, decode) {\n    try {\n        return decode(str);\n    }\n    catch (e) {\n        return str;\n    }\n}\n", "import { get, writable } from 'svelte/store';\nimport { tick } from 'svelte';\nimport { BROWSER as browser } from 'esm-env';\nimport { serialize } from './cookie-es-main/index.js';\nimport { navigating } from '$app/stores';\nimport { FlashMessage } from './flashMessage.js';\nimport { FlashRouter } from './router.js';\nimport { afterNavigate, beforeNavigate } from '$app/navigation';\nconst cookieName = 'flash';\nconst routers = new WeakMap();\nfunction getRouter(page, initialData) {\n    let router = routers.get(page);\n    if (!router) {\n        router = new FlashRouter();\n        routers.set(page, router);\n        router.getFlashMessage(get(page).route.id).message.set(initialData);\n        subscribeToNavigation(page);\n    }\n    return router;\n}\nfunction subscribeToNavigation(page) {\n    if (!browser)\n        return;\n    page.subscribe(($page) => {\n        const cookieData = parseFlashCookie();\n        if (cookieData !== undefined) {\n            //console.log('ðŸš€ ~ page.subscribe:', cookieData, $page.route.id);\n            const flash = getRouter(page).getFlashMessage($page.route.id);\n            flash.message.set(cookieData, { concatenateArray: !flash.options.clearArray });\n            clearFlashCookie(flash.options.flashCookieOptions);\n        }\n    });\n    beforeNavigate((nav) => {\n        const navTo = nav?.to?.route.id;\n        if (navTo) {\n            const flash = getRouter(page).getFlashMessage(navTo);\n            if (flash.options.clearOnNavigate && nav.from?.route.id != navTo) {\n                //console.log('ðŸš€ ~ beforeNavigate ~ clear message on nav to:', navTo);\n                flash.message.set(undefined);\n            }\n        }\n    });\n    afterNavigate(() => {\n        const cookieData = parseFlashCookie();\n        if (cookieData !== undefined) {\n            //console.log('ðŸš€ ~ afterNavigate:', cookieData, get(page).route.id);\n            const flash = getRouter(page).getFlashMessage(get(page).route.id);\n            flash.message.set(cookieData, { concatenateArray: !flash.options.clearArray });\n            clearFlashCookie(flash.options.flashCookieOptions);\n        }\n    });\n}\nexport function initFlash(page, options) {\n    return _initFlash(page, options).message;\n}\n// @DCI-context\nfunction _initFlash(page, options) {\n    if (!browser) {\n        // The SSR version uses a simple store with no options,\n        // since they are used only on the client.\n        return new FlashMessage(writable(get(page).data.flash));\n    }\n    const _page = get(page);\n    ///// Roles //////////////////////////////////////////////////////////////////\n    //#region Router /////\n    const Router = getRouter(page, _page.data.flash);\n    function Router_getFlashMessage() {\n        const route = Router.routes.get(Page_route());\n        if (route)\n            return route;\n        return options ? Router_createRoute() : Router.getClosestRoute(Page_route());\n    }\n    function Router_createRoute() {\n        return Router.createRoute(Page_route(), Page_initialData(), options);\n    }\n    //#endregion\n    //#region Page\n    const Page = {\n        store: page,\n        route: _page.route.id,\n        initialdata: _page.data.flash,\n        navigating\n    };\n    function Page_initialData() {\n        return Page.initialdata;\n    }\n    function Page_route() {\n        return Page.route ?? '';\n    }\n    //#endregion\n    return Router_getFlashMessage();\n}\n/**\n * Retrieves the flash message store for display or modification.\n * @param page Page store, imported from `$app/stores`.\n * @param {FlashOptions} options for the flash message. Can only be set once, usually at the highest level component where getFlash is called for the first time.\n * @returns The flash message store.\n */\nexport function getFlash(page, options) {\n    return _initFlash(page, options).message;\n}\n/**\n * Update the flash message manually, usually after a fetch request.\n * @param page Page store, imported from `$app/stores`.\n * @param {Promise<void>} update A callback which is executed *before* the message is updated, to delay the message until navigation events are completed, for example when using `goto`.\n * @returns {Promise<boolean>} `true` if a flash message existed, `false` if not.\n */\nexport async function updateFlash(page, update) {\n    // Update before setting the new message, so navigation events can pass through first.\n    if (update)\n        await update();\n    const cookieData = parseFlashCookie();\n    if (cookieData !== undefined) {\n        if (browser)\n            await tick();\n        const flash = getRouter(page).getFlashMessage(get(page).route.id);\n        flash.message.set(cookieData, { concatenateArray: !flash.options.clearArray });\n        clearFlashCookie(flash.options.flashCookieOptions);\n    }\n    return !!cookieData;\n}\n///////////////////////////////////////////////////////////\nfunction clearFlashCookie(options) {\n    // Clear parsed cookie\n    if (browser) {\n        document.cookie = serialize(cookieName, '', {\n            ...options,\n            maxAge: 0\n        });\n    }\n}\nfunction parseFlashCookie() {\n    const cookieString = document.cookie;\n    if (!cookieString || !cookieString.includes(cookieName + '='))\n        return undefined;\n    function parseCookieString(str) {\n        const output = {};\n        if (!str)\n            return output;\n        return str\n            .split(';')\n            .map((v) => v.split('='))\n            .reduce((acc, v) => {\n            acc[decodeURIComponent(v[0].trim())] = decodeURIComponent(v[1].trim());\n            return acc;\n        }, output);\n    }\n    const cookies = parseCookieString(cookieString);\n    if (cookies[cookieName]) {\n        try {\n            return JSON.parse(cookies[cookieName]);\n        }\n        catch (e) {\n            // Ignore value if parsing failed\n        }\n    }\n    return undefined;\n}\n", "import { browser } from '$app/environment';\nimport { defaultOptions } from './options.js';\nexport class FlashMessage {\n    options;\n    _message;\n    get message() {\n        return this._message;\n    }\n    _flashTimeout = 0;\n    get flashTimeout() {\n        return this._flashTimeout;\n    }\n    constructor(message, options) {\n        this.options = options ?? defaultOptions;\n        this._message = {\n            subscribe: message.subscribe,\n            set: (value, options) => message.update(($message) => this.update($message, value, options?.concatenateArray ?? false)),\n            update: (updater, options) => message.update(($message) => this.update($message, updater($message), options?.concatenateArray ?? false))\n        };\n    }\n    update(current, newData, concatenateArray = false) {\n        if (this._flashTimeout)\n            clearTimeout(this.flashTimeout);\n        // Need to do a per-element comparison here, since update will be called\n        // when going to the same route, while keeping the old flash message,\n        // making it display multiple times.\n        if (concatenateArray && Array.isArray(newData)) {\n            if (Array.isArray(current)) {\n                if (current.length > 0 &&\n                    newData.length > 0 &&\n                    current[current.length - 1] === newData[newData.length - 1]) {\n                    return current;\n                }\n                else {\n                    return current.concat(newData);\n                }\n            }\n        }\n        if (browser && newData !== undefined && this.options.clearAfterMs) {\n            this._flashTimeout = setTimeout(() => {\n                this.message.set(undefined);\n            }, this.options.clearAfterMs);\n        }\n        return newData;\n    }\n}\n", "export const defaultOptions = {\n    clearArray: false,\n    clearOnNavigate: true,\n    clearAfterMs: 0,\n    flashCookieOptions: {\n        path: '/',\n        maxAge: 120,\n        httpOnly: false,\n        sameSite: 'strict'\n    }\n};\nexport function mergeOptions(parentOptions, options) {\n    return {\n        ...parentOptions,\n        ...options,\n        flashCookieOptions: {\n            ...parentOptions.flashCookieOptions,\n            ...options?.flashCookieOptions\n        }\n    };\n}\n", "/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { writable } from 'svelte/store';\nimport { FlashMessage } from './flashMessage.js';\nimport { mergeOptions } from './options.js';\nimport { onDestroy } from 'svelte';\nexport class FlashRouter {\n    routes = new Map();\n    messageStore;\n    constructor() {\n        this.messageStore = writable();\n        this.routes.set('', new FlashMessage(this.messageStore));\n        onDestroy(() => {\n            for (const route of this.routes.values()) {\n                clearTimeout(route.flashTimeout);\n            }\n        });\n    }\n    get defaultRoute() {\n        return this.routes.get('');\n    }\n    has(routeId) {\n        return this.routes.has(routeId);\n    }\n    getFlashMessage(routeId) {\n        if (!routeId)\n            return this.defaultRoute;\n        if (this.routes.has(routeId))\n            return this.routes.get(routeId);\n        return this.getClosestRoute(routeId);\n    }\n    getClosestRoute(routeId) {\n        const matchingRoutes = Array.from(this.routes.keys()).filter((key) => routeId.includes(key));\n        if (!matchingRoutes.length) {\n            return this.defaultRoute;\n        }\n        const longestRoute = matchingRoutes.reduce((prev, curr) => curr.length > prev.length ? curr : prev);\n        return this.routes.get(longestRoute);\n    }\n    createRoute(routeId, data, options) {\n        const closest = this.getClosestRoute(routeId);\n        const newRoute = new FlashMessage(this.messageStore, mergeOptions(closest.options, options));\n        // Update flash data\n        newRoute.message.set(data);\n        this.routes.set(routeId, newRoute);\n        return newRoute;\n    }\n}\n"],
  "mappings": "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",
  "names": ["options"]
}
