import {
  BROWSER
} from "./chunk-IP2U24VQ.js";
import "./chunk-X7HCJ7ZS.js";
import {
  flip
} from "./chunk-KYWTOJ5J.js";
import "./chunk-ZB6PEJPW.js";
import {
  readable,
  writable
} from "./chunk-WLLGEP5X.js";
import {
  fade,
  fly,
  scale,
  slide
} from "./chunk-XIWMVCSC.js";
import {
  cubicIn
} from "./chunk-VFRMSNTO.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  add_render_callback,
  add_transform,
  afterUpdate,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_animation,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  fix_and_outro_and_destroy_block,
  fix_position,
  flush,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  get_svelte_dataset,
  globals,
  group_outros,
  head_selector,
  init,
  init_binding_group,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  prop_dev,
  run_all,
  safe_not_equal,
  select_multiple_value,
  select_option,
  select_options,
  select_value,
  setContext,
  set_attributes,
  set_data_dev,
  set_input_value,
  set_store_value,
  set_style,
  space,
  src_url_equal,
  subscribe,
  svg_element,
  text,
  to_number,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-Z3QZFIAR.js";
import "./chunk-4DGM7FRE.js";
import "./chunk-25V3TAZK.js";

// node_modules/@skeletonlabs/skeleton/dist/utilities/CodeBlock/stores.js
var storeHighlightJs = writable(void 0);

// node_modules/@skeletonlabs/skeleton/dist/utilities/Popup/popup.js
var storePopup = writable(void 0);
function popup(triggerNode, args) {
  const { computePosition, autoUpdate, offset, shift, flip: flip2, arrow, size, autoPlacement, hide, inline } = get_store_value(storePopup);
  const popupState = {
    open: false,
    autoUpdateCleanup: () => {
    }
  };
  const focusableAllowedList = ':is(a[href], button, input, textarea, select, details, [tabindex]):not([tabindex="-1"])';
  let focusablePopupElements;
  const documentationLink = "https://www.skeleton.dev/utilities/popups";
  let elemPopup;
  let elemArrow;
  function setDomElements() {
    elemPopup = document.querySelector(`[data-popup="${args.target}"]`) ?? document.createElement("div");
    elemArrow = elemPopup.querySelector(`.arrow`) ?? document.createElement("div");
  }
  setDomElements();
  function render() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!elemPopup)
      throw new Error(`The data-popup="${args.target}" element was not found. ${documentationLink}`);
    if (!computePosition)
      throw new Error(`Floating UI 'computePosition' not found for data-popup="${args.target}". ${documentationLink}`);
    if (!offset)
      throw new Error(`Floating UI 'offset' not found for data-popup="${args.target}". ${documentationLink}`);
    if (!shift)
      throw new Error(`Floating UI 'shift' not found for data-popup="${args.target}". ${documentationLink}`);
    if (!flip2)
      throw new Error(`Floating UI 'flip' not found for data-popup="${args.target}". ${documentationLink}`);
    if (!arrow)
      throw new Error(`Floating UI 'arrow' not found for data-popup="${args.target}". ${documentationLink}`);
    const optionalMiddleware = [];
    if (size)
      optionalMiddleware.push(size((_a = args.middleware) == null ? void 0 : _a.size));
    if (autoPlacement)
      optionalMiddleware.push(autoPlacement((_b = args.middleware) == null ? void 0 : _b.autoPlacement));
    if (hide)
      optionalMiddleware.push(hide((_c = args.middleware) == null ? void 0 : _c.hide));
    if (inline)
      optionalMiddleware.push(inline((_d = args.middleware) == null ? void 0 : _d.inline));
    computePosition(triggerNode, elemPopup, {
      placement: args.placement ?? "bottom",
      // Middleware - NOTE: the order matters:
      // https://floating-ui.com/docs/middleware#ordering
      middleware: [
        // https://floating-ui.com/docs/offset
        offset(((_e = args.middleware) == null ? void 0 : _e.offset) ?? 8),
        // https://floating-ui.com/docs/shift
        shift(((_f = args.middleware) == null ? void 0 : _f.shift) ?? { padding: 8 }),
        // https://floating-ui.com/docs/flip
        flip2((_g = args.middleware) == null ? void 0 : _g.flip),
        // https://floating-ui.com/docs/arrow
        arrow(((_h = args.middleware) == null ? void 0 : _h.arrow) ?? { element: elemArrow || null }),
        // Implement optional middleware
        ...optionalMiddleware
      ]
    }).then(({ x, y, placement, middlewareData }) => {
      Object.assign(elemPopup.style, {
        left: `${x}px`,
        top: `${y}px`
      });
      if (elemArrow) {
        const { x: arrowX, y: arrowY } = middlewareData.arrow;
        const staticSide = {
          top: "bottom",
          right: "left",
          bottom: "top",
          left: "right"
        }[placement.split("-")[0]];
        Object.assign(elemArrow.style, {
          left: arrowX != null ? `${arrowX}px` : "",
          top: arrowY != null ? `${arrowY}px` : "",
          right: "",
          bottom: "",
          [staticSide]: "-4px"
        });
      }
    });
  }
  function open() {
    if (!elemPopup)
      return;
    popupState.open = true;
    if (args.state)
      args.state({ state: popupState.open });
    render();
    elemPopup.style.display = "block";
    elemPopup.style.opacity = "1";
    elemPopup.style.pointerEvents = "auto";
    elemPopup.removeAttribute("inert");
    popupState.autoUpdateCleanup = autoUpdate(triggerNode, elemPopup, render);
    focusablePopupElements = Array.from(elemPopup == null ? void 0 : elemPopup.querySelectorAll(focusableAllowedList));
  }
  function close(callback) {
    if (!elemPopup)
      return;
    const cssTransitionDuration = parseFloat(window.getComputedStyle(elemPopup).transitionDuration.replace("s", "")) * 1e3;
    setTimeout(() => {
      popupState.open = false;
      if (args.state)
        args.state({ state: popupState.open });
      elemPopup.style.opacity = "0";
      elemPopup.setAttribute("inert", "");
      if (popupState.autoUpdateCleanup)
        popupState.autoUpdateCleanup();
      if (callback)
        callback();
    }, cssTransitionDuration);
  }
  function toggle() {
    popupState.open === false ? open() : close();
  }
  function onWindowClick(event) {
    if (popupState.open === false)
      return;
    if (triggerNode.contains(event.target))
      return;
    if (elemPopup && elemPopup.contains(event.target) === false) {
      close();
      return;
    }
    const closeQueryString = args.closeQuery === void 0 ? "a[href], button" : args.closeQuery;
    if (closeQueryString === "")
      return;
    const closableMenuElements = elemPopup == null ? void 0 : elemPopup.querySelectorAll(closeQueryString);
    closableMenuElements == null ? void 0 : closableMenuElements.forEach((elem) => {
      if (elem.contains(event.target))
        close();
    });
  }
  const onWindowKeyDown = (event) => {
    if (popupState.open === false)
      return;
    const key = event.key;
    if (key === "Escape") {
      event.preventDefault();
      triggerNode.focus();
      close();
      return;
    }
    focusablePopupElements = Array.from(elemPopup == null ? void 0 : elemPopup.querySelectorAll(focusableAllowedList));
    const triggerMenuFocused = popupState.open && document.activeElement === triggerNode;
    if (triggerMenuFocused && (key === "ArrowDown" || key === "Tab") && focusableAllowedList.length > 0 && focusablePopupElements.length > 0) {
      event.preventDefault();
      focusablePopupElements[0].focus();
    }
  };
  switch (args.event) {
    case "click":
      triggerNode.addEventListener("click", toggle, true);
      window.addEventListener("click", onWindowClick, true);
      break;
    case "hover":
      triggerNode.addEventListener("mouseover", open, true);
      triggerNode.addEventListener("mouseleave", () => close(), true);
      break;
    case "focus-blur":
      triggerNode.addEventListener("focus", toggle, true);
      triggerNode.addEventListener("blur", () => close(), true);
      break;
    case "focus-click":
      triggerNode.addEventListener("focus", open, true);
      window.addEventListener("click", onWindowClick, true);
      break;
    default:
      throw new Error(`Event value of '${args.event}' is not supported. ${documentationLink}`);
  }
  window.addEventListener("keydown", onWindowKeyDown, true);
  render();
  return {
    update(newArgs) {
      close(() => {
        args = newArgs;
        render();
        setDomElements();
      });
    },
    destroy() {
      triggerNode.removeEventListener("click", toggle, true);
      triggerNode.removeEventListener("mouseover", open, true);
      triggerNode.removeEventListener("mouseleave", () => close(), true);
      triggerNode.removeEventListener("focus", toggle, true);
      triggerNode.removeEventListener("focus", open, true);
      triggerNode.removeEventListener("blur", () => close(), true);
      window.removeEventListener("click", onWindowClick, true);
      window.removeEventListener("keydown", onWindowKeyDown, true);
    }
  };
}

// node_modules/@skeletonlabs/skeleton/dist/utilities/TableOfContents/stores.js
var tocStore = writable([]);
var tocActiveId = writable(void 0);

// node_modules/@skeletonlabs/skeleton/dist/utilities/Drawer/stores.js
var DRAWER_STORE_KEY = "drawerStore";
function getDrawerStore() {
  const drawerStore = getContext(DRAWER_STORE_KEY);
  if (!drawerStore)
    throw new Error("drawerStore is not initialized. Please ensure that `initializeStores()` is invoked in the root layout file of this app!");
  return drawerStore;
}
function initializeDrawerStore() {
  const drawerStore = drawerService();
  return setContext(DRAWER_STORE_KEY, drawerStore);
}
function drawerService() {
  const { subscribe: subscribe2, set, update } = writable({});
  return {
    subscribe: subscribe2,
    set,
    update,
    /** Open the drawer. */
    open: (newSettings) => update(() => {
      return { open: true, ...newSettings };
    }),
    /** Close the drawer. */
    close: () => update((d) => {
      d.open = false;
      return d;
    })
  };
}

// node_modules/@skeletonlabs/skeleton/dist/utilities/Modal/stores.js
var MODAL_STORE_KEY = "modalStore";
function getModalStore() {
  const modalStore = getContext(MODAL_STORE_KEY);
  if (!modalStore)
    throw new Error("modalStore is not initialized. Please ensure that `initializeStores()` is invoked in the root layout file of this app!");
  return modalStore;
}
function initializeModalStore() {
  const modalStore = modalService();
  return setContext(MODAL_STORE_KEY, modalStore);
}
function modalService() {
  const { subscribe: subscribe2, set, update } = writable([]);
  return {
    subscribe: subscribe2,
    set,
    update,
    /** Append to end of queue. */
    trigger: (modal) => update((mStore) => {
      mStore.push(modal);
      return mStore;
    }),
    /**  Remove first item in queue. */
    close: () => update((mStore) => {
      if (mStore.length > 0)
        mStore.shift();
      return mStore;
    }),
    /** Remove all items from queue. */
    clear: () => set([])
  };
}

// node_modules/@skeletonlabs/skeleton/dist/utilities/Toast/stores.js
var toastDefaults = { message: "Missing Toast Message", autohide: true, timeout: 5e3 };
var TOAST_STORE_KEY = "toastStore";
function getToastStore() {
  const toastStore = getContext(TOAST_STORE_KEY);
  if (!toastStore)
    throw new Error("toastStore is not initialized. Please ensure that `initializeStores()` is invoked in the root layout file of this app!");
  return toastStore;
}
function initializeToastStore() {
  const toastStore = toastService();
  return setContext(TOAST_STORE_KEY, toastStore);
}
function randomUUID() {
  const random = Math.random();
  return Number(random).toString(32);
}
function toastService() {
  const { subscribe: subscribe2, set, update } = writable([]);
  const close = (id) => update((tStore) => {
    if (tStore.length > 0) {
      const index = tStore.findIndex((t) => t.id === id);
      const selectedToast = tStore[index];
      if (selectedToast) {
        if (selectedToast.callback)
          selectedToast.callback({ id, status: "closed" });
        if (selectedToast.timeoutId)
          clearTimeout(selectedToast.timeoutId);
        tStore.splice(index, 1);
      }
    }
    return tStore;
  });
  function handleAutoHide(toast) {
    if (toast.autohide === true) {
      return setTimeout(() => {
        close(toast.id);
      }, toast.timeout);
    }
  }
  return {
    subscribe: subscribe2,
    close,
    /** Add a new toast to the queue. */
    trigger: (toast) => {
      const id = randomUUID();
      update((tStore) => {
        if (toast && toast.callback)
          toast.callback({ id, status: "queued" });
        if (toast.hideDismiss)
          toast.autohide = true;
        const tMerged = { ...toastDefaults, ...toast, id };
        tMerged.timeoutId = handleAutoHide(tMerged);
        tStore.push(tMerged);
        return tStore;
      });
      return id;
    },
    /** Remain visible on hover */
    freeze: (index) => update((tStore) => {
      if (tStore.length > 0)
        clearTimeout(tStore[index].timeoutId);
      return tStore;
    }),
    /** Cancel remain visible on leave */
    unfreeze: (index) => update((tStore) => {
      if (tStore.length > 0)
        tStore[index].timeoutId = handleAutoHide(tStore[index]);
      return tStore;
    }),
    /** Remove all toasts from queue */
    clear: () => set([])
  };
}

// node_modules/@skeletonlabs/skeleton/dist/utilities/index.js
function initializeStores() {
  initializeModalStore();
  initializeToastStore();
  initializeDrawerStore();
}

// node_modules/@skeletonlabs/skeleton/dist/utilities/LocalStorageStore/LocalStorageStore.js
var stores = {};
function getStorage(type) {
  return type === "local" ? localStorage : sessionStorage;
}
function localStorageStore(key, initialValue, options) {
  const serializer = (options == null ? void 0 : options.serializer) ?? JSON;
  const storageType = (options == null ? void 0 : options.storage) ?? "local";
  function updateStorage(key2, value) {
    if (!BROWSER)
      return;
    getStorage(storageType).setItem(key2, serializer.stringify(value));
  }
  if (!stores[key]) {
    const store = writable(initialValue, (set2) => {
      const json = BROWSER ? getStorage(storageType).getItem(key) : null;
      if (json) {
        set2(serializer.parse(json));
      }
      if (BROWSER) {
        const handleStorage = (event) => {
          if (event.key === key)
            set2(event.newValue ? serializer.parse(event.newValue) : null);
        };
        window.addEventListener("storage", handleStorage);
        return () => window.removeEventListener("storage", handleStorage);
      }
    });
    const { subscribe: subscribe2, set } = store;
    stores[key] = {
      set(value) {
        updateStorage(key, value);
        set(value);
      },
      update(updater) {
        const value = updater(get_store_value(store));
        updateStorage(key, value);
        set(value);
      },
      subscribe: subscribe2
    };
  }
  return stores[key];
}

// node_modules/@skeletonlabs/skeleton/dist/utilities/LightSwitch/lightswitch.js
var modeOsPrefers = localStorageStore("modeOsPrefers", false);
var modeUserPrefers = localStorageStore("modeUserPrefers", void 0);
var modeCurrent = localStorageStore("modeCurrent", false);
function getModeOsPrefers() {
  const prefersLightMode = window.matchMedia("(prefers-color-scheme: light)").matches;
  modeOsPrefers.set(prefersLightMode);
  return prefersLightMode;
}
function getModeUserPrefers() {
  return get_store_value(modeUserPrefers);
}
function getModeAutoPrefers() {
  const os = getModeOsPrefers();
  const user = getModeUserPrefers();
  const modeValue = user !== void 0 ? user : os;
  return modeValue;
}
function setModeUserPrefers(value) {
  modeUserPrefers.set(value);
}
function setModeCurrent(value) {
  const elemHtmlClasses = document.documentElement.classList;
  const classDark = `dark`;
  value === true ? elemHtmlClasses.remove(classDark) : elemHtmlClasses.add(classDark);
  modeCurrent.set(value);
}
function setInitialClassState() {
  const elemHtmlClasses = document.documentElement.classList;
  const condLocalStorageUserPrefs = localStorage.getItem("modeUserPrefers") === "false";
  const condLocalStorageUserPrefsExists = !("modeUserPrefers" in localStorage);
  const condMatchMedia = window.matchMedia("(prefers-color-scheme: dark)").matches;
  if (condLocalStorageUserPrefs || condLocalStorageUserPrefsExists && condMatchMedia) {
    elemHtmlClasses.add("dark");
  } else {
    elemHtmlClasses.remove("dark");
  }
}
function autoModeWatcher() {
  const mql = window.matchMedia("(prefers-color-scheme: light)");
  function setMode(value) {
    const elemHtmlClasses = document.documentElement.classList;
    const classDark = `dark`;
    value === true ? elemHtmlClasses.remove(classDark) : elemHtmlClasses.add(classDark);
  }
  setMode(mql.matches);
  mql.onchange = () => {
    setMode(mql.matches);
  };
}

// node_modules/@skeletonlabs/skeleton/dist/utilities/PrefersReducedMotion/PrefersReducedMotion.js
var reducedMotionQuery = "(prefers-reduced-motion: reduce)";
function prefersReducedMotion() {
  if (!BROWSER)
    return false;
  return window.matchMedia(reducedMotionQuery).matches;
}
var prefersReducedMotionStore = readable(prefersReducedMotion(), (set) => {
  if (BROWSER) {
    const setReducedMotion = (event) => {
      set(event.matches);
    };
    const mediaQueryList = window.matchMedia(reducedMotionQuery);
    mediaQueryList.addEventListener("change", setReducedMotion);
    return () => {
      mediaQueryList.removeEventListener("change", setReducedMotion);
    };
  }
});

// node_modules/@skeletonlabs/skeleton/dist/components/Table/utils.js
function tableSourceMapper(source, keys) {
  return source.map((row) => {
    const mappedRow = {};
    keys.forEach((key) => mappedRow[key] = row[key]);
    return mappedRow;
  });
}
function tableSourceValues(source) {
  return source.map((row) => Object.values(row));
}
function tableMapperValues(source, keys) {
  return tableSourceValues(tableSourceMapper(source, keys));
}

// node_modules/@skeletonlabs/skeleton/dist/actions/Clipboard/clipboard.js
function clipboard(node, args) {
  if (!window.isSecureContext) {
    console.error("Clipboard action failed: app not running in secure context, see: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard");
    return {};
  }
  const fireCopyCompleteEvent = () => {
    node.dispatchEvent(new CustomEvent("copyComplete"));
  };
  const onClick = () => {
    if (typeof args === "object") {
      if ("element" in args) {
        const element2 = document.querySelector(`[data-clipboard="${args.element}"]`);
        if (!element2)
          throw new Error(`Missing HTMLElement with an attribute of [data-clipboard="${args.element}"]`);
        copyToClipboard(element2.innerHTML, "text/html").then(fireCopyCompleteEvent);
        return;
      }
      if ("input" in args) {
        const input = document.querySelector(`[data-clipboard="${args.input}"]`);
        if (!input)
          throw new Error(`Missing HTMLInputElement with an attribute of [data-clipboard="${args.input}"]`);
        copyToClipboard(input.value).then(fireCopyCompleteEvent);
        return;
      }
    }
    copyToClipboard(args).then(fireCopyCompleteEvent);
  };
  node.addEventListener("click", onClick);
  return {
    update(newArgs) {
      args = newArgs;
    },
    destroy() {
      node.removeEventListener("click", onClick);
    }
  };
}
async function copyToClipboard(data, mimeType = "text/plain") {
  if (navigator.clipboard.write) {
    await navigator.clipboard.write([
      new ClipboardItem({
        [mimeType]: new Blob([data], {
          type: mimeType
        }),
        ["text/plain"]: new Blob([data], {
          type: "text/plain"
        })
      })
    ]);
  } else {
    await new Promise((resolve) => {
      resolve(navigator.clipboard.writeText(String(data)));
    });
  }
}

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/filter.js
function filter(node, filterName) {
  if (filterName === void 0)
    return;
  const applyFilter = () => {
    node.setAttribute("style", `filter: url("${filterName}")`);
  };
  applyFilter();
  return {
    update(newArgs) {
      filterName = newArgs;
      applyFilter();
    }
  };
}

// node_modules/@skeletonlabs/skeleton/dist/actions/FocusTrap/focusTrap.js
function focusTrap(node, enabled) {
  const elemWhitelist = 'a[href]:not([tabindex="-1"]), button:not([tabindex="-1"]), input:not([tabindex="-1"]), textarea:not([tabindex="-1"]), select:not([tabindex="-1"]), details:not([tabindex="-1"]), [tabindex]:not([tabindex="-1"])';
  let elemFirst;
  let elemLast;
  function onFirstElemKeydown(e) {
    if (e.shiftKey && e.code === "Tab") {
      e.preventDefault();
      elemLast.focus();
    }
  }
  function onLastElemKeydown(e) {
    if (!e.shiftKey && e.code === "Tab") {
      e.preventDefault();
      elemFirst.focus();
    }
  }
  const sortByTabIndex = (focusableElems) => {
    return focusableElems.filter((elem) => elem.tabIndex >= 0).sort((a, b) => {
      if (a.tabIndex === 0 && b.tabIndex > 0)
        return 1;
      else if (a.tabIndex > 0 && b.tabIndex === 0)
        return -1;
      else
        return a.tabIndex - b.tabIndex;
    });
  };
  const getFocusTrapTarget = (elemFirst2) => {
    const focusindexElements = [...node.querySelectorAll("[data-focusindex]")];
    if (!focusindexElements || focusindexElements.length === 0)
      return elemFirst2;
    return focusindexElements.sort((a, b) => {
      return +a.dataset.focusindex - +b.dataset.focusindex;
    })[0] || elemFirst2;
  };
  const onScanElements = (fromObserver) => {
    if (enabled === false)
      return;
    const focusableElems = sortByTabIndex(Array.from(node.querySelectorAll(elemWhitelist)));
    if (focusableElems.length) {
      elemFirst = focusableElems[0];
      elemLast = focusableElems[focusableElems.length - 1];
      if (!fromObserver)
        getFocusTrapTarget(elemFirst).focus();
      elemFirst.addEventListener("keydown", onFirstElemKeydown);
      elemLast.addEventListener("keydown", onLastElemKeydown);
    }
  };
  onScanElements(false);
  function onCleanUp() {
    if (elemFirst)
      elemFirst.removeEventListener("keydown", onFirstElemKeydown);
    if (elemLast)
      elemLast.removeEventListener("keydown", onLastElemKeydown);
  }
  const onObservationChange = (mutationRecords, observer2) => {
    if (mutationRecords.length) {
      onCleanUp();
      onScanElements(true);
    }
    return observer2;
  };
  const observer = new MutationObserver(onObservationChange);
  observer.observe(node, { childList: true, subtree: true });
  return {
    update(newArgs) {
      enabled = newArgs;
      newArgs ? onScanElements(false) : onCleanUp();
    },
    destroy() {
      onCleanUp();
      observer.disconnect();
    }
  };
}

// node_modules/@skeletonlabs/skeleton/dist/utilities/TableOfContents/crawler.js
function tocCrawler(node, args) {
  var _a;
  let queryElements = "h2, h3, h4, h5, h6";
  let scrollTarget = "body";
  let headings;
  let permalinks = [];
  function init2() {
    if (args == null ? void 0 : args.queryElements)
      queryElements = args.queryElements;
    if (args == null ? void 0 : args.scrollTarget)
      scrollTarget = args.scrollTarget;
    headings = node.querySelectorAll(queryElements);
    permalinks = [];
    queryHeadings();
  }
  function queryHeadings() {
    headings == null ? void 0 : headings.forEach((elemHeading) => {
      var _a2, _b, _c, _d;
      if (elemHeading.hasAttribute("data-toc-ignore"))
        return;
      if ((args == null ? void 0 : args.mode) === "generate" && !elemHeading.id) {
        const newHeadingId = (_b = (_a2 = elemHeading.firstChild) == null ? void 0 : _a2.textContent) == null ? void 0 : _b.trim().replaceAll(/[^a-zA-Z0-9 ]/g, "").replaceAll(" ", "-").toLowerCase();
        const prefix = args.prefix ? `${args.prefix}-` : "";
        const suffix = args.suffix ? `-${args.suffix}` : "";
        elemHeading.id = prefix + newHeadingId + suffix;
      }
      permalinks.push({
        element: elemHeading.nodeName.toLowerCase(),
        id: elemHeading.id,
        text: ((_d = (_c = elemHeading.firstChild) == null ? void 0 : _c.textContent) == null ? void 0 : _d.trim()) || ""
      });
    });
    tocStore.set(permalinks);
  }
  function onWindowScroll(e) {
    if (!(headings == null ? void 0 : headings.length))
      return;
    const targetElem = e.target;
    if (!(targetElem instanceof HTMLElement))
      throw new Error("scrollTarget is not an HTMLElement");
    const scrollableTop = targetElem.getBoundingClientRect().top || 0;
    const headingSizeThreshold = 40;
    for (const elemHeading of headings) {
      const headerBoundTop = elemHeading.getBoundingClientRect().top;
      const offsetTop = headerBoundTop - scrollableTop + headingSizeThreshold;
      if (offsetTop >= 0)
        return tocActiveId.set(elemHeading.id);
    }
  }
  init2();
  if (scrollTarget)
    (_a = document.querySelector(scrollTarget)) == null ? void 0 : _a.addEventListener("scroll", onWindowScroll);
  return {
    update(newArgs) {
      args = newArgs;
      init2();
    },
    destroy() {
      var _a2;
      if (scrollTarget)
        (_a2 = document.querySelector(scrollTarget)) == null ? void 0 : _a2.removeEventListener("scroll", onWindowScroll);
    }
  };
}

// node_modules/@skeletonlabs/skeleton/dist/components/Accordion/Accordion.svelte
var file = "node_modules/@skeletonlabs/skeleton/dist/components/Accordion/Accordion.svelte";
function create_fragment(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "accordion " + /*classesBase*/
      ctx[0]);
      attr_dev(div, "data-testid", "accordion");
      add_location(div, file, 46, 0, 1776);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesBase*/
      1 && div_class_value !== (div_class_value = "accordion " + /*classesBase*/
      ctx2[0])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let classesBase;
  let $prefersReducedMotionStore;
  validate_store(prefersReducedMotionStore, "prefersReducedMotionStore");
  component_subscribe($$self, prefersReducedMotionStore, ($$value) => $$invalidate(20, $prefersReducedMotionStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Accordion", slots, ["default"]);
  let { autocollapse = false } = $$props;
  let { width = "w-full" } = $$props;
  let { spacing = "space-y-1" } = $$props;
  let { disabled = false } = $$props;
  let { padding = "py-2 px-4" } = $$props;
  let { hover = "hover:bg-primary-hover-token" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { caretOpen = "rotate-180" } = $$props;
  let { caretClosed = "" } = $$props;
  let { regionControl = "" } = $$props;
  let { regionPanel = "space-y-4" } = $$props;
  let { regionCaret = "" } = $$props;
  let { transitions = !$prefersReducedMotionStore } = $$props;
  let { transitionIn = slide } = $$props;
  let { transitionInParams = { duration: 200 } } = $$props;
  let { transitionOut = slide } = $$props;
  let { transitionOutParams = { duration: 200 } } = $$props;
  const active = writable(null);
  setContext("active", active);
  setContext("autocollapse", autocollapse);
  setContext("disabled", disabled);
  setContext("padding", padding);
  setContext("hover", hover);
  setContext("rounded", rounded);
  setContext("caretOpen", caretOpen);
  setContext("caretClosed", caretClosed);
  setContext("regionControl", regionControl);
  setContext("regionPanel", regionPanel);
  setContext("regionCaret", regionCaret);
  setContext("transitions", transitions);
  setContext("transitionIn", transitionIn);
  setContext("transitionInParams", transitionInParams);
  setContext("transitionOut", transitionOut);
  setContext("transitionOutParams", transitionOutParams);
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("autocollapse" in $$new_props)
      $$invalidate(1, autocollapse = $$new_props.autocollapse);
    if ("width" in $$new_props)
      $$invalidate(2, width = $$new_props.width);
    if ("spacing" in $$new_props)
      $$invalidate(3, spacing = $$new_props.spacing);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("padding" in $$new_props)
      $$invalidate(5, padding = $$new_props.padding);
    if ("hover" in $$new_props)
      $$invalidate(6, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(7, rounded = $$new_props.rounded);
    if ("caretOpen" in $$new_props)
      $$invalidate(8, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$new_props)
      $$invalidate(9, caretClosed = $$new_props.caretClosed);
    if ("regionControl" in $$new_props)
      $$invalidate(10, regionControl = $$new_props.regionControl);
    if ("regionPanel" in $$new_props)
      $$invalidate(11, regionPanel = $$new_props.regionPanel);
    if ("regionCaret" in $$new_props)
      $$invalidate(12, regionCaret = $$new_props.regionCaret);
    if ("transitions" in $$new_props)
      $$invalidate(13, transitions = $$new_props.transitions);
    if ("transitionIn" in $$new_props)
      $$invalidate(14, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$new_props)
      $$invalidate(15, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$new_props)
      $$invalidate(16, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$new_props)
      $$invalidate(17, transitionOutParams = $$new_props.transitionOutParams);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    slide,
    prefersReducedMotionStore,
    writable,
    setContext,
    autocollapse,
    width,
    spacing,
    disabled,
    padding,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    regionControl,
    regionPanel,
    regionCaret,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    active,
    classesBase,
    $prefersReducedMotionStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("autocollapse" in $$props)
      $$invalidate(1, autocollapse = $$new_props.autocollapse);
    if ("width" in $$props)
      $$invalidate(2, width = $$new_props.width);
    if ("spacing" in $$props)
      $$invalidate(3, spacing = $$new_props.spacing);
    if ("disabled" in $$props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("padding" in $$props)
      $$invalidate(5, padding = $$new_props.padding);
    if ("hover" in $$props)
      $$invalidate(6, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(7, rounded = $$new_props.rounded);
    if ("caretOpen" in $$props)
      $$invalidate(8, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$props)
      $$invalidate(9, caretClosed = $$new_props.caretClosed);
    if ("regionControl" in $$props)
      $$invalidate(10, regionControl = $$new_props.regionControl);
    if ("regionPanel" in $$props)
      $$invalidate(11, regionPanel = $$new_props.regionPanel);
    if ("regionCaret" in $$props)
      $$invalidate(12, regionCaret = $$new_props.regionCaret);
    if ("transitions" in $$props)
      $$invalidate(13, transitions = $$new_props.transitions);
    if ("transitionIn" in $$props)
      $$invalidate(14, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$props)
      $$invalidate(15, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$props)
      $$invalidate(16, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$props)
      $$invalidate(17, transitionOutParams = $$new_props.transitionOutParams);
    if ("classesBase" in $$props)
      $$invalidate(0, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(0, classesBase = `${width} ${spacing} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    classesBase,
    autocollapse,
    width,
    spacing,
    disabled,
    padding,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    regionControl,
    regionPanel,
    regionCaret,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    $$scope,
    slots
  ];
}
var Accordion = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      autocollapse: 1,
      width: 2,
      spacing: 3,
      disabled: 4,
      padding: 5,
      hover: 6,
      rounded: 7,
      caretOpen: 8,
      caretClosed: 9,
      regionControl: 10,
      regionPanel: 11,
      regionCaret: 12,
      transitions: 13,
      transitionIn: 14,
      transitionInParams: 15,
      transitionOut: 16,
      transitionOutParams: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Accordion",
      options,
      id: create_fragment.name
    });
  }
  get autocollapse() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocollapse(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretOpen() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretOpen(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretClosed() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretClosed(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionControl() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionControl(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionPanel() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionPanel(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionCaret() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionCaret(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitions() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitions(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionIn() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionIn(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionInParams() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionInParams(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOut() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOut(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOutParams() {
    throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOutParams(value) {
    throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Accordion_default = Accordion;

// node_modules/@skeletonlabs/skeleton/dist/internal/transitions.js
function dynamicTransition(node, dynParams) {
  const { transition, params, enabled } = dynParams;
  if (enabled)
    return transition(node, params);
  if ("duration" in params)
    return transition(node, { duration: 0 });
  return { duration: 0 };
}

// node_modules/@skeletonlabs/skeleton/dist/components/Accordion/AccordionItem.svelte
var file2 = "node_modules/@skeletonlabs/skeleton/dist/components/Accordion/AccordionItem.svelte";
var get_content_slot_changes = (dirty) => ({});
var get_content_slot_context = (ctx) => ({});
var get_iconOpen_slot_changes = (dirty) => ({});
var get_iconOpen_slot_context = (ctx) => ({});
var get_iconClosed_slot_changes = (dirty) => ({});
var get_iconClosed_slot_context = (ctx) => ({});
var get_summary_slot_changes = (dirty) => ({});
var get_summary_slot_context = (ctx) => ({});
var get_lead_slot_changes = (dirty) => ({});
var get_lead_slot_context = (ctx) => ({});
function create_if_block_3(ctx) {
  let div;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[30].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    get_lead_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "accordion-lead");
      add_location(div, file2, 87, 3, 2903);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              get_lead_slot_changes
            ),
            get_lead_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(87:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function fallback_block_3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(summary)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(summary)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(94:24) (summary)",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let div;
  let html_tag;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      html_tag = claim_html_tag(div_nodes, false);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(div, "class", div_class_value = "accordion-summary-caret " + /*classesControlCaret*/
      ctx[11]);
      add_location(div, file2, 108, 3, 3492);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      html_tag.m(
        /*svgCaretIcon*/
        ctx[14],
        div
      );
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*classesControlCaret*/
      2048 && div_class_value !== (div_class_value = "accordion-summary-caret " + /*classesControlCaret*/
      ctx2[11])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(107:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block_2, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*openState*/
      ctx2[8]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "accordion-summary-icons " + /*classesControlIcons*/
      ctx[10]);
      add_location(div, file2, 99, 3, 3233);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty[0] & /*classesControlIcons*/
      1024 && div_class_value !== (div_class_value = "accordion-summary-icons " + /*classesControlIcons*/
      ctx2[10])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(97:2) {#if $$slots.iconClosed || $$slots.iconOpen}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let current;
  const iconOpen_slot_template = (
    /*#slots*/
    ctx[30].iconOpen
  );
  const iconOpen_slot = create_slot(
    iconOpen_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    get_iconOpen_slot_context
  );
  const iconOpen_slot_or_fallback = iconOpen_slot || fallback_block_2(ctx);
  const block = {
    c: function create() {
      if (iconOpen_slot_or_fallback)
        iconOpen_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (iconOpen_slot_or_fallback)
        iconOpen_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (iconOpen_slot_or_fallback) {
        iconOpen_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (iconOpen_slot) {
        if (iconOpen_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            iconOpen_slot,
            iconOpen_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              iconOpen_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              get_iconOpen_slot_changes
            ),
            get_iconOpen_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconOpen_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconOpen_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (iconOpen_slot_or_fallback)
        iconOpen_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(103:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let current;
  const iconClosed_slot_template = (
    /*#slots*/
    ctx[30].iconClosed
  );
  const iconClosed_slot = create_slot(
    iconClosed_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    get_iconClosed_slot_context
  );
  const iconClosed_slot_or_fallback = iconClosed_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      if (iconClosed_slot_or_fallback)
        iconClosed_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (iconClosed_slot_or_fallback)
        iconClosed_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (iconClosed_slot_or_fallback) {
        iconClosed_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (iconClosed_slot) {
        if (iconClosed_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            iconClosed_slot,
            iconClosed_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              iconClosed_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              get_iconClosed_slot_changes
            ),
            get_iconClosed_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(iconClosed_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(iconClosed_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (iconClosed_slot_or_fallback)
        iconClosed_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(101:4) {#if openState}",
    ctx
  });
  return block;
}
function fallback_block_2(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*svgCaretIcon*/
        ctx[14],
        target,
        anchor
      );
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(104:27) {@html svgCaretIcon}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*svgCaretIcon*/
        ctx[14],
        target,
        anchor
      );
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(102:29) {@html svgCaretIcon}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let div_class_value;
  let div_id_value;
  let div_aria_hidden_value;
  let div_intro;
  let div_outro;
  let current;
  const content_slot_template = (
    /*#slots*/
    ctx[30].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    get_content_slot_context
  );
  const content_slot_or_fallback = content_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (content_slot_or_fallback)
        content_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        id: true,
        role: true,
        "aria-hidden": true,
        "aria-labelledby": true
      });
      var div_nodes = children(div);
      if (content_slot_or_fallback)
        content_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "accordion-panel " + /*classesPanel*/
      ctx[9]);
      attr_dev(div, "id", div_id_value = "accordion-panel-" + /*id*/
      ctx[0]);
      attr_dev(div, "role", "region");
      attr_dev(div, "aria-hidden", div_aria_hidden_value = !/*openState*/
      ctx[8]);
      attr_dev(
        div,
        "aria-labelledby",
        /*id*/
        ctx[0]
      );
      add_location(div, file2, 113, 2, 3632);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (content_slot_or_fallback) {
        content_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (content_slot) {
        if (content_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx,
            /*$$scope*/
            ctx[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[29]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx[29],
              dirty,
              get_content_slot_changes
            ),
            get_content_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*classesPanel*/
      512 && div_class_value !== (div_class_value = "accordion-panel " + /*classesPanel*/
      ctx[9])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*id*/
      1 && div_id_value !== (div_id_value = "accordion-panel-" + /*id*/
      ctx[0])) {
        attr_dev(div, "id", div_id_value);
      }
      if (!current || dirty[0] & /*openState*/
      256 && div_aria_hidden_value !== (div_aria_hidden_value = !/*openState*/
      ctx[8])) {
        attr_dev(div, "aria-hidden", div_aria_hidden_value);
      }
      if (!current || dirty[0] & /*id*/
      1) {
        attr_dev(
          div,
          "aria-labelledby",
          /*id*/
          ctx[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(content_slot_or_fallback, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(div, dynamicTransition, {
            transition: (
              /*transitionIn*/
              ctx[4]
            ),
            params: (
              /*transitionInParams*/
              ctx[5]
            ),
            enabled: (
              /*transitions*/
              ctx[3]
            )
          });
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(content_slot_or_fallback, local);
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div, dynamicTransition, {
          transition: (
            /*transitionOut*/
            ctx[6]
          ),
          params: (
            /*transitionOutParams*/
            ctx[7]
          ),
          enabled: (
            /*transitions*/
            ctx[3]
          )
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (content_slot_or_fallback)
        content_slot_or_fallback.d(detaching);
      if (detaching && div_outro)
        div_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(113:1) {#if openState}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(content)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(content)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(123:24) (content)",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div1;
  let button;
  let t0;
  let div0;
  let t1;
  let current_block_type_index;
  let if_block1;
  let button_class_value;
  let button_aria_controls_value;
  let t2;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[16].lead && create_if_block_3(ctx)
  );
  const summary_slot_template = (
    /*#slots*/
    ctx[30].summary
  );
  const summary_slot = create_slot(
    summary_slot_template,
    ctx,
    /*$$scope*/
    ctx[29],
    get_summary_slot_context
  );
  const summary_slot_or_fallback = summary_slot || fallback_block_3(ctx);
  const if_block_creators = [create_if_block_1, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[16].iconClosed || /*$$slots*/
      ctx2[16].iconOpen
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block2 = (
    /*openState*/
    ctx[8] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      button = element("button");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (summary_slot_or_fallback)
        summary_slot_or_fallback.c();
      t1 = space();
      if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      button = claim_element(div1_nodes, "BUTTON", {
        type: true,
        class: true,
        id: true,
        "aria-expanded": true,
        "aria-controls": true
      });
      var button_nodes = children(button);
      if (if_block0)
        if_block0.l(button_nodes);
      t0 = claim_space(button_nodes);
      div0 = claim_element(button_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (summary_slot_or_fallback)
        summary_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(button_nodes);
      if_block1.l(button_nodes);
      button_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block2)
        if_block2.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "accordion-summary flex-1");
      add_location(div0, file2, 92, 2, 2996);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", button_class_value = "accordion-control " + /*classesControl*/
      ctx[12]);
      attr_dev(
        button,
        "id",
        /*id*/
        ctx[0]
      );
      attr_dev(
        button,
        "aria-expanded",
        /*openState*/
        ctx[8]
      );
      attr_dev(button, "aria-controls", button_aria_controls_value = "accordion-panel-" + /*id*/
      ctx[0]);
      button.disabled = /*disabled*/
      ctx[2];
      add_location(button, file2, 72, 1, 2632);
      attr_dev(div1, "class", div1_class_value = "accordion-item " + /*classesBase*/
      ctx[13]);
      attr_dev(div1, "data-testid", "accordion-item");
      add_location(div1, file2, 70, 0, 2541);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, button);
      if (if_block0)
        if_block0.m(button, null);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, div0);
      if (summary_slot_or_fallback) {
        summary_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(button, t1);
      if_blocks[current_block_type_index].m(button, null);
      append_hydration_dev(div1, t2);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button,
            "click",
            /*setActive*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keyup",
            /*keyup_handler*/
            ctx[33],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keypress",
            /*keypress_handler*/
            ctx[34],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[16].lead
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          65536) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(button, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (summary_slot) {
        if (summary_slot.p && (!current || dirty[0] & /*$$scope*/
        536870912)) {
          update_slot_base(
            summary_slot,
            summary_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[29],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[29]
            ) : get_slot_changes(
              summary_slot_template,
              /*$$scope*/
              ctx2[29],
              dirty,
              get_summary_slot_changes
            ),
            get_summary_slot_context
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(button, null);
      }
      if (!current || dirty[0] & /*classesControl*/
      4096 && button_class_value !== (button_class_value = "accordion-control " + /*classesControl*/
      ctx2[12])) {
        attr_dev(button, "class", button_class_value);
      }
      if (!current || dirty[0] & /*id*/
      1) {
        attr_dev(
          button,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*openState*/
      256) {
        attr_dev(
          button,
          "aria-expanded",
          /*openState*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*id*/
      1 && button_aria_controls_value !== (button_aria_controls_value = "accordion-panel-" + /*id*/
      ctx2[0])) {
        attr_dev(button, "aria-controls", button_aria_controls_value);
      }
      if (!current || dirty[0] & /*disabled*/
      4) {
        prop_dev(
          button,
          "disabled",
          /*disabled*/
          ctx2[2]
        );
      }
      if (
        /*openState*/
        ctx2[8]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*openState*/
          256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classesBase*/
      8192 && div1_class_value !== (div1_class_value = "accordion-item " + /*classesBase*/
      ctx2[13])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(summary_slot_or_fallback, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(summary_slot_or_fallback, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block0)
        if_block0.d();
      if (summary_slot_or_fallback)
        summary_slot_or_fallback.d(detaching);
      if_blocks[current_block_type_index].d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase = "";
var cControl = "text-start w-full flex items-center space-x-4";
var cControlIcons = "fill-current w-3 transition-transform duration-[200ms]";
var cPanel = "";
function instance2($$self, $$props, $$invalidate) {
  let openState;
  let classesBase;
  let classesControl;
  let classesCaretState;
  let classesControlCaret;
  let classesControlIcons;
  let classesPanel;
  let $active, $$unsubscribe_active = noop, $$subscribe_active = () => ($$unsubscribe_active(), $$unsubscribe_active = subscribe(active, ($$value) => $$invalidate(28, $active = $$value)), active);
  $$self.$$.on_destroy.push(() => $$unsubscribe_active());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AccordionItem", slots, ["lead", "summary", "iconClosed", "iconOpen", "content"]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { open = false } = $$props;
  let { id = String(Math.random()) } = $$props;
  let { autocollapse = getContext("autocollapse") } = $$props;
  let { active = getContext("active") } = $$props;
  validate_store(active, "active");
  $$subscribe_active();
  let { disabled = getContext("disabled") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { caretOpen = getContext("caretOpen") } = $$props;
  let { caretClosed = getContext("caretClosed") } = $$props;
  let { regionControl = getContext("regionControl") } = $$props;
  let { regionPanel = getContext("regionPanel") } = $$props;
  let { regionCaret = getContext("regionCaret") } = $$props;
  let { transitions = getContext("transitions") } = $$props;
  let { transitionIn = getContext("transitionIn") } = $$props;
  let { transitionInParams = getContext("transitionInParams") } = $$props;
  let { transitionOut = getContext("transitionOut") } = $$props;
  let { transitionOutParams = getContext("transitionOutParams") } = $$props;
  const svgCaretIcon = `
		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class={classesControlCaret}>
			<path d="M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z" />
		</svg>`;
  function setActive(event) {
    if (autocollapse === true) {
      active.set(id);
    } else {
      $$invalidate(17, open = !open);
    }
    onToggle(event);
  }
  function onToggle(event) {
    const currentOpenState = autocollapse ? $active === id : open;
    dispatch("toggle", {
      event,
      id,
      panelId: `accordion-panel-${id}`,
      open: currentOpenState,
      autocollapse
    });
  }
  if (autocollapse && open)
    setActive();
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(37, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("open" in $$new_props)
      $$invalidate(17, open = $$new_props.open);
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("autocollapse" in $$new_props)
      $$invalidate(18, autocollapse = $$new_props.autocollapse);
    if ("active" in $$new_props)
      $$subscribe_active($$invalidate(1, active = $$new_props.active));
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("padding" in $$new_props)
      $$invalidate(19, padding = $$new_props.padding);
    if ("hover" in $$new_props)
      $$invalidate(20, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(21, rounded = $$new_props.rounded);
    if ("caretOpen" in $$new_props)
      $$invalidate(22, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$new_props)
      $$invalidate(23, caretClosed = $$new_props.caretClosed);
    if ("regionControl" in $$new_props)
      $$invalidate(24, regionControl = $$new_props.regionControl);
    if ("regionPanel" in $$new_props)
      $$invalidate(25, regionPanel = $$new_props.regionPanel);
    if ("regionCaret" in $$new_props)
      $$invalidate(26, regionCaret = $$new_props.regionCaret);
    if ("transitions" in $$new_props)
      $$invalidate(3, transitions = $$new_props.transitions);
    if ("transitionIn" in $$new_props)
      $$invalidate(4, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$new_props)
      $$invalidate(5, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$new_props)
      $$invalidate(6, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$new_props)
      $$invalidate(7, transitionOutParams = $$new_props.transitionOutParams);
    if ("$$scope" in $$new_props)
      $$invalidate(29, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    getContext,
    dynamicTransition,
    dispatch,
    open,
    id,
    cBase,
    cControl,
    cControlIcons,
    cPanel,
    autocollapse,
    active,
    disabled,
    padding,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    regionControl,
    regionPanel,
    regionCaret,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    svgCaretIcon,
    setActive,
    onToggle,
    classesPanel,
    classesControlIcons,
    classesCaretState,
    classesControlCaret,
    openState,
    classesControl,
    classesBase,
    $active
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(37, $$props = assign(assign({}, $$props), $$new_props));
    if ("open" in $$props)
      $$invalidate(17, open = $$new_props.open);
    if ("id" in $$props)
      $$invalidate(0, id = $$new_props.id);
    if ("autocollapse" in $$props)
      $$invalidate(18, autocollapse = $$new_props.autocollapse);
    if ("active" in $$props)
      $$subscribe_active($$invalidate(1, active = $$new_props.active));
    if ("disabled" in $$props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("padding" in $$props)
      $$invalidate(19, padding = $$new_props.padding);
    if ("hover" in $$props)
      $$invalidate(20, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(21, rounded = $$new_props.rounded);
    if ("caretOpen" in $$props)
      $$invalidate(22, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$props)
      $$invalidate(23, caretClosed = $$new_props.caretClosed);
    if ("regionControl" in $$props)
      $$invalidate(24, regionControl = $$new_props.regionControl);
    if ("regionPanel" in $$props)
      $$invalidate(25, regionPanel = $$new_props.regionPanel);
    if ("regionCaret" in $$props)
      $$invalidate(26, regionCaret = $$new_props.regionCaret);
    if ("transitions" in $$props)
      $$invalidate(3, transitions = $$new_props.transitions);
    if ("transitionIn" in $$props)
      $$invalidate(4, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$props)
      $$invalidate(5, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$props)
      $$invalidate(6, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$props)
      $$invalidate(7, transitionOutParams = $$new_props.transitionOutParams);
    if ("classesPanel" in $$props)
      $$invalidate(9, classesPanel = $$new_props.classesPanel);
    if ("classesControlIcons" in $$props)
      $$invalidate(10, classesControlIcons = $$new_props.classesControlIcons);
    if ("classesCaretState" in $$props)
      $$invalidate(27, classesCaretState = $$new_props.classesCaretState);
    if ("classesControlCaret" in $$props)
      $$invalidate(11, classesControlCaret = $$new_props.classesControlCaret);
    if ("openState" in $$props)
      $$invalidate(8, openState = $$new_props.openState);
    if ("classesControl" in $$props)
      $$invalidate(12, classesControl = $$new_props.classesControl);
    if ("classesBase" in $$props)
      $$invalidate(13, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*open, autocollapse*/
    393216) {
      $:
        if (open && autocollapse)
          setActive();
    }
    if ($$self.$$.dirty[0] & /*autocollapse, $active, id, open*/
    268828673) {
      $:
        $$invalidate(8, openState = autocollapse ? $active === id : open);
    }
    $:
      $$invalidate(13, classesBase = `${cBase} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*padding, hover, rounded, regionControl*/
    20447232) {
      $:
        $$invalidate(12, classesControl = `${cControl} ${padding} ${hover} ${rounded} ${regionControl}`);
    }
    if ($$self.$$.dirty[0] & /*openState, caretOpen, caretClosed*/
    12583168) {
      $:
        $$invalidate(27, classesCaretState = openState ? caretOpen : caretClosed);
    }
    if ($$self.$$.dirty[0] & /*regionCaret, classesCaretState*/
    201326592) {
      $:
        $$invalidate(11, classesControlCaret = `${cControlIcons} ${regionCaret} ${classesCaretState}`);
    }
    if ($$self.$$.dirty[0] & /*regionCaret*/
    67108864) {
      $:
        $$invalidate(10, classesControlIcons = `${cControlIcons} ${regionCaret}`);
    }
    if ($$self.$$.dirty[0] & /*padding, rounded, regionPanel*/
    36175872) {
      $:
        $$invalidate(9, classesPanel = `${cPanel} ${padding} ${rounded} ${regionPanel}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    id,
    active,
    disabled,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    openState,
    classesPanel,
    classesControlIcons,
    classesControlCaret,
    classesControl,
    classesBase,
    svgCaretIcon,
    setActive,
    $$slots,
    open,
    autocollapse,
    padding,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    regionControl,
    regionPanel,
    regionCaret,
    classesCaretState,
    $active,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler
  ];
}
var AccordionItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        open: 17,
        id: 0,
        autocollapse: 18,
        active: 1,
        disabled: 2,
        padding: 19,
        hover: 20,
        rounded: 21,
        caretOpen: 22,
        caretClosed: 23,
        regionControl: 24,
        regionPanel: 25,
        regionCaret: 26,
        transitions: 3,
        transitionIn: 4,
        transitionInParams: 5,
        transitionOut: 6,
        transitionOutParams: 7
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AccordionItem",
      options,
      id: create_fragment2.name
    });
  }
  get open() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autocollapse() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autocollapse(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretOpen() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretOpen(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretClosed() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretClosed(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionControl() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionControl(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionPanel() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionPanel(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionCaret() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionCaret(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitions() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitions(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionIn() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionIn(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionInParams() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionInParams(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOut() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOut(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOutParams() {
    throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOutParams(value) {
    throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AccordionItem_default = AccordionItem;

// node_modules/@skeletonlabs/skeleton/dist/components/AppBar/AppBar.svelte
var file3 = "node_modules/@skeletonlabs/skeleton/dist/components/AppBar/AppBar.svelte";
var get_headline_slot_changes = (dirty) => ({});
var get_headline_slot_context = (ctx) => ({});
var get_trail_slot_changes = (dirty) => ({});
var get_trail_slot_context = (ctx) => ({});
var get_lead_slot_changes2 = (dirty) => ({});
var get_lead_slot_context2 = (ctx) => ({});
function create_if_block_22(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[22].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_lead_slot_context2
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-bar-slot-lead " + /*classesSlotLead*/
      ctx[4]);
      add_location(div, file3, 39, 3, 1366);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_lead_slot_changes2
            ),
            get_lead_slot_context2
          );
        }
      }
      if (!current || dirty & /*classesSlotLead*/
      16 && div_class_value !== (div_class_value = "app-bar-slot-lead " + /*classesSlotLead*/
      ctx2[4])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(39:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let div;
  let div_class_value;
  let current;
  const trail_slot_template = (
    /*#slots*/
    ctx[22].trail
  );
  const trail_slot = create_slot(
    trail_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_trail_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (trail_slot)
        trail_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-bar-slot-trail " + /*classesSlotTrail*/
      ctx[2]);
      add_location(div, file3, 45, 3, 1595);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (trail_slot) {
        trail_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              trail_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_trail_slot_changes
            ),
            get_trail_slot_context
          );
        }
      }
      if (!current || dirty & /*classesSlotTrail*/
      4 && div_class_value !== (div_class_value = "app-bar-slot-trail " + /*classesSlotTrail*/
      ctx2[2])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(45:2) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let div_class_value;
  let current;
  const headline_slot_template = (
    /*#slots*/
    ctx[22].headline
  );
  const headline_slot = create_slot(
    headline_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_headline_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (headline_slot)
        headline_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (headline_slot)
        headline_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-bar-row-headline " + /*classesRowHeadline*/
      ctx[5]);
      add_location(div, file3, 50, 2, 1740);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (headline_slot) {
        headline_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (headline_slot) {
        if (headline_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            headline_slot,
            headline_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              headline_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_headline_slot_changes
            ),
            get_headline_slot_context
          );
        }
      }
      if (!current || dirty & /*classesRowHeadline*/
      32 && div_class_value !== (div_class_value = "app-bar-row-headline " + /*classesRowHeadline*/
      ctx2[5])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(headline_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(headline_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (headline_slot)
        headline_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(50:1) {#if $$slots.headline}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div2;
  let div1;
  let t0;
  let div0;
  let div0_class_value;
  let t1;
  let div1_class_value;
  let t2;
  let div2_class_value;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[8].lead && create_if_block_22(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  let if_block1 = (
    /*$$slots*/
    ctx[8].trail && create_if_block_12(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[8].headline && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true,
        "aria-labelledby": true
      });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      if (if_block2)
        if_block2.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "app-bar-slot-default " + /*classesSlotDefault*/
      ctx[3]);
      add_location(div0, file3, 42, 2, 1477);
      attr_dev(div1, "class", div1_class_value = "app-bar-row-main " + /*classesRowMain*/
      ctx[6]);
      add_location(div1, file3, 36, 1, 1272);
      attr_dev(div2, "class", div2_class_value = "app-bar " + /*classesBase*/
      ctx[7]);
      attr_dev(div2, "data-testid", "app-bar");
      attr_dev(div2, "role", "toolbar");
      attr_dev(
        div2,
        "aria-label",
        /*label*/
        ctx[0]
      );
      attr_dev(
        div2,
        "aria-labelledby",
        /*labelledby*/
        ctx[1]
      );
      add_location(div2, file3, 34, 0, 1130);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration_dev(div1, t1);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[8].lead
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_22(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesSlotDefault*/
      8 && div0_class_value !== (div0_class_value = "app-bar-slot-default " + /*classesSlotDefault*/
      ctx2[3])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*$$slots*/
        ctx2[8].trail
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesRowMain*/
      64 && div1_class_value !== (div1_class_value = "app-bar-row-main " + /*classesRowMain*/
      ctx2[6])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (
        /*$$slots*/
        ctx2[8].headline
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          256) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block2(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      128 && div2_class_value !== (div2_class_value = "app-bar " + /*classesBase*/
      ctx2[7])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*label*/
      1) {
        attr_dev(
          div2,
          "aria-label",
          /*label*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*labelledby*/
      2) {
        attr_dev(
          div2,
          "aria-labelledby",
          /*labelledby*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase2 = "flex flex-col";
var cRowMain = "grid items-center";
var cRowHeadline = "";
var cSlotLead = "flex-none flex justify-between items-center";
var cSlotDefault = "flex-auto";
var cSlotTrail = "flex-none flex items-center space-x-4";
function instance3($$self, $$props, $$invalidate) {
  let classesBase;
  let classesRowMain;
  let classesRowHeadline;
  let classesSlotLead;
  let classesSlotDefault;
  let classesSlotTrail;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppBar", slots, ["lead", "default", "trail", "headline"]);
  const $$slots = compute_slots(slots);
  let { background = "bg-surface-100-800-token" } = $$props;
  let { border = "" } = $$props;
  let { padding = "p-4" } = $$props;
  let { shadow = "" } = $$props;
  let { spacing = "space-y-4" } = $$props;
  let { gridColumns = "grid-cols-[auto_1fr_auto]" } = $$props;
  let { gap = "gap-4" } = $$props;
  let { regionRowMain = "" } = $$props;
  let { regionRowHeadline = "" } = $$props;
  let { slotLead = "" } = $$props;
  let { slotDefault = "" } = $$props;
  let { slotTrail = "" } = $$props;
  let { label = "" } = $$props;
  let { labelledby = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("background" in $$new_props)
      $$invalidate(9, background = $$new_props.background);
    if ("border" in $$new_props)
      $$invalidate(10, border = $$new_props.border);
    if ("padding" in $$new_props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("shadow" in $$new_props)
      $$invalidate(12, shadow = $$new_props.shadow);
    if ("spacing" in $$new_props)
      $$invalidate(13, spacing = $$new_props.spacing);
    if ("gridColumns" in $$new_props)
      $$invalidate(14, gridColumns = $$new_props.gridColumns);
    if ("gap" in $$new_props)
      $$invalidate(15, gap = $$new_props.gap);
    if ("regionRowMain" in $$new_props)
      $$invalidate(16, regionRowMain = $$new_props.regionRowMain);
    if ("regionRowHeadline" in $$new_props)
      $$invalidate(17, regionRowHeadline = $$new_props.regionRowHeadline);
    if ("slotLead" in $$new_props)
      $$invalidate(18, slotLead = $$new_props.slotLead);
    if ("slotDefault" in $$new_props)
      $$invalidate(19, slotDefault = $$new_props.slotDefault);
    if ("slotTrail" in $$new_props)
      $$invalidate(20, slotTrail = $$new_props.slotTrail);
    if ("label" in $$new_props)
      $$invalidate(0, label = $$new_props.label);
    if ("labelledby" in $$new_props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    background,
    border,
    padding,
    shadow,
    spacing,
    gridColumns,
    gap,
    regionRowMain,
    regionRowHeadline,
    slotLead,
    slotDefault,
    slotTrail,
    label,
    labelledby,
    cBase: cBase2,
    cRowMain,
    cRowHeadline,
    cSlotLead,
    cSlotDefault,
    cSlotTrail,
    classesSlotTrail,
    classesSlotDefault,
    classesSlotLead,
    classesRowHeadline,
    classesRowMain,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
    if ("background" in $$props)
      $$invalidate(9, background = $$new_props.background);
    if ("border" in $$props)
      $$invalidate(10, border = $$new_props.border);
    if ("padding" in $$props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("shadow" in $$props)
      $$invalidate(12, shadow = $$new_props.shadow);
    if ("spacing" in $$props)
      $$invalidate(13, spacing = $$new_props.spacing);
    if ("gridColumns" in $$props)
      $$invalidate(14, gridColumns = $$new_props.gridColumns);
    if ("gap" in $$props)
      $$invalidate(15, gap = $$new_props.gap);
    if ("regionRowMain" in $$props)
      $$invalidate(16, regionRowMain = $$new_props.regionRowMain);
    if ("regionRowHeadline" in $$props)
      $$invalidate(17, regionRowHeadline = $$new_props.regionRowHeadline);
    if ("slotLead" in $$props)
      $$invalidate(18, slotLead = $$new_props.slotLead);
    if ("slotDefault" in $$props)
      $$invalidate(19, slotDefault = $$new_props.slotDefault);
    if ("slotTrail" in $$props)
      $$invalidate(20, slotTrail = $$new_props.slotTrail);
    if ("label" in $$props)
      $$invalidate(0, label = $$new_props.label);
    if ("labelledby" in $$props)
      $$invalidate(1, labelledby = $$new_props.labelledby);
    if ("classesSlotTrail" in $$props)
      $$invalidate(2, classesSlotTrail = $$new_props.classesSlotTrail);
    if ("classesSlotDefault" in $$props)
      $$invalidate(3, classesSlotDefault = $$new_props.classesSlotDefault);
    if ("classesSlotLead" in $$props)
      $$invalidate(4, classesSlotLead = $$new_props.classesSlotLead);
    if ("classesRowHeadline" in $$props)
      $$invalidate(5, classesRowHeadline = $$new_props.classesRowHeadline);
    if ("classesRowMain" in $$props)
      $$invalidate(6, classesRowMain = $$new_props.classesRowMain);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(7, classesBase = `${cBase2} ${background} ${border} ${spacing} ${padding} ${shadow} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*gridColumns, gap, regionRowMain*/
    114688) {
      $:
        $$invalidate(6, classesRowMain = `${cRowMain} ${gridColumns} ${gap} ${regionRowMain}`);
    }
    if ($$self.$$.dirty & /*regionRowHeadline*/
    131072) {
      $:
        $$invalidate(5, classesRowHeadline = `${cRowHeadline} ${regionRowHeadline}`);
    }
    if ($$self.$$.dirty & /*slotLead*/
    262144) {
      $:
        $$invalidate(4, classesSlotLead = `${cSlotLead} ${slotLead}`);
    }
    if ($$self.$$.dirty & /*slotDefault*/
    524288) {
      $:
        $$invalidate(3, classesSlotDefault = `${cSlotDefault} ${slotDefault}`);
    }
    if ($$self.$$.dirty & /*slotTrail*/
    1048576) {
      $:
        $$invalidate(2, classesSlotTrail = `${cSlotTrail} ${slotTrail}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    label,
    labelledby,
    classesSlotTrail,
    classesSlotDefault,
    classesSlotLead,
    classesRowHeadline,
    classesRowMain,
    classesBase,
    $$slots,
    background,
    border,
    padding,
    shadow,
    spacing,
    gridColumns,
    gap,
    regionRowMain,
    regionRowHeadline,
    slotLead,
    slotDefault,
    slotTrail,
    $$scope,
    slots
  ];
}
var AppBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      background: 9,
      border: 10,
      padding: 11,
      shadow: 12,
      spacing: 13,
      gridColumns: 14,
      gap: 15,
      regionRowMain: 16,
      regionRowHeadline: 17,
      slotLead: 18,
      slotDefault: 19,
      slotTrail: 20,
      label: 0,
      labelledby: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppBar",
      options,
      id: create_fragment3.name
    });
  }
  get background() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gridColumns() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gridColumns(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionRowMain() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionRowMain(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionRowHeadline() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionRowHeadline(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotLead() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotLead(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotDefault() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotDefault(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotTrail() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotTrail(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<AppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<AppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppBar_default = AppBar;

// node_modules/@skeletonlabs/skeleton/dist/components/AppRail/AppRail.svelte
var file4 = "node_modules/@skeletonlabs/skeleton/dist/components/AppRail/AppRail.svelte";
var get_trail_slot_changes2 = (dirty) => ({});
var get_trail_slot_context2 = (ctx) => ({});
var get_lead_slot_changes3 = (dirty) => ({});
var get_lead_slot_context3 = (ctx) => ({});
function create_fragment4(ctx) {
  let div3;
  let div0;
  let div0_class_value;
  let t0;
  let div1;
  let div1_class_value;
  let t1;
  let div2;
  let div2_class_value;
  let div3_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[17].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_lead_slot_context3
  );
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const trail_slot_template = (
    /*#slots*/
    ctx[17].trail
  );
  const trail_slot = create_slot(
    trail_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_trail_slot_context2
  );
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      if (lead_slot)
        lead_slot.c();
      t0 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t1 = space();
      div2 = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (lead_slot)
        lead_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (trail_slot)
        trail_slot.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "app-bar-lead " + /*classesRegionLead*/
      ctx[2]);
      add_location(div0, file4, 35, 1, 1199);
      attr_dev(div1, "class", div1_class_value = "app-bar-default " + /*classesRegionDefault*/
      ctx[1]);
      add_location(div1, file4, 37, 1, 1297);
      attr_dev(div2, "class", div2_class_value = "app-bar-trail " + /*classesRegionTrail*/
      ctx[0]);
      add_location(div2, file4, 39, 1, 1386);
      attr_dev(div3, "class", div3_class_value = "app-rail " + /*classesBase*/
      ctx[3]);
      attr_dev(div3, "data-testid", "app-rail");
      add_location(div3, file4, 33, 0, 1117);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      if (lead_slot) {
        lead_slot.m(div0, null);
      }
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      if (trail_slot) {
        trail_slot.m(div2, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_lead_slot_changes3
            ),
            get_lead_slot_context3
          );
        }
      }
      if (!current || dirty & /*classesRegionLead*/
      4 && div0_class_value !== (div0_class_value = "app-bar-lead " + /*classesRegionLead*/
      ctx2[2])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesRegionDefault*/
      2 && div1_class_value !== (div1_class_value = "app-bar-default " + /*classesRegionDefault*/
      ctx2[1])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              trail_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_trail_slot_changes2
            ),
            get_trail_slot_context2
          );
        }
      }
      if (!current || dirty & /*classesRegionTrail*/
      1 && div2_class_value !== (div2_class_value = "app-bar-trail " + /*classesRegionTrail*/
      ctx2[0])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*classesBase*/
      8 && div3_class_value !== (div3_class_value = "app-rail " + /*classesBase*/
      ctx2[3])) {
        attr_dev(div3, "class", div3_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      transition_in(default_slot, local);
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      transition_out(default_slot, local);
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      if (lead_slot)
        lead_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase3 = "grid grid-rows-[auto_1fr_auto] overflow-y-auto";
var cRegionLead = "box-border";
var cRegionDefault = "box-border";
var cRegionTrail = "box-border";
function instance4($$self, $$props, $$invalidate) {
  let classesBase;
  let classesRegionLead;
  let classesRegionDefault;
  let classesRegionTrail;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppRail", slots, ["lead", "default", "trail"]);
  let { background = "bg-surface-100-800-token" } = $$props;
  let { border = "" } = $$props;
  let { width = "w-20" } = $$props;
  let { height = "h-full" } = $$props;
  let { gap = "gap-0" } = $$props;
  let { regionLead = "" } = $$props;
  let { regionDefault = "" } = $$props;
  let { regionTrail = "" } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let { active = "bg-primary-active-token" } = $$props;
  let { spacing = "space-y-1" } = $$props;
  let { aspectRatio = "aspect-square" } = $$props;
  setContext("active", active);
  setContext("hover", hover);
  setContext("spacing", spacing);
  setContext("aspectRatio", aspectRatio);
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("background" in $$new_props)
      $$invalidate(4, background = $$new_props.background);
    if ("border" in $$new_props)
      $$invalidate(5, border = $$new_props.border);
    if ("width" in $$new_props)
      $$invalidate(6, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(7, height = $$new_props.height);
    if ("gap" in $$new_props)
      $$invalidate(8, gap = $$new_props.gap);
    if ("regionLead" in $$new_props)
      $$invalidate(9, regionLead = $$new_props.regionLead);
    if ("regionDefault" in $$new_props)
      $$invalidate(10, regionDefault = $$new_props.regionDefault);
    if ("regionTrail" in $$new_props)
      $$invalidate(11, regionTrail = $$new_props.regionTrail);
    if ("hover" in $$new_props)
      $$invalidate(12, hover = $$new_props.hover);
    if ("active" in $$new_props)
      $$invalidate(13, active = $$new_props.active);
    if ("spacing" in $$new_props)
      $$invalidate(14, spacing = $$new_props.spacing);
    if ("aspectRatio" in $$new_props)
      $$invalidate(15, aspectRatio = $$new_props.aspectRatio);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    background,
    border,
    width,
    height,
    gap,
    regionLead,
    regionDefault,
    regionTrail,
    hover,
    active,
    spacing,
    aspectRatio,
    cBase: cBase3,
    cRegionLead,
    cRegionDefault,
    cRegionTrail,
    classesRegionTrail,
    classesRegionDefault,
    classesRegionLead,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("background" in $$props)
      $$invalidate(4, background = $$new_props.background);
    if ("border" in $$props)
      $$invalidate(5, border = $$new_props.border);
    if ("width" in $$props)
      $$invalidate(6, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(7, height = $$new_props.height);
    if ("gap" in $$props)
      $$invalidate(8, gap = $$new_props.gap);
    if ("regionLead" in $$props)
      $$invalidate(9, regionLead = $$new_props.regionLead);
    if ("regionDefault" in $$props)
      $$invalidate(10, regionDefault = $$new_props.regionDefault);
    if ("regionTrail" in $$props)
      $$invalidate(11, regionTrail = $$new_props.regionTrail);
    if ("hover" in $$props)
      $$invalidate(12, hover = $$new_props.hover);
    if ("active" in $$props)
      $$invalidate(13, active = $$new_props.active);
    if ("spacing" in $$props)
      $$invalidate(14, spacing = $$new_props.spacing);
    if ("aspectRatio" in $$props)
      $$invalidate(15, aspectRatio = $$new_props.aspectRatio);
    if ("classesRegionTrail" in $$props)
      $$invalidate(0, classesRegionTrail = $$new_props.classesRegionTrail);
    if ("classesRegionDefault" in $$props)
      $$invalidate(1, classesRegionDefault = $$new_props.classesRegionDefault);
    if ("classesRegionLead" in $$props)
      $$invalidate(2, classesRegionLead = $$new_props.classesRegionLead);
    if ("classesBase" in $$props)
      $$invalidate(3, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(3, classesBase = `${cBase3} ${background} ${border} ${width} ${height} ${gap} ${$$props.class || ""}`);
    if ($$self.$$.dirty & /*regionLead*/
    512) {
      $:
        $$invalidate(2, classesRegionLead = `${cRegionLead} ${regionLead}`);
    }
    if ($$self.$$.dirty & /*regionDefault*/
    1024) {
      $:
        $$invalidate(1, classesRegionDefault = `${cRegionDefault} ${regionDefault}`);
    }
    if ($$self.$$.dirty & /*regionTrail*/
    2048) {
      $:
        $$invalidate(0, classesRegionTrail = `${cRegionTrail} ${regionTrail}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    classesRegionTrail,
    classesRegionDefault,
    classesRegionLead,
    classesBase,
    background,
    border,
    width,
    height,
    gap,
    regionLead,
    regionDefault,
    regionTrail,
    hover,
    active,
    spacing,
    aspectRatio,
    $$scope,
    slots
  ];
}
var AppRail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      background: 4,
      border: 5,
      width: 6,
      height: 7,
      gap: 8,
      regionLead: 9,
      regionDefault: 10,
      regionTrail: 11,
      hover: 12,
      active: 13,
      spacing: 14,
      aspectRatio: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppRail",
      options,
      id: create_fragment4.name
    });
  }
  get background() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLead() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLead(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionDefault() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionDefault(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionTrail() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionTrail(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<AppRail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<AppRail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppRail_default = AppRail;

// node_modules/@skeletonlabs/skeleton/dist/components/AppRail/AppRailTile.svelte
var file5 = "node_modules/@skeletonlabs/skeleton/dist/components/AppRail/AppRailTile.svelte";
var get_lead_slot_changes4 = (dirty) => ({});
var get_lead_slot_context4 = (ctx) => ({});
function create_if_block3(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[23].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    get_lead_slot_context4
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-rail-lead " + /*classesLead*/
      ctx[6]);
      add_location(div, file5, 55, 21, 1950);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty[0] & /*$$scope*/
        4194304)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              get_lead_slot_changes4
            ),
            get_lead_slot_context4
          );
        }
      }
      if (!current || dirty[0] & /*classesLead*/
      64 && div_class_value !== (div_class_value = "app-rail-lead " + /*classesLead*/
      ctx2[6])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(56:3) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let label;
  let button;
  let div0;
  let input;
  let t0;
  let div2;
  let t1;
  let div1;
  let div1_class_value;
  let div2_class_value;
  let button_class_value;
  let label_class_value;
  let current;
  let binding_group;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "radio" },
    { name: (
      /*name*/
      ctx[1]
    ) },
    { __value: (
      /*value*/
      ctx[2]
    ) },
    /*prunedRestProps*/
    ctx[12](),
    { tabindex: "-1" }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block = (
    /*$$slots*/
    ctx[13].lead && create_if_block3(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[34][0]
  );
  const block = {
    c: function create() {
      label = element("label");
      button = element("button");
      div0 = element("div");
      input = element("input");
      t0 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", {
        class: true,
        "data-testid": true,
        title: true
      });
      var label_nodes = children(label);
      button = claim_element(label_nodes, "BUTTON", { class: true, tabindex: true });
      var button_nodes = children(button);
      div0 = claim_element(button_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", { type: true, name: true, tabindex: true });
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(button_nodes);
      div2 = claim_element(button_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block)
        if_block.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file5, 51, 3, 1718);
      attr_dev(div0, "class", "h-0 w-0 overflow-hidden");
      add_location(div0, file5, 50, 2, 1677);
      attr_dev(div1, "class", div1_class_value = "app-rail-label " + /*classesLabel*/
      ctx[5]);
      add_location(div1, file5, 56, 3, 2026);
      attr_dev(div2, "class", div2_class_value = "app-rail-interface " + /*classesInterface*/
      ctx[7]);
      add_location(div2, file5, 54, 2, 1877);
      attr_dev(button, "class", button_class_value = "app-rail-wrapper " + /*classesWrapper*/
      ctx[8]);
      attr_dev(button, "tabindex", "0");
      add_location(button, file5, 48, 1, 1463);
      attr_dev(label, "class", label_class_value = "app-rail-tile " + /*classesBase*/
      ctx[9]);
      attr_dev(label, "data-testid", "app-rail-tile");
      attr_dev(
        label,
        "title",
        /*title*/
        ctx[3]
      );
      add_location(label, file5, 44, 0, 1186);
      binding_group.p(input);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, button);
      append_hydration_dev(button, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[32](input);
      input.checked = input.__value === /*group*/
      ctx[0];
      append_hydration_dev(button, t0);
      append_hydration_dev(button, div2);
      if (if_block)
        if_block.m(div2, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[33]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "click",
            /*selectElemInput*/
            ctx[11],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*onKeyDown*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keyup",
            /*keyup_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keypress",
            /*keypress_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "mouseover",
            /*mouseover_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "focus",
            /*focus_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            label,
            "blur",
            /*blur_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "radio" },
        (!current || dirty[0] & /*name*/
        2) && { name: (
          /*name*/
          ctx2[1]
        ) },
        (!current || dirty[0] & /*value*/
        4) && { __value: (
          /*value*/
          ctx2[2]
        ) },
        /*prunedRestProps*/
        ctx2[12](),
        { tabindex: "-1" }
      ]));
      if (dirty[0] & /*group*/
      1) {
        input.checked = input.__value === /*group*/
        ctx2[0];
      }
      if (
        /*$$slots*/
        ctx2[13].lead
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          8192) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classesLabel*/
      32 && div1_class_value !== (div1_class_value = "app-rail-label " + /*classesLabel*/
      ctx2[5])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*classesInterface*/
      128 && div2_class_value !== (div2_class_value = "app-rail-interface " + /*classesInterface*/
      ctx2[7])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*classesWrapper*/
      256 && button_class_value !== (button_class_value = "app-rail-wrapper " + /*classesWrapper*/
      ctx2[8])) {
        attr_dev(button, "class", button_class_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      512 && label_class_value !== (label_class_value = "app-rail-tile " + /*classesBase*/
      ctx2[9])) {
        attr_dev(label, "class", label_class_value);
      }
      if (!current || dirty[0] & /*title*/
      8) {
        attr_dev(
          label,
          "title",
          /*title*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      ctx[32](null);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase4 = "cursor-pointer";
var cWrapper = "flex flex-col justify-center items-stretch w-full";
var cInterface = "text-center";
var cLabel = "font-bold text-xs";
function instance5($$self, $$props, $$invalidate) {
  let classActive;
  let classesBase;
  let classesWrapper;
  let classesInterface;
  let classesLead;
  let classesLabel;
  const omit_props_names = [
    "group",
    "name",
    "value",
    "title",
    "regionLead",
    "regionLabel",
    "hover",
    "active",
    "spacing",
    "width",
    "aspectRatio"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppRailTile", slots, ["lead", "default"]);
  const $$slots = compute_slots(slots);
  let { group } = $$props;
  let { name } = $$props;
  let { value } = $$props;
  let { title = "" } = $$props;
  let { regionLead = "" } = $$props;
  let { regionLabel = "" } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { active = getContext("active") } = $$props;
  let { spacing = getContext("spacing") } = $$props;
  let { width = getContext("width") } = $$props;
  let { aspectRatio = getContext("aspectRatio") } = $$props;
  let elemInput;
  function onKeyDown2(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      selectElemInput();
    }
  }
  function selectElemInput() {
    elemInput.click();
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (group === void 0 && !("group" in $$props || $$self.$$.bound[$$self.$$.props["group"]])) {
      console.warn("<AppRailTile> was created without expected prop 'group'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<AppRailTile> was created without expected prop 'name'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<AppRailTile> was created without expected prop 'value'");
    }
  });
  const $$binding_groups = [[]];
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemInput = $$value;
      $$invalidate(4, elemInput);
    });
  }
  function input_change_handler() {
    group = this.__value;
    $$invalidate(0, group);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(36, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(35, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("group" in $$new_props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("title" in $$new_props)
      $$invalidate(3, title = $$new_props.title);
    if ("regionLead" in $$new_props)
      $$invalidate(14, regionLead = $$new_props.regionLead);
    if ("regionLabel" in $$new_props)
      $$invalidate(15, regionLabel = $$new_props.regionLabel);
    if ("hover" in $$new_props)
      $$invalidate(16, hover = $$new_props.hover);
    if ("active" in $$new_props)
      $$invalidate(17, active = $$new_props.active);
    if ("spacing" in $$new_props)
      $$invalidate(18, spacing = $$new_props.spacing);
    if ("width" in $$new_props)
      $$invalidate(19, width = $$new_props.width);
    if ("aspectRatio" in $$new_props)
      $$invalidate(20, aspectRatio = $$new_props.aspectRatio);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    group,
    name,
    value,
    title,
    regionLead,
    regionLabel,
    hover,
    active,
    spacing,
    width,
    aspectRatio,
    cBase: cBase4,
    cWrapper,
    cInterface,
    cLabel,
    elemInput,
    onKeyDown: onKeyDown2,
    selectElemInput,
    prunedRestProps,
    classesLabel,
    classesLead,
    classesInterface,
    classActive,
    classesWrapper,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(36, $$props = assign(assign({}, $$props), $$new_props));
    if ("group" in $$props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("title" in $$props)
      $$invalidate(3, title = $$new_props.title);
    if ("regionLead" in $$props)
      $$invalidate(14, regionLead = $$new_props.regionLead);
    if ("regionLabel" in $$props)
      $$invalidate(15, regionLabel = $$new_props.regionLabel);
    if ("hover" in $$props)
      $$invalidate(16, hover = $$new_props.hover);
    if ("active" in $$props)
      $$invalidate(17, active = $$new_props.active);
    if ("spacing" in $$props)
      $$invalidate(18, spacing = $$new_props.spacing);
    if ("width" in $$props)
      $$invalidate(19, width = $$new_props.width);
    if ("aspectRatio" in $$props)
      $$invalidate(20, aspectRatio = $$new_props.aspectRatio);
    if ("elemInput" in $$props)
      $$invalidate(4, elemInput = $$new_props.elemInput);
    if ("classesLabel" in $$props)
      $$invalidate(5, classesLabel = $$new_props.classesLabel);
    if ("classesLead" in $$props)
      $$invalidate(6, classesLead = $$new_props.classesLead);
    if ("classesInterface" in $$props)
      $$invalidate(7, classesInterface = $$new_props.classesInterface);
    if ("classActive" in $$props)
      $$invalidate(21, classActive = $$new_props.classActive);
    if ("classesWrapper" in $$props)
      $$invalidate(8, classesWrapper = $$new_props.classesWrapper);
    if ("classesBase" in $$props)
      $$invalidate(9, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*group, value, active*/
    131077) {
      $:
        $$invalidate(21, classActive = group === value ? active : "");
    }
    $:
      $$invalidate(9, classesBase = `${cBase4} ${$$props.class || ""}`);
    if ($$self.$$.dirty[0] & /*aspectRatio, width, hover, classActive*/
    3735552) {
      $:
        $$invalidate(8, classesWrapper = `${cWrapper} ${aspectRatio} ${width} ${hover} ${classActive}`);
    }
    if ($$self.$$.dirty[0] & /*spacing*/
    262144) {
      $:
        $$invalidate(7, classesInterface = `${cInterface} ${spacing}`);
    }
    if ($$self.$$.dirty[0] & /*regionLead*/
    16384) {
      $:
        $$invalidate(6, classesLead = `${regionLead}`);
    }
    if ($$self.$$.dirty[0] & /*regionLabel*/
    32768) {
      $:
        $$invalidate(5, classesLabel = `${cLabel} ${regionLabel}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    group,
    name,
    value,
    title,
    elemInput,
    classesLabel,
    classesLead,
    classesInterface,
    classesWrapper,
    classesBase,
    onKeyDown2,
    selectElemInput,
    prunedRestProps,
    $$slots,
    regionLead,
    regionLabel,
    hover,
    active,
    spacing,
    width,
    aspectRatio,
    classActive,
    $$scope,
    slots,
    mouseover_handler,
    mouseleave_handler,
    focus_handler,
    blur_handler,
    keyup_handler,
    keypress_handler,
    click_handler,
    change_handler,
    input_binding,
    input_change_handler,
    $$binding_groups
  ];
}
var AppRailTile = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        regionLead: 14,
        regionLabel: 15,
        hover: 16,
        active: 17,
        spacing: 18,
        width: 19,
        aspectRatio: 20
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppRailTile",
      options,
      id: create_fragment5.name
    });
  }
  get group() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLead() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLead(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLabel() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLabel(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<AppRailTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<AppRailTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppRailTile_default = AppRailTile;

// node_modules/@skeletonlabs/skeleton/dist/components/AppRail/AppRailAnchor.svelte
var file6 = "node_modules/@skeletonlabs/skeleton/dist/components/AppRail/AppRailAnchor.svelte";
var get_lead_slot_changes5 = (dirty) => ({});
var get_lead_slot_context5 = (ctx) => ({});
function create_if_block4(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[16].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_lead_slot_context5
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "app-rail-lead " + /*classesLead*/
      ctx[1]);
      add_location(div, file6, 42, 20, 1137);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_lead_slot_changes5
            ),
            get_lead_slot_context5
          );
        }
      }
      if (!current || dirty & /*classesLead*/
      2 && div_class_value !== (div_class_value = "app-rail-lead " + /*classesLead*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(43:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let a;
  let div1;
  let t;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let a_class_value;
  let a_href_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    ctx[6].lead && create_if_block4(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  let a_levels = [
    {
      class: a_class_value = "app-rail-anchor " + /*classesBase*/
      ctx[3]
    },
    {
      href: a_href_value = /*$$props*/
      ctx[5].href
    },
    /*prunedRestProps*/
    ctx[4](),
    { "data-testid": "app-rail-anchor" }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        class: true,
        href: true,
        "data-testid": true
      });
      var a_nodes = children(a);
      div1 = claim_element(a_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block)
        if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "app-rail-label " + /*classesLabel*/
      ctx[0]);
      add_location(div0, file6, 43, 2, 1212);
      attr_dev(div1, "class", div1_class_value = "app-rail-wrapper " + /*classesWrapper*/
      ctx[2]);
      add_location(div1, file6, 41, 1, 1069);
      set_attributes(a, a_data);
      add_location(a, file6, 27, 0, 855);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, div1);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keydown",
            /*keydown_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keyup",
            /*keyup_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keypress",
            /*keypress_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseover",
            /*mouseover_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "focus",
            /*focus_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "blur",
            /*blur_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[6].lead
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesLabel*/
      1 && div0_class_value !== (div0_class_value = "app-rail-label " + /*classesLabel*/
      ctx2[0])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*classesWrapper*/
      4 && div1_class_value !== (div1_class_value = "app-rail-wrapper " + /*classesWrapper*/
      ctx2[2])) {
        attr_dev(div1, "class", div1_class_value);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*classesBase*/
        8 && a_class_value !== (a_class_value = "app-rail-anchor " + /*classesBase*/
        ctx2[3])) && { class: a_class_value },
        (!current || dirty & /*$$props*/
        32 && a_href_value !== (a_href_value = /*$$props*/
        ctx2[5].href)) && { href: a_href_value },
        /*prunedRestProps*/
        ctx2[4](),
        { "data-testid": "app-rail-anchor" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase5 = "unstyled";
var cWrapper2 = "w-full flex flex-col justify-center items-stretch text-center space-y-1";
var cLabel2 = "font-bold text-xs";
function instance6($$self, $$props, $$invalidate) {
  let classActive;
  let classesBase;
  let classesWrapper;
  let classesLead;
  let classesLabel;
  const omit_props_names = ["selected", "regionLead", "regionLabel", "hover", "active", "spacing", "aspectRatio"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppRailAnchor", slots, ["lead", "default"]);
  const $$slots = compute_slots(slots);
  let { selected = false } = $$props;
  let { regionLead = "flex justify-center items-center" } = $$props;
  let { regionLabel = "" } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { active = getContext("active") } = $$props;
  let { spacing = getContext("spacing") } = $$props;
  let { aspectRatio = getContext("aspectRatio") } = $$props;
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(7, selected = $$new_props.selected);
    if ("regionLead" in $$new_props)
      $$invalidate(8, regionLead = $$new_props.regionLead);
    if ("regionLabel" in $$new_props)
      $$invalidate(9, regionLabel = $$new_props.regionLabel);
    if ("hover" in $$new_props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("active" in $$new_props)
      $$invalidate(11, active = $$new_props.active);
    if ("spacing" in $$new_props)
      $$invalidate(12, spacing = $$new_props.spacing);
    if ("aspectRatio" in $$new_props)
      $$invalidate(13, aspectRatio = $$new_props.aspectRatio);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    selected,
    regionLead,
    regionLabel,
    hover,
    active,
    spacing,
    aspectRatio,
    cBase: cBase5,
    cWrapper: cWrapper2,
    cLabel: cLabel2,
    prunedRestProps,
    classesLabel,
    classesLead,
    classActive,
    classesWrapper,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(7, selected = $$new_props.selected);
    if ("regionLead" in $$props)
      $$invalidate(8, regionLead = $$new_props.regionLead);
    if ("regionLabel" in $$props)
      $$invalidate(9, regionLabel = $$new_props.regionLabel);
    if ("hover" in $$props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("active" in $$props)
      $$invalidate(11, active = $$new_props.active);
    if ("spacing" in $$props)
      $$invalidate(12, spacing = $$new_props.spacing);
    if ("aspectRatio" in $$props)
      $$invalidate(13, aspectRatio = $$new_props.aspectRatio);
    if ("classesLabel" in $$props)
      $$invalidate(0, classesLabel = $$new_props.classesLabel);
    if ("classesLead" in $$props)
      $$invalidate(1, classesLead = $$new_props.classesLead);
    if ("classActive" in $$props)
      $$invalidate(14, classActive = $$new_props.classActive);
    if ("classesWrapper" in $$props)
      $$invalidate(2, classesWrapper = $$new_props.classesWrapper);
    if ("classesBase" in $$props)
      $$invalidate(3, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selected, active*/
    2176) {
      $:
        $$invalidate(14, classActive = selected ? active : "");
    }
    $:
      $$invalidate(3, classesBase = `${cBase5} ${$$props.class || ""}`);
    if ($$self.$$.dirty & /*aspectRatio, hover, spacing, classActive*/
    29696) {
      $:
        $$invalidate(2, classesWrapper = `${cWrapper2} ${aspectRatio} ${hover} ${spacing} ${classActive}`);
    }
    if ($$self.$$.dirty & /*regionLead*/
    256) {
      $:
        $$invalidate(1, classesLead = `${regionLead}`);
    }
    if ($$self.$$.dirty & /*regionLabel*/
    512) {
      $:
        $$invalidate(0, classesLabel = `${cLabel2} ${regionLabel}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    classesLabel,
    classesLead,
    classesWrapper,
    classesBase,
    prunedRestProps,
    $$props,
    $$slots,
    selected,
    regionLead,
    regionLabel,
    hover,
    active,
    spacing,
    aspectRatio,
    classActive,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    mouseover_handler,
    mouseleave_handler,
    focus_handler,
    blur_handler
  ];
}
var AppRailAnchor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      selected: 7,
      regionLead: 8,
      regionLabel: 9,
      hover: 10,
      active: 11,
      spacing: 12,
      aspectRatio: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppRailAnchor",
      options,
      id: create_fragment6.name
    });
  }
  get selected() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLead() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLead(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLabel() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLabel(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get aspectRatio() {
    throw new Error("<AppRailAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set aspectRatio(value) {
    throw new Error("<AppRailAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppRailAnchor_default = AppRailAnchor;

// node_modules/@skeletonlabs/skeleton/dist/components/AppShell/AppShell.svelte
var file7 = "node_modules/@skeletonlabs/skeleton/dist/components/AppShell/AppShell.svelte";
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
var get_sidebarRight_slot_changes = (dirty) => ({});
var get_sidebarRight_slot_context = (ctx) => ({});
var get_pageFooter_slot_changes = (dirty) => ({});
var get_pageFooter_slot_context = (ctx) => ({});
var get_pageHeader_slot_changes = (dirty) => ({});
var get_pageHeader_slot_context = (ctx) => ({});
var get_sidebarLeft_slot_changes = (dirty) => ({});
var get_sidebarLeft_slot_context = (ctx) => ({});
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_if_block_5(ctx) {
  let header;
  let header_class_value;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[19].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_header_slot_context
  );
  const block = {
    c: function create() {
      header = element("header");
      if (header_slot)
        header_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { id: true, class: true });
      var header_nodes = children(header);
      if (header_slot)
        header_slot.l(header_nodes);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "id", "shell-header");
      attr_dev(header, "class", header_class_value = "flex-none " + /*classesHeader*/
      ctx[8]);
      add_location(header, file7, 35, 2, 1161);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      if (header_slot) {
        header_slot.m(header, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      if (!current || dirty & /*classesHeader*/
      256 && header_class_value !== (header_class_value = "flex-none " + /*classesHeader*/
      ctx2[8])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(header);
      }
      if (header_slot)
        header_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(35:1) {#if $$slots.header}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let aside;
  let current;
  const sidebarLeft_slot_template = (
    /*#slots*/
    ctx[19].sidebarLeft
  );
  const sidebarLeft_slot = create_slot(
    sidebarLeft_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_sidebarLeft_slot_context
  );
  const block = {
    c: function create() {
      aside = element("aside");
      if (sidebarLeft_slot)
        sidebarLeft_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { id: true, class: true });
      var aside_nodes = children(aside);
      if (sidebarLeft_slot)
        sidebarLeft_slot.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside, "id", "sidebar-left");
      attr_dev(
        aside,
        "class",
        /*classesSidebarLeft*/
        ctx[7]
      );
      add_location(aside, file7, 42, 3, 1387);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if (sidebarLeft_slot) {
        sidebarLeft_slot.m(aside, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (sidebarLeft_slot) {
        if (sidebarLeft_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            sidebarLeft_slot,
            sidebarLeft_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              sidebarLeft_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_sidebarLeft_slot_changes
            ),
            get_sidebarLeft_slot_context
          );
        }
      }
      if (!current || dirty & /*classesSidebarLeft*/
      128) {
        attr_dev(
          aside,
          "class",
          /*classesSidebarLeft*/
          ctx2[7]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidebarLeft_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidebarLeft_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(aside);
      }
      if (sidebarLeft_slot)
        sidebarLeft_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(42:2) {#if $$slots.sidebarLeft}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let header;
  let header_class_value;
  let current;
  const pageHeader_slot_template = (
    /*#slots*/
    ctx[19].pageHeader
  );
  const pageHeader_slot = create_slot(
    pageHeader_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_pageHeader_slot_context
  );
  const pageHeader_slot_or_fallback = pageHeader_slot || fallback_block_12(ctx);
  const block = {
    c: function create() {
      header = element("header");
      if (pageHeader_slot_or_fallback)
        pageHeader_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { id: true, class: true });
      var header_nodes = children(header);
      if (pageHeader_slot_or_fallback)
        pageHeader_slot_or_fallback.l(header_nodes);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "id", "page-header");
      attr_dev(header, "class", header_class_value = "flex-none " + /*classesPageHeader*/
      ctx[5]);
      add_location(header, file7, 49, 4, 1660);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      if (pageHeader_slot_or_fallback) {
        pageHeader_slot_or_fallback.m(header, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (pageHeader_slot) {
        if (pageHeader_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            pageHeader_slot,
            pageHeader_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              pageHeader_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_pageHeader_slot_changes
            ),
            get_pageHeader_slot_context
          );
        }
      }
      if (!current || dirty & /*classesPageHeader*/
      32 && header_class_value !== (header_class_value = "flex-none " + /*classesPageHeader*/
      ctx2[5])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pageHeader_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pageHeader_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(header);
      }
      if (pageHeader_slot_or_fallback)
        pageHeader_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(49:3) {#if $$slots.pageHeader}",
    ctx
  });
  return block;
}
function fallback_block_12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(slot:header)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(slot:header)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_12.name,
    type: "fallback",
    source: "(50:91) (slot:header)",
    ctx
  });
  return block;
}
function create_if_block_23(ctx) {
  let footer;
  let footer_class_value;
  let current;
  const pageFooter_slot_template = (
    /*#slots*/
    ctx[19].pageFooter
  );
  const pageFooter_slot = create_slot(
    pageFooter_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_pageFooter_slot_context
  );
  const pageFooter_slot_or_fallback = pageFooter_slot || fallback_block2(ctx);
  const block = {
    c: function create() {
      footer = element("footer");
      if (pageFooter_slot_or_fallback)
        pageFooter_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { id: true, class: true });
      var footer_nodes = children(footer);
      if (pageFooter_slot_or_fallback)
        pageFooter_slot_or_fallback.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(footer, "id", "page-footer");
      attr_dev(footer, "class", footer_class_value = "flex-none " + /*classesPageFooter*/
      ctx[3]);
      add_location(footer, file7, 57, 4, 1973);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      if (pageFooter_slot_or_fallback) {
        pageFooter_slot_or_fallback.m(footer, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (pageFooter_slot) {
        if (pageFooter_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            pageFooter_slot,
            pageFooter_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              pageFooter_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_pageFooter_slot_changes
            ),
            get_pageFooter_slot_context
          );
        }
      }
      if (!current || dirty & /*classesPageFooter*/
      8 && footer_class_value !== (footer_class_value = "flex-none " + /*classesPageFooter*/
      ctx2[3])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pageFooter_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pageFooter_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(footer);
      }
      if (pageFooter_slot_or_fallback)
        pageFooter_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_23.name,
    type: "if",
    source: "(57:3) {#if $$slots.pageFooter}",
    ctx
  });
  return block;
}
function fallback_block2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("(slot:footer)");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "(slot:footer)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block2.name,
    type: "fallback",
    source: "(58:91) (slot:footer)",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let aside;
  let current;
  const sidebarRight_slot_template = (
    /*#slots*/
    ctx[19].sidebarRight
  );
  const sidebarRight_slot = create_slot(
    sidebarRight_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_sidebarRight_slot_context
  );
  const block = {
    c: function create() {
      aside = element("aside");
      if (sidebarRight_slot)
        sidebarRight_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      aside = claim_element(nodes, "ASIDE", { id: true, class: true });
      var aside_nodes = children(aside);
      if (sidebarRight_slot)
        sidebarRight_slot.l(aside_nodes);
      aside_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(aside, "id", "sidebar-right");
      attr_dev(
        aside,
        "class",
        /*classesSidebarRight*/
        ctx[6]
      );
      add_location(aside, file7, 63, 3, 2174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, aside, anchor);
      if (sidebarRight_slot) {
        sidebarRight_slot.m(aside, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (sidebarRight_slot) {
        if (sidebarRight_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            sidebarRight_slot,
            sidebarRight_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              sidebarRight_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_sidebarRight_slot_changes
            ),
            get_sidebarRight_slot_context
          );
        }
      }
      if (!current || dirty & /*classesSidebarRight*/
      64) {
        attr_dev(
          aside,
          "class",
          /*classesSidebarRight*/
          ctx2[6]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(sidebarRight_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(sidebarRight_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(aside);
      }
      if (sidebarRight_slot)
        sidebarRight_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(63:2) {#if $$slots.sidebarRight}",
    ctx
  });
  return block;
}
function create_if_block5(ctx) {
  let footer;
  let footer_class_value;
  let current;
  const footer_slot_template = (
    /*#slots*/
    ctx[19].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    get_footer_slot_context
  );
  const block = {
    c: function create() {
      footer = element("footer");
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { id: true, class: true });
      var footer_nodes = children(footer);
      if (footer_slot)
        footer_slot.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(footer, "id", "shell-footer");
      attr_dev(footer, "class", footer_class_value = "flex-none " + /*classesFooter*/
      ctx[2]);
      add_location(footer, file7, 69, 2, 2329);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      if (footer_slot) {
        footer_slot.m(footer, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
      if (!current || dirty & /*classesFooter*/
      4 && footer_class_value !== (footer_class_value = "flex-none " + /*classesFooter*/
      ctx2[2])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(footer);
      }
      if (footer_slot)
        footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(69:1) {#if $$slots.footer}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let div2;
  let t0;
  let div1;
  let t1;
  let div0;
  let t2;
  let main;
  let main_class_value;
  let t3;
  let div0_class_value;
  let t4;
  let div1_class_value;
  let t5;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[10].header && create_if_block_5(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[10].sidebarLeft && create_if_block_4(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[10].pageHeader && create_if_block_32(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[18],
    null
  );
  let if_block3 = (
    /*$$slots*/
    ctx[10].pageFooter && create_if_block_23(ctx)
  );
  let if_block4 = (
    /*$$slots*/
    ctx[10].sidebarRight && create_if_block_13(ctx)
  );
  let if_block5 = (
    /*$$slots*/
    ctx[10].footer && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div0 = element("div");
      if (if_block2)
        if_block2.c();
      t2 = space();
      main = element("main");
      if (default_slot)
        default_slot.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        id: true,
        class: true,
        "data-testid": true
      });
      var div2_nodes = children(div2);
      if (if_block0)
        if_block0.l(div2_nodes);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block1)
        if_block1.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { id: true, class: true });
      var div0_nodes = children(div0);
      if (if_block2)
        if_block2.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      main = claim_element(div0_nodes, "MAIN", { id: true, class: true });
      var main_nodes = children(main);
      if (default_slot)
        default_slot.l(main_nodes);
      main_nodes.forEach(detach_dev);
      t3 = claim_space(div0_nodes);
      if (if_block3)
        if_block3.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t4 = claim_space(div1_nodes);
      if (if_block4)
        if_block4.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t5 = claim_space(div2_nodes);
      if (if_block5)
        if_block5.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(main, "id", "page-content");
      attr_dev(main, "class", main_class_value = "flex-auto " + /*classesPageContent*/
      ctx[4]);
      add_location(main, file7, 53, 3, 1831);
      attr_dev(div0, "id", "page");
      attr_dev(div0, "class", div0_class_value = /*regionPage*/
      ctx[1] + " " + cPage);
      set_style(
        div0,
        "scrollbar-gutter",
        /*scrollbarGutter*/
        ctx[0]
      );
      add_location(div0, file7, 46, 2, 1502);
      attr_dev(div1, "class", div1_class_value = "flex-auto " + cContentArea);
      add_location(div1, file7, 39, 1, 1285);
      attr_dev(div2, "id", "appShell");
      attr_dev(
        div2,
        "class",
        /*classesBase*/
        ctx[9]
      );
      attr_dev(div2, "data-testid", "app-shell");
      add_location(div2, file7, 32, 0, 1050);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration_dev(div0, t2);
      append_hydration_dev(div0, main);
      if (default_slot) {
        default_slot.m(main, null);
      }
      append_hydration_dev(div0, t3);
      if (if_block3)
        if_block3.m(div0, null);
      append_hydration_dev(div1, t4);
      if (if_block4)
        if_block4.m(div1, null);
      append_hydration_dev(div2, t5);
      if (if_block5)
        if_block5.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div0,
          "scroll",
          /*scroll_handler*/
          ctx[20],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[10].header
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1024) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[10].sidebarLeft
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1024) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[10].pageHeader
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1024) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_32(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        262144)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[18],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[18]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[18],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesPageContent*/
      16 && main_class_value !== (main_class_value = "flex-auto " + /*classesPageContent*/
      ctx2[4])) {
        attr_dev(main, "class", main_class_value);
      }
      if (
        /*$$slots*/
        ctx2[10].pageFooter
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1024) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_23(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*regionPage*/
      2 && div0_class_value !== (div0_class_value = /*regionPage*/
      ctx2[1] + " " + cPage)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & /*scrollbarGutter*/
      1) {
        set_style(
          div0,
          "scrollbar-gutter",
          /*scrollbarGutter*/
          ctx2[0]
        );
      }
      if (
        /*$$slots*/
        ctx2[10].sidebarRight
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1024) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_13(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div1, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[10].footer
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          1024) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block5(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div2, null);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      512) {
        attr_dev(
          div2,
          "class",
          /*classesBase*/
          ctx2[9]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(default_slot, local);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(default_slot, local);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBaseAppShell = "w-full h-full flex flex-col overflow-hidden";
var cContentArea = "w-full h-full flex overflow-hidden";
var cPage = "flex-1 overflow-x-hidden flex flex-col";
var cSidebarLeft = "flex-none overflow-x-hidden overflow-y-auto";
var cSidebarRight = "flex-none overflow-x-hidden overflow-y-auto";
function instance7($$self, $$props, $$invalidate) {
  let classesBase;
  let classesHeader;
  let classesSidebarLeft;
  let classesSidebarRight;
  let classesPageHeader;
  let classesPageContent;
  let classesPageFooter;
  let classesFooter;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AppShell", slots, [
    "header",
    "sidebarLeft",
    "pageHeader",
    "default",
    "pageFooter",
    "sidebarRight",
    "footer"
  ]);
  const $$slots = compute_slots(slots);
  let { scrollbarGutter = "auto" } = $$props;
  let { regionPage = "" } = $$props;
  let { slotHeader = "z-10" } = $$props;
  let { slotSidebarLeft = "w-auto" } = $$props;
  let { slotSidebarRight = "w-auto" } = $$props;
  let { slotPageHeader = "" } = $$props;
  let { slotPageContent = "" } = $$props;
  let { slotPageFooter = "" } = $$props;
  let { slotFooter = "" } = $$props;
  function scroll_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("scrollbarGutter" in $$new_props)
      $$invalidate(0, scrollbarGutter = $$new_props.scrollbarGutter);
    if ("regionPage" in $$new_props)
      $$invalidate(1, regionPage = $$new_props.regionPage);
    if ("slotHeader" in $$new_props)
      $$invalidate(11, slotHeader = $$new_props.slotHeader);
    if ("slotSidebarLeft" in $$new_props)
      $$invalidate(12, slotSidebarLeft = $$new_props.slotSidebarLeft);
    if ("slotSidebarRight" in $$new_props)
      $$invalidate(13, slotSidebarRight = $$new_props.slotSidebarRight);
    if ("slotPageHeader" in $$new_props)
      $$invalidate(14, slotPageHeader = $$new_props.slotPageHeader);
    if ("slotPageContent" in $$new_props)
      $$invalidate(15, slotPageContent = $$new_props.slotPageContent);
    if ("slotPageFooter" in $$new_props)
      $$invalidate(16, slotPageFooter = $$new_props.slotPageFooter);
    if ("slotFooter" in $$new_props)
      $$invalidate(17, slotFooter = $$new_props.slotFooter);
    if ("$$scope" in $$new_props)
      $$invalidate(18, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    scrollbarGutter,
    regionPage,
    slotHeader,
    slotSidebarLeft,
    slotSidebarRight,
    slotPageHeader,
    slotPageContent,
    slotPageFooter,
    slotFooter,
    cBaseAppShell,
    cContentArea,
    cPage,
    cSidebarLeft,
    cSidebarRight,
    classesFooter,
    classesPageFooter,
    classesPageContent,
    classesPageHeader,
    classesSidebarRight,
    classesSidebarLeft,
    classesHeader,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(21, $$props = assign(assign({}, $$props), $$new_props));
    if ("scrollbarGutter" in $$props)
      $$invalidate(0, scrollbarGutter = $$new_props.scrollbarGutter);
    if ("regionPage" in $$props)
      $$invalidate(1, regionPage = $$new_props.regionPage);
    if ("slotHeader" in $$props)
      $$invalidate(11, slotHeader = $$new_props.slotHeader);
    if ("slotSidebarLeft" in $$props)
      $$invalidate(12, slotSidebarLeft = $$new_props.slotSidebarLeft);
    if ("slotSidebarRight" in $$props)
      $$invalidate(13, slotSidebarRight = $$new_props.slotSidebarRight);
    if ("slotPageHeader" in $$props)
      $$invalidate(14, slotPageHeader = $$new_props.slotPageHeader);
    if ("slotPageContent" in $$props)
      $$invalidate(15, slotPageContent = $$new_props.slotPageContent);
    if ("slotPageFooter" in $$props)
      $$invalidate(16, slotPageFooter = $$new_props.slotPageFooter);
    if ("slotFooter" in $$props)
      $$invalidate(17, slotFooter = $$new_props.slotFooter);
    if ("classesFooter" in $$props)
      $$invalidate(2, classesFooter = $$new_props.classesFooter);
    if ("classesPageFooter" in $$props)
      $$invalidate(3, classesPageFooter = $$new_props.classesPageFooter);
    if ("classesPageContent" in $$props)
      $$invalidate(4, classesPageContent = $$new_props.classesPageContent);
    if ("classesPageHeader" in $$props)
      $$invalidate(5, classesPageHeader = $$new_props.classesPageHeader);
    if ("classesSidebarRight" in $$props)
      $$invalidate(6, classesSidebarRight = $$new_props.classesSidebarRight);
    if ("classesSidebarLeft" in $$props)
      $$invalidate(7, classesSidebarLeft = $$new_props.classesSidebarLeft);
    if ("classesHeader" in $$props)
      $$invalidate(8, classesHeader = $$new_props.classesHeader);
    if ("classesBase" in $$props)
      $$invalidate(9, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(9, classesBase = `${cBaseAppShell} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*slotHeader*/
    2048) {
      $:
        $$invalidate(8, classesHeader = `${slotHeader}`);
    }
    if ($$self.$$.dirty & /*slotSidebarLeft*/
    4096) {
      $:
        $$invalidate(7, classesSidebarLeft = `${cSidebarLeft} ${slotSidebarLeft}`);
    }
    if ($$self.$$.dirty & /*slotSidebarRight*/
    8192) {
      $:
        $$invalidate(6, classesSidebarRight = `${cSidebarRight} ${slotSidebarRight}`);
    }
    if ($$self.$$.dirty & /*slotPageHeader*/
    16384) {
      $:
        $$invalidate(5, classesPageHeader = `${slotPageHeader}`);
    }
    if ($$self.$$.dirty & /*slotPageContent*/
    32768) {
      $:
        $$invalidate(4, classesPageContent = `${slotPageContent}`);
    }
    if ($$self.$$.dirty & /*slotPageFooter*/
    65536) {
      $:
        $$invalidate(3, classesPageFooter = `${slotPageFooter}`);
    }
    if ($$self.$$.dirty & /*slotFooter*/
    131072) {
      $:
        $$invalidate(2, classesFooter = `${slotFooter}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    scrollbarGutter,
    regionPage,
    classesFooter,
    classesPageFooter,
    classesPageContent,
    classesPageHeader,
    classesSidebarRight,
    classesSidebarLeft,
    classesHeader,
    classesBase,
    $$slots,
    slotHeader,
    slotSidebarLeft,
    slotSidebarRight,
    slotPageHeader,
    slotPageContent,
    slotPageFooter,
    slotFooter,
    $$scope,
    slots,
    scroll_handler
  ];
}
var AppShell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      scrollbarGutter: 0,
      regionPage: 1,
      slotHeader: 11,
      slotSidebarLeft: 12,
      slotSidebarRight: 13,
      slotPageHeader: 14,
      slotPageContent: 15,
      slotPageFooter: 16,
      slotFooter: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AppShell",
      options,
      id: create_fragment7.name
    });
  }
  get scrollbarGutter() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollbarGutter(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionPage() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionPage(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotHeader() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotHeader(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotSidebarLeft() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotSidebarLeft(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotSidebarRight() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotSidebarRight(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotPageHeader() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotPageHeader(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotPageContent() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotPageContent(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotPageFooter() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotPageFooter(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotFooter() {
    throw new Error("<AppShell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotFooter(value) {
    throw new Error("<AppShell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AppShell_default = AppShell;

// node_modules/@skeletonlabs/skeleton/dist/components/Autocomplete/Autocomplete.svelte
var file8 = "node_modules/@skeletonlabs/skeleton/dist/components/Autocomplete/Autocomplete.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[35] = list[i];
  return child_ctx;
}
function create_else_block2(ctx) {
  let div;
  let html_tag;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      html_tag = claim_html_tag(div_nodes, false);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(div, "class", div_class_value = "autocomplete-empty " + /*classesEmpty*/
      ctx[7]);
      add_location(div, file8, 95, 2, 3148);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      html_tag.m(
        /*emptyState*/
        ctx[0],
        div
      );
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*emptyState*/
      1)
        html_tag.p(
          /*emptyState*/
          ctx2[0]
        );
      if (dirty[0] & /*classesEmpty*/
      128 && div_class_value !== (div_class_value = "autocomplete-empty " + /*classesEmpty*/
      ctx2[7])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(95:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let nav;
  let ul;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let ul_class_value;
  let nav_class_value;
  let current;
  let each_value = ensure_array_like_dev(
    /*optionsFiltered*/
    ctx[6].slice(
      0,
      /*sliceLimit*/
      ctx[13]
    )
  );
  const get_key = (ctx2) => (
    /*option*/
    ctx2[35]
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      nav = element("nav");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      ul = claim_element(nav_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", ul_class_value = "autocomplete-list " + /*classesList*/
      ctx[10]);
      add_location(ul, file8, 80, 3, 2515);
      attr_dev(nav, "class", nav_class_value = "autocomplete-nav " + /*classesNav*/
      ctx[11]);
      add_location(nav, file8, 79, 2, 2468);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*classesItem, transitionOut, transitionOutParams, transitions, classesButton, onSelection, optionsFiltered, sliceLimit*/
      25458) {
        each_value = ensure_array_like_dev(
          /*optionsFiltered*/
          ctx2[6].slice(
            0,
            /*sliceLimit*/
            ctx2[13]
          )
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      if (!current || dirty[0] & /*classesList*/
      1024 && ul_class_value !== (ul_class_value = "autocomplete-list " + /*classesList*/
      ctx2[10])) {
        attr_dev(ul, "class", ul_class_value);
      }
      if (!current || dirty[0] & /*classesNav*/
      2048 && nav_class_value !== (nav_class_value = "autocomplete-nav " + /*classesNav*/
      ctx2[11])) {
        attr_dev(nav, "class", nav_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(nav);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(79:1) {#if optionsFiltered.length > 0}",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let li;
  let button;
  let html_tag;
  let raw_value = (
    /*option*/
    ctx[35].label + ""
  );
  let button_class_value;
  let t;
  let li_class_value;
  let li_intro;
  let li_outro;
  let current;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[29](
        /*option*/
        ctx[35]
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      li = element("li");
      button = element("button");
      html_tag = new HtmlTagHydration(false);
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      button = claim_element(li_nodes, "BUTTON", { class: true, type: true });
      var button_nodes = children(button);
      html_tag = claim_html_tag(button_nodes, false);
      button_nodes.forEach(detach_dev);
      t = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(button, "class", button_class_value = "autocomplete-button " + /*classesButton*/
      ctx[8]);
      attr_dev(button, "type", "button");
      add_location(button, file8, 87, 6, 2927);
      attr_dev(li, "class", li_class_value = "autocomplete-item " + /*classesItem*/
      ctx[9]);
      add_location(li, file8, 82, 5, 2633);
      this.first = li;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, button);
      html_tag.m(raw_value, button);
      append_hydration_dev(li, t);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", click_handler_1, false, false, false, false),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keypress",
            /*keypress_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*optionsFiltered, sliceLimit*/
      8256) && raw_value !== (raw_value = /*option*/
      ctx[35].label + ""))
        html_tag.p(raw_value);
      if (!current || dirty[0] & /*classesButton*/
      256 && button_class_value !== (button_class_value = "autocomplete-button " + /*classesButton*/
      ctx[8])) {
        attr_dev(button, "class", button_class_value);
      }
      if (!current || dirty[0] & /*classesItem*/
      512 && li_class_value !== (li_class_value = "autocomplete-item " + /*classesItem*/
      ctx[9])) {
        attr_dev(li, "class", li_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (li_outro)
            li_outro.end(1);
          li_intro = create_in_transition(li, dynamicTransition, {
            transition: (
              /*transitionIn*/
              ctx[2]
            ),
            params: (
              /*transitionInParams*/
              ctx[3]
            ),
            enabled: (
              /*transitions*/
              ctx[1]
            )
          });
          li_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (li_intro)
        li_intro.invalidate();
      if (local) {
        li_outro = create_out_transition(li, dynamicTransition, {
          transition: (
            /*transitionOut*/
            ctx[4]
          ),
          params: (
            /*transitionOutParams*/
            ctx[5]
          ),
          enabled: (
            /*transitions*/
            ctx[1]
          )
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      if (detaching && li_outro)
        li_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(82:4) {#each optionsFiltered.slice(0, sliceLimit) as option (option)}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let current;
  const if_block_creators = [create_if_block6, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*optionsFiltered*/
      ctx2[6].length > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "autocomplete " + /*classesBase*/
      ctx[12]);
      attr_dev(div, "data-testid", "autocomplete");
      add_location(div, file8, 77, 0, 2364);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty[0] & /*classesBase*/
      4096 && div_class_value !== (div_class_value = "autocomplete " + /*classesBase*/
      ctx2[12])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let listedOptions;
  let optionsFiltered;
  let sliceLimit;
  let classesBase;
  let classesNav;
  let classesList;
  let classesItem;
  let classesButton;
  let classesEmpty;
  let $prefersReducedMotionStore;
  validate_store(prefersReducedMotionStore, "prefersReducedMotionStore");
  component_subscribe($$self, prefersReducedMotionStore, ($$value) => $$invalidate(30, $prefersReducedMotionStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Autocomplete", slots, []);
  const dispatch = createEventDispatcher();
  let { input = void 0 } = $$props;
  let { options = [] } = $$props;
  let { limit = void 0 } = $$props;
  let { allowlist = [] } = $$props;
  let { denylist = [] } = $$props;
  let { emptyState = "No Results Found." } = $$props;
  let { regionNav = "" } = $$props;
  let { regionList = "list-nav" } = $$props;
  let { regionItem = "" } = $$props;
  let { regionButton = "w-full" } = $$props;
  let { regionEmpty = "text-center" } = $$props;
  let { filter: filter2 = filterOptions } = $$props;
  let { transitions = !$prefersReducedMotionStore } = $$props;
  let { transitionIn = slide } = $$props;
  let { transitionInParams = { duration: 200 } } = $$props;
  let { transitionOut = slide } = $$props;
  let { transitionOutParams = { duration: 200 } } = $$props;
  function filterByAllowDeny(allowlist2, denylist2) {
    let _options = [...options];
    if (allowlist2.length) {
      _options = _options.filter((option) => allowlist2.includes(option.value));
    }
    if (denylist2.length) {
      _options = _options.filter((option) => !denylist2.includes(option.value));
    }
    if (!allowlist2.length && !denylist2.length) {
      _options = options;
    }
    $$invalidate(26, listedOptions = _options);
  }
  function filterOptions() {
    let _options = [...listedOptions];
    _options = _options.filter((option) => {
      const inputFormatted = String(input).toLowerCase().trim();
      let optionFormatted = JSON.stringify([option.label, option.value, option.keywords]).toLowerCase();
      if (optionFormatted.includes(inputFormatted))
        return option;
    });
    return _options;
  }
  function onSelection(option) {
    dispatch("selection", option);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler_1 = (option) => onSelection(option);
  $$self.$$set = ($$new_props) => {
    $$invalidate(34, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("input" in $$new_props)
      $$invalidate(15, input = $$new_props.input);
    if ("options" in $$new_props)
      $$invalidate(16, options = $$new_props.options);
    if ("limit" in $$new_props)
      $$invalidate(17, limit = $$new_props.limit);
    if ("allowlist" in $$new_props)
      $$invalidate(18, allowlist = $$new_props.allowlist);
    if ("denylist" in $$new_props)
      $$invalidate(19, denylist = $$new_props.denylist);
    if ("emptyState" in $$new_props)
      $$invalidate(0, emptyState = $$new_props.emptyState);
    if ("regionNav" in $$new_props)
      $$invalidate(20, regionNav = $$new_props.regionNav);
    if ("regionList" in $$new_props)
      $$invalidate(21, regionList = $$new_props.regionList);
    if ("regionItem" in $$new_props)
      $$invalidate(22, regionItem = $$new_props.regionItem);
    if ("regionButton" in $$new_props)
      $$invalidate(23, regionButton = $$new_props.regionButton);
    if ("regionEmpty" in $$new_props)
      $$invalidate(24, regionEmpty = $$new_props.regionEmpty);
    if ("filter" in $$new_props)
      $$invalidate(25, filter2 = $$new_props.filter);
    if ("transitions" in $$new_props)
      $$invalidate(1, transitions = $$new_props.transitions);
    if ("transitionIn" in $$new_props)
      $$invalidate(2, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$new_props)
      $$invalidate(3, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$new_props)
      $$invalidate(4, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$new_props)
      $$invalidate(5, transitionOutParams = $$new_props.transitionOutParams);
  };
  $$self.$capture_state = () => ({
    slide,
    prefersReducedMotionStore,
    dynamicTransition,
    createEventDispatcher,
    dispatch,
    input,
    options,
    limit,
    allowlist,
    denylist,
    emptyState,
    regionNav,
    regionList,
    regionItem,
    regionButton,
    regionEmpty,
    filter: filter2,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    filterByAllowDeny,
    filterOptions,
    onSelection,
    classesEmpty,
    classesButton,
    classesItem,
    classesList,
    classesNav,
    classesBase,
    optionsFiltered,
    sliceLimit,
    listedOptions,
    $prefersReducedMotionStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(34, $$props = assign(assign({}, $$props), $$new_props));
    if ("input" in $$props)
      $$invalidate(15, input = $$new_props.input);
    if ("options" in $$props)
      $$invalidate(16, options = $$new_props.options);
    if ("limit" in $$props)
      $$invalidate(17, limit = $$new_props.limit);
    if ("allowlist" in $$props)
      $$invalidate(18, allowlist = $$new_props.allowlist);
    if ("denylist" in $$props)
      $$invalidate(19, denylist = $$new_props.denylist);
    if ("emptyState" in $$props)
      $$invalidate(0, emptyState = $$new_props.emptyState);
    if ("regionNav" in $$props)
      $$invalidate(20, regionNav = $$new_props.regionNav);
    if ("regionList" in $$props)
      $$invalidate(21, regionList = $$new_props.regionList);
    if ("regionItem" in $$props)
      $$invalidate(22, regionItem = $$new_props.regionItem);
    if ("regionButton" in $$props)
      $$invalidate(23, regionButton = $$new_props.regionButton);
    if ("regionEmpty" in $$props)
      $$invalidate(24, regionEmpty = $$new_props.regionEmpty);
    if ("filter" in $$props)
      $$invalidate(25, filter2 = $$new_props.filter);
    if ("transitions" in $$props)
      $$invalidate(1, transitions = $$new_props.transitions);
    if ("transitionIn" in $$props)
      $$invalidate(2, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$props)
      $$invalidate(3, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$props)
      $$invalidate(4, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$props)
      $$invalidate(5, transitionOutParams = $$new_props.transitionOutParams);
    if ("classesEmpty" in $$props)
      $$invalidate(7, classesEmpty = $$new_props.classesEmpty);
    if ("classesButton" in $$props)
      $$invalidate(8, classesButton = $$new_props.classesButton);
    if ("classesItem" in $$props)
      $$invalidate(9, classesItem = $$new_props.classesItem);
    if ("classesList" in $$props)
      $$invalidate(10, classesList = $$new_props.classesList);
    if ("classesNav" in $$props)
      $$invalidate(11, classesNav = $$new_props.classesNav);
    if ("classesBase" in $$props)
      $$invalidate(12, classesBase = $$new_props.classesBase);
    if ("optionsFiltered" in $$props)
      $$invalidate(6, optionsFiltered = $$new_props.optionsFiltered);
    if ("sliceLimit" in $$props)
      $$invalidate(13, sliceLimit = $$new_props.sliceLimit);
    if ("listedOptions" in $$props)
      $$invalidate(26, listedOptions = $$new_props.listedOptions);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*options*/
    65536) {
      $:
        $$invalidate(26, listedOptions = options);
    }
    if ($$self.$$.dirty[0] & /*allowlist, denylist*/
    786432) {
      $:
        filterByAllowDeny(allowlist, denylist);
    }
    if ($$self.$$.dirty[0] & /*input, filter, listedOptions*/
    100696064) {
      $:
        $$invalidate(6, optionsFiltered = input ? filter2() : listedOptions);
    }
    if ($$self.$$.dirty[0] & /*limit, optionsFiltered*/
    131136) {
      $:
        $$invalidate(13, sliceLimit = limit ?? optionsFiltered.length);
    }
    $:
      $$invalidate(12, classesBase = `${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*regionNav*/
    1048576) {
      $:
        $$invalidate(11, classesNav = `${regionNav}`);
    }
    if ($$self.$$.dirty[0] & /*regionList*/
    2097152) {
      $:
        $$invalidate(10, classesList = `${regionList}`);
    }
    if ($$self.$$.dirty[0] & /*regionItem*/
    4194304) {
      $:
        $$invalidate(9, classesItem = `${regionItem}`);
    }
    if ($$self.$$.dirty[0] & /*regionButton*/
    8388608) {
      $:
        $$invalidate(8, classesButton = `${regionButton}`);
    }
    if ($$self.$$.dirty[0] & /*regionEmpty*/
    16777216) {
      $:
        $$invalidate(7, classesEmpty = `${regionEmpty}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    emptyState,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    optionsFiltered,
    classesEmpty,
    classesButton,
    classesItem,
    classesList,
    classesNav,
    classesBase,
    sliceLimit,
    onSelection,
    input,
    options,
    limit,
    allowlist,
    denylist,
    regionNav,
    regionList,
    regionItem,
    regionButton,
    regionEmpty,
    filter2,
    listedOptions,
    click_handler,
    keypress_handler,
    click_handler_1
  ];
}
var Autocomplete = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        input: 15,
        options: 16,
        limit: 17,
        allowlist: 18,
        denylist: 19,
        emptyState: 0,
        regionNav: 20,
        regionList: 21,
        regionItem: 22,
        regionButton: 23,
        regionEmpty: 24,
        filter: 25,
        transitions: 1,
        transitionIn: 2,
        transitionInParams: 3,
        transitionOut: 4,
        transitionOutParams: 5
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Autocomplete",
      options,
      id: create_fragment8.name
    });
  }
  get input() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get limit() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set limit(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowlist() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowlist(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get denylist() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set denylist(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get emptyState() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set emptyState(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionNav() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionNav(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionList() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionList(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionItem() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionItem(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionButton() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionButton(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionEmpty() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionEmpty(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get filter() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set filter(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitions() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitions(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionIn() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionIn(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionInParams() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionInParams(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOut() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOut(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOutParams() {
    throw new Error("<Autocomplete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOutParams(value) {
    throw new Error("<Autocomplete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Autocomplete_default = Autocomplete;

// node_modules/@skeletonlabs/skeleton/dist/components/Avatar/Avatar.svelte
var file9 = "node_modules/@skeletonlabs/skeleton/dist/components/Avatar/Avatar.svelte";
function create_else_block3(ctx) {
  let svg;
  let text_1;
  let t_value = String(
    /*initials*/
    ctx[1]
  ).substring(0, 2).toUpperCase() + "";
  let t;
  let text_1_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      text_1 = svg_element("text");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { class: true, viewBox: true });
      var svg_nodes = children(svg);
      text_1 = claim_svg_element(svg_nodes, "text", {
        x: true,
        y: true,
        "dominant-baseline": true,
        "text-anchor": true,
        "font-weight": true,
        "font-size": true,
        class: true
      });
      var text_1_nodes = children(text_1);
      t = claim_text(text_1_nodes, t_value);
      text_1_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "x", "50%");
      attr_dev(text_1, "y", "50%");
      attr_dev(text_1, "dominant-baseline", "central");
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "font-weight", "bold");
      attr_dev(
        text_1,
        "font-size",
        /*fontSize*/
        ctx[3]
      );
      attr_dev(text_1, "class", text_1_class_value = "avatar-text " + /*fill*/
      ctx[2]);
      add_location(text_1, file9, 39, 3, 1253);
      attr_dev(svg, "class", "avatar-initials w-full h-full");
      attr_dev(svg, "viewBox", "0 0 512 512");
      add_location(svg, file9, 38, 2, 1184);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, text_1);
      append_hydration_dev(text_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*initials*/
      2 && t_value !== (t_value = String(
        /*initials*/
        ctx2[1]
      ).substring(0, 2).toUpperCase() + ""))
        set_data_dev(t, t_value);
      if (dirty & /*fontSize*/
      8) {
        attr_dev(
          text_1,
          "font-size",
          /*fontSize*/
          ctx2[3]
        );
      }
      if (dirty & /*fill*/
      4 && text_1_class_value !== (text_1_class_value = "avatar-text " + /*fill*/
      ctx2[2])) {
        attr_dev(text_1, "class", text_1_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(38:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block7(ctx) {
  let img;
  let img_class_value;
  let img_style_value;
  let img_src_value;
  let img_alt_value;
  let action_action;
  let mounted;
  let dispose;
  let img_levels = [
    {
      class: img_class_value = "avatar-image " + /*cImage*/
      ctx[8]
    },
    {
      style: img_style_value = /*$$props*/
      ctx[10].style ?? ""
    },
    { src: img_src_value = /*src*/
    ctx[0] },
    {
      alt: img_alt_value = /*$$props*/
      ctx[10].alt || ""
    },
    /*prunedRestProps*/
    ctx[9]()
  ];
  let img_data = {};
  for (let i = 0; i < img_levels.length; i += 1) {
    img_data = assign(img_data, img_levels[i]);
  }
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", {
        class: true,
        style: true,
        src: true,
        alt: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(img, img_data);
      add_location(img, file9, 28, 2, 971);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(action_action = /*action*/
          ctx[5].call(
            null,
            img,
            /*actionParams*/
            ctx[6]
          )),
          listen_dev(
            img,
            "error",
            /*error_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(img, img_data = get_spread_update(img_levels, [
        { class: img_class_value },
        dirty & /*$$props*/
        1024 && img_style_value !== (img_style_value = /*$$props*/
        ctx2[10].style ?? "") && { style: img_style_value },
        dirty & /*src*/
        1 && !src_url_equal(img.src, img_src_value = /*src*/
        ctx2[0]) && { src: img_src_value },
        dirty & /*$$props*/
        1024 && img_alt_value !== (img_alt_value = /*$$props*/
        ctx2[10].alt || "") && { alt: img_alt_value },
        /*prunedRestProps*/
        ctx2[9]()
      ]));
      if (action_action && is_function(action_action.update) && dirty & /*actionParams*/
      64)
        action_action.update.call(
          null,
          /*actionParams*/
          ctx2[6]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(28:1) {#if src}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let figure;
  let figure_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*src*/
      ctx2[0]
    )
      return create_if_block7;
    return create_else_block3;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      figure = element("figure");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", { class: true, "data-testid": true });
      var figure_nodes = children(figure);
      if_block.l(figure_nodes);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figure, "class", figure_class_value = "avatar " + /*classesBase*/
      ctx[7]);
      attr_dev(figure, "data-testid", "avatar");
      add_location(figure, file9, 26, 0, 858);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      if_block.m(figure, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            figure,
            "click",
            /*click_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            figure,
            "keydown",
            /*keydown_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            figure,
            "keyup",
            /*keyup_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            figure,
            "keypress",
            /*keypress_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(figure, null);
        }
      }
      if (dirty & /*classesBase*/
      128 && figure_class_value !== (figure_class_value = "avatar " + /*classesBase*/
      ctx2[7])) {
        attr_dev(figure, "class", figure_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(figure);
      }
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let classesBase;
  const omit_props_names = [
    "initials",
    "fill",
    "fontSize",
    "src",
    "fallback",
    "action",
    "actionParams",
    "background",
    "width",
    "border",
    "rounded",
    "shadow",
    "cursor"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Avatar", slots, []);
  let { initials = "AB" } = $$props;
  let { fill = "fill-token" } = $$props;
  let { fontSize = 150 } = $$props;
  let { src = "" } = $$props;
  let { fallback = "" } = $$props;
  let { action = () => {
  } } = $$props;
  let { actionParams = "" } = $$props;
  let { background = "bg-surface-400-500-token" } = $$props;
  let { width = "w-16" } = $$props;
  let { border = "" } = $$props;
  let { rounded = "rounded-full" } = $$props;
  let { shadow = "" } = $$props;
  let { cursor = "" } = $$props;
  let cBase26 = "flex aspect-square text-surface-50 font-semibold justify-center items-center overflow-hidden isolate";
  let cImage = "w-full object-cover";
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  const error_handler = () => $$invalidate(0, src = fallback);
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(23, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("initials" in $$new_props)
      $$invalidate(1, initials = $$new_props.initials);
    if ("fill" in $$new_props)
      $$invalidate(2, fill = $$new_props.fill);
    if ("fontSize" in $$new_props)
      $$invalidate(3, fontSize = $$new_props.fontSize);
    if ("src" in $$new_props)
      $$invalidate(0, src = $$new_props.src);
    if ("fallback" in $$new_props)
      $$invalidate(4, fallback = $$new_props.fallback);
    if ("action" in $$new_props)
      $$invalidate(5, action = $$new_props.action);
    if ("actionParams" in $$new_props)
      $$invalidate(6, actionParams = $$new_props.actionParams);
    if ("background" in $$new_props)
      $$invalidate(11, background = $$new_props.background);
    if ("width" in $$new_props)
      $$invalidate(12, width = $$new_props.width);
    if ("border" in $$new_props)
      $$invalidate(13, border = $$new_props.border);
    if ("rounded" in $$new_props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(15, shadow = $$new_props.shadow);
    if ("cursor" in $$new_props)
      $$invalidate(16, cursor = $$new_props.cursor);
  };
  $$self.$capture_state = () => ({
    initials,
    fill,
    fontSize,
    src,
    fallback,
    action,
    actionParams,
    background,
    width,
    border,
    rounded,
    shadow,
    cursor,
    cBase: cBase26,
    cImage,
    prunedRestProps,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
    if ("initials" in $$props)
      $$invalidate(1, initials = $$new_props.initials);
    if ("fill" in $$props)
      $$invalidate(2, fill = $$new_props.fill);
    if ("fontSize" in $$props)
      $$invalidate(3, fontSize = $$new_props.fontSize);
    if ("src" in $$props)
      $$invalidate(0, src = $$new_props.src);
    if ("fallback" in $$props)
      $$invalidate(4, fallback = $$new_props.fallback);
    if ("action" in $$props)
      $$invalidate(5, action = $$new_props.action);
    if ("actionParams" in $$props)
      $$invalidate(6, actionParams = $$new_props.actionParams);
    if ("background" in $$props)
      $$invalidate(11, background = $$new_props.background);
    if ("width" in $$props)
      $$invalidate(12, width = $$new_props.width);
    if ("border" in $$props)
      $$invalidate(13, border = $$new_props.border);
    if ("rounded" in $$props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(15, shadow = $$new_props.shadow);
    if ("cursor" in $$props)
      $$invalidate(16, cursor = $$new_props.cursor);
    if ("cBase" in $$props)
      $$invalidate(22, cBase26 = $$new_props.cBase);
    if ("cImage" in $$props)
      $$invalidate(8, cImage = $$new_props.cImage);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(7, classesBase = `${cBase26} ${background} ${width} ${border} ${rounded} ${shadow} ${cursor} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    src,
    initials,
    fill,
    fontSize,
    fallback,
    action,
    actionParams,
    classesBase,
    cImage,
    prunedRestProps,
    $$props,
    background,
    width,
    border,
    rounded,
    shadow,
    cursor,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    error_handler
  ];
}
var Avatar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {
      initials: 1,
      fill: 2,
      fontSize: 3,
      src: 0,
      fallback: 4,
      action: 5,
      actionParams: 6,
      background: 11,
      width: 12,
      border: 13,
      rounded: 14,
      shadow: 15,
      cursor: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Avatar",
      options,
      id: create_fragment9.name
    });
  }
  get initials() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set initials(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fontSize() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fontSize(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fallback() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fallback(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get action() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set action(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get actionParams() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actionParams(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cursor() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cursor(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Avatar_default = Avatar;

// node_modules/@skeletonlabs/skeleton/dist/components/ConicGradient/settings.js
var tailwindDefaultColors = [
  {
    label: "slate",
    shades: {
      "50": { hex: "#f8fafc", rgb: "248 250 252" },
      "100": { hex: "#f1f5f9", rgb: "241 245 249" },
      "200": { hex: "#e2e8f0", rgb: "226 232 240" },
      "300": { hex: "#cbd5e1", rgb: "203 213 225" },
      "400": { hex: "#94a3b8", rgb: "148 163 184" },
      "500": { hex: "#64748b", rgb: "100 116 139" },
      "600": { hex: "#475569", rgb: "71 85 105" },
      "700": { hex: "#334155", rgb: "51 65 85" },
      "800": { hex: "#1e293b", rgb: "30 41 59" },
      "900": { hex: "#0f172a", rgb: "15 23 42" }
    }
  },
  {
    label: "gray",
    shades: {
      "50": { hex: "#f9fafb", rgb: "249 250 251" },
      "100": { hex: "#f3f4f6", rgb: "243 244 246" },
      "200": { hex: "#e5e7eb", rgb: "229 231 235" },
      "300": { hex: "#d1d5db", rgb: "209 213 219" },
      "400": { hex: "#9ca3af", rgb: "156 163 175" },
      "500": { hex: "#6b7280", rgb: "107 114 128" },
      "600": { hex: "#4b5563", rgb: "75 85 99" },
      "700": { hex: "#374151", rgb: "55 65 81" },
      "800": { hex: "#1f2937", rgb: "31 41 55" },
      "900": { hex: "#111827", rgb: "17 24 39" }
    }
  },
  {
    label: "zinc",
    shades: {
      "50": { hex: "#fafafa", rgb: "250 250 250" },
      "100": { hex: "#f4f4f5", rgb: "244 244 245" },
      "200": { hex: "#e4e4e7", rgb: "228 228 231" },
      "300": { hex: "#d4d4d8", rgb: "212 212 216" },
      "400": { hex: "#a1a1aa", rgb: "161 161 170" },
      "500": { hex: "#71717a", rgb: "113 113 122" },
      "600": { hex: "#52525b", rgb: "82 82 91" },
      "700": { hex: "#3f3f46", rgb: "63 63 70" },
      "800": { hex: "#27272a", rgb: "39 39 42" },
      "900": { hex: "#18181b", rgb: "24 24 27" }
    }
  },
  {
    label: "neutral",
    shades: {
      "50": { hex: "#fafafa", rgb: "250 250 250" },
      "100": { hex: "#f5f5f5", rgb: "245 245 245" },
      "200": { hex: "#e5e5e5", rgb: "229 229 229" },
      "300": { hex: "#d4d4d4", rgb: "212 212 212" },
      "400": { hex: "#a3a3a3", rgb: "163 163 163" },
      "500": { hex: "#737373", rgb: "115 115 115" },
      "600": { hex: "#525252", rgb: "82 82 82" },
      "700": { hex: "#404040", rgb: "64 64 64" },
      "800": { hex: "#262626", rgb: "38 38 38" },
      "900": { hex: "#171717", rgb: "23 23 23" }
    }
  },
  {
    label: "stone",
    shades: {
      "50": { hex: "#fafaf9", rgb: "250 250 249" },
      "100": { hex: "#f5f5f4", rgb: "245 245 244" },
      "200": { hex: "#e7e5e4", rgb: "231 229 228" },
      "300": { hex: "#d6d3d1", rgb: "214 211 209" },
      "400": { hex: "#a8a29e", rgb: "168 162 158" },
      "500": { hex: "#78716c", rgb: "120 113 108" },
      "600": { hex: "#57534e", rgb: "87 83 78" },
      "700": { hex: "#44403c", rgb: "68 64 60" },
      "800": { hex: "#292524", rgb: "41 37 36" },
      "900": { hex: "#1c1917", rgb: "28 25 23" }
    }
  },
  {
    label: "red",
    shades: {
      "50": { hex: "#fef2f2", rgb: "254 242 242" },
      "100": { hex: "#fee2e2", rgb: "254 226 226" },
      "200": { hex: "#fecaca", rgb: "254 202 202" },
      "300": { hex: "#fca5a5", rgb: "252 165 165" },
      "400": { hex: "#f87171", rgb: "248 113 113" },
      "500": { hex: "#ef4444", rgb: "239 68 68" },
      "600": { hex: "#dc2626", rgb: "220 38 38" },
      "700": { hex: "#b91c1c", rgb: "185 28 28" },
      "800": { hex: "#991b1b", rgb: "153 27 27" },
      "900": { hex: "#7f1d1d", rgb: "127 29 29" }
    }
  },
  {
    label: "orange",
    shades: {
      "50": { hex: "#fff7ed", rgb: "255 247 237" },
      "100": { hex: "#ffedd5", rgb: "255 237 213" },
      "200": { hex: "#fed7aa", rgb: "254 215 170" },
      "300": { hex: "#fdba74", rgb: "253 186 116" },
      "400": { hex: "#fb923c", rgb: "251 146 60" },
      "500": { hex: "#f97316", rgb: "249 115 22" },
      "600": { hex: "#ea580c", rgb: "234 88 12" },
      "700": { hex: "#c2410c", rgb: "194 65 12" },
      "800": { hex: "#9a3412", rgb: "154 52 18" },
      "900": { hex: "#7c2d12", rgb: "124 45 18" }
    }
  },
  {
    label: "amber",
    shades: {
      "50": { hex: "#fffbeb", rgb: "255 251 235" },
      "100": { hex: "#fef3c7", rgb: "254 243 199" },
      "200": { hex: "#fde68a", rgb: "253 230 138" },
      "300": { hex: "#fcd34d", rgb: "252 211 77" },
      "400": { hex: "#fbbf24", rgb: "251 191 36" },
      "500": { hex: "#f59e0b", rgb: "245 158 11" },
      "600": { hex: "#d97706", rgb: "217 119 6" },
      "700": { hex: "#b45309", rgb: "180 83 9" },
      "800": { hex: "#92400e", rgb: "146 64 14" },
      "900": { hex: "#78350f", rgb: "120 53 15" }
    }
  },
  {
    label: "yellow",
    shades: {
      "50": { hex: "#fefce8", rgb: "254 252 232" },
      "100": { hex: "#fef9c3", rgb: "254 249 195" },
      "200": { hex: "#fef08a", rgb: "254 240 138" },
      "300": { hex: "#fde047", rgb: "253 224 71" },
      "400": { hex: "#facc15", rgb: "250 204 21" },
      "500": { hex: "#eab308", rgb: "234 179 8" },
      "600": { hex: "#ca8a04", rgb: "202 138 4" },
      "700": { hex: "#a16207", rgb: "161 98 7" },
      "800": { hex: "#854d0e", rgb: "133 77 14" },
      "900": { hex: "#713f12", rgb: "113 63 18" }
    }
  },
  {
    label: "lime",
    shades: {
      "50": { hex: "#f7fee7", rgb: "247 254 231" },
      "100": { hex: "#ecfccb", rgb: "236 252 203" },
      "200": { hex: "#d9f99d", rgb: "217 249 157" },
      "300": { hex: "#bef264", rgb: "190 242 100" },
      "400": { hex: "#a3e635", rgb: "163 230 53" },
      "500": { hex: "#84cc16", rgb: "132 204 22" },
      "600": { hex: "#65a30d", rgb: "101 163 13" },
      "700": { hex: "#4d7c0f", rgb: "77 124 15" },
      "800": { hex: "#3f6212", rgb: "63 98 18" },
      "900": { hex: "#365314", rgb: "54 83 20" }
    }
  },
  {
    label: "green",
    shades: {
      "50": { hex: "#f0fdf4", rgb: "240 253 244" },
      "100": { hex: "#dcfce7", rgb: "220 252 231" },
      "200": { hex: "#bbf7d0", rgb: "187 247 208" },
      "300": { hex: "#86efac", rgb: "134 239 172" },
      "400": { hex: "#4ade80", rgb: "74 222 128" },
      "500": { hex: "#22c55e", rgb: "34 197 94" },
      "600": { hex: "#16a34a", rgb: "22 163 74" },
      "700": { hex: "#15803d", rgb: "21 128 61" },
      "800": { hex: "#166534", rgb: "22 101 52" },
      "900": { hex: "#14532d", rgb: "20 83 45" }
    }
  },
  {
    label: "emerald",
    shades: {
      "50": { hex: "#ecfdf5", rgb: "236 253 245" },
      "100": { hex: "#d1fae5", rgb: "209 250 229" },
      "200": { hex: "#a7f3d0", rgb: "167 243 208" },
      "300": { hex: "#6ee7b7", rgb: "110 231 183" },
      "400": { hex: "#34d399", rgb: "52 211 153" },
      "500": { hex: "#10b981", rgb: "16 185 129" },
      "600": { hex: "#059669", rgb: "5 150 105" },
      "700": { hex: "#047857", rgb: "4 120 87" },
      "800": { hex: "#065f46", rgb: "6 95 70" },
      "900": { hex: "#064e3b", rgb: "6 78 59" }
    }
  },
  {
    label: "teal",
    shades: {
      "50": { hex: "#f0fdfa", rgb: "240 253 250" },
      "100": { hex: "#ccfbf1", rgb: "204 251 241" },
      "200": { hex: "#99f6e4", rgb: "153 246 228" },
      "300": { hex: "#5eead4", rgb: "94 234 212" },
      "400": { hex: "#2dd4bf", rgb: "45 212 191" },
      "500": { hex: "#14b8a6", rgb: "20 184 166" },
      "600": { hex: "#0d9488", rgb: "13 148 136" },
      "700": { hex: "#0f766e", rgb: "15 118 110" },
      "800": { hex: "#115e59", rgb: "17 94 89" },
      "900": { hex: "#134e4a", rgb: "19 78 74" }
    }
  },
  {
    label: "cyan",
    shades: {
      "50": { hex: "#ecfeff", rgb: "236 254 255" },
      "100": { hex: "#cffafe", rgb: "207 250 254" },
      "200": { hex: "#a5f3fc", rgb: "165 243 252" },
      "300": { hex: "#67e8f9", rgb: "103 232 249" },
      "400": { hex: "#22d3ee", rgb: "34 211 238" },
      "500": { hex: "#06b6d4", rgb: "6 182 212" },
      "600": { hex: "#0891b2", rgb: "8 145 178" },
      "700": { hex: "#0e7490", rgb: "14 116 144" },
      "800": { hex: "#155e75", rgb: "21 94 117" },
      "900": { hex: "#164e63", rgb: "22 78 99" }
    }
  },
  {
    label: "sky",
    shades: {
      "50": { hex: "#f0f9ff", rgb: "240 249 255" },
      "100": { hex: "#e0f2fe", rgb: "224 242 254" },
      "200": { hex: "#bae6fd", rgb: "186 230 253" },
      "300": { hex: "#7dd3fc", rgb: "125 211 252" },
      "400": { hex: "#38bdf8", rgb: "56 189 248" },
      "500": { hex: "#0ea5e9", rgb: "14 165 233" },
      "600": { hex: "#0284c7", rgb: "2 132 199" },
      "700": { hex: "#0369a1", rgb: "3 105 161" },
      "800": { hex: "#075985", rgb: "7 89 133" },
      "900": { hex: "#0c4a6e", rgb: "12 74 110" }
    }
  },
  {
    label: "blue",
    shades: {
      "50": { hex: "#eff6ff", rgb: "239 246 255" },
      "100": { hex: "#dbeafe", rgb: "219 234 254" },
      "200": { hex: "#bfdbfe", rgb: "191 219 254" },
      "300": { hex: "#93c5fd", rgb: "147 197 253" },
      "400": { hex: "#60a5fa", rgb: "96 165 250" },
      "500": { hex: "#3b82f6", rgb: "59 130 246" },
      "600": { hex: "#2563eb", rgb: "37 99 235" },
      "700": { hex: "#1d4ed8", rgb: "29 78 216" },
      "800": { hex: "#1e40af", rgb: "30 64 175" },
      "900": { hex: "#1e3a8a", rgb: "30 58 138" }
    }
  },
  {
    label: "indigo",
    shades: {
      "50": { hex: "#eef2ff", rgb: "238 242 255" },
      "100": { hex: "#e0e7ff", rgb: "224 231 255" },
      "200": { hex: "#c7d2fe", rgb: "199 210 254" },
      "300": { hex: "#a5b4fc", rgb: "165 180 252" },
      "400": { hex: "#818cf8", rgb: "129 140 248" },
      "500": { hex: "#6366f1", rgb: "99 102 241" },
      "600": { hex: "#4f46e5", rgb: "79 70 229" },
      "700": { hex: "#4338ca", rgb: "67 56 202" },
      "800": { hex: "#3730a3", rgb: "55 48 163" },
      "900": { hex: "#312e81", rgb: "49 46 129" }
    }
  },
  {
    label: "violet",
    shades: {
      "50": { hex: "#f5f3ff", rgb: "245 243 255" },
      "100": { hex: "#ede9fe", rgb: "237 233 254" },
      "200": { hex: "#ddd6fe", rgb: "221 214 254" },
      "300": { hex: "#c4b5fd", rgb: "196 181 253" },
      "400": { hex: "#a78bfa", rgb: "167 139 250" },
      "500": { hex: "#8b5cf6", rgb: "139 92 246" },
      "600": { hex: "#7c3aed", rgb: "124 58 237" },
      "700": { hex: "#6d28d9", rgb: "109 40 217" },
      "800": { hex: "#5b21b6", rgb: "91 33 182" },
      "900": { hex: "#4c1d95", rgb: "76 29 149" }
    }
  },
  {
    label: "purple",
    shades: {
      "50": { hex: "#faf5ff", rgb: "250 245 255" },
      "100": { hex: "#f3e8ff", rgb: "243 232 255" },
      "200": { hex: "#e9d5ff", rgb: "233 213 255" },
      "300": { hex: "#d8b4fe", rgb: "216 180 254" },
      "400": { hex: "#c084fc", rgb: "192 132 252" },
      "500": { hex: "#a855f7", rgb: "168 85 247" },
      "600": { hex: "#9333ea", rgb: "147 51 234" },
      "700": { hex: "#7e22ce", rgb: "126 34 206" },
      "800": { hex: "#6b21a8", rgb: "107 33 168" },
      "900": { hex: "#581c87", rgb: "88 28 135" }
    }
  },
  {
    label: "fuchsia",
    shades: {
      "50": { hex: "#fdf4ff", rgb: "253 244 255" },
      "100": { hex: "#fae8ff", rgb: "250 232 255" },
      "200": { hex: "#f5d0fe", rgb: "245 208 254" },
      "300": { hex: "#f0abfc", rgb: "240 171 252" },
      "400": { hex: "#e879f9", rgb: "232 121 249" },
      "500": { hex: "#d946ef", rgb: "217 70 239" },
      "600": { hex: "#c026d3", rgb: "192 38 211" },
      "700": { hex: "#a21caf", rgb: "162 28 175" },
      "800": { hex: "#86198f", rgb: "134 25 143" },
      "900": { hex: "#701a75", rgb: "112 26 117" }
    }
  },
  {
    label: "pink",
    shades: {
      "50": { hex: "#fdf2f8", rgb: "253 242 248" },
      "100": { hex: "#fce7f3", rgb: "252 231 243" },
      "200": { hex: "#fbcfe8", rgb: "251 207 232" },
      "300": { hex: "#f9a8d4", rgb: "249 168 212" },
      "400": { hex: "#f472b6", rgb: "244 114 182" },
      "500": { hex: "#ec4899", rgb: "236 72 153" },
      "600": { hex: "#db2777", rgb: "219 39 119" },
      "700": { hex: "#be185d", rgb: "190 24 93" },
      "800": { hex: "#9d174d", rgb: "157 23 77" },
      "900": { hex: "#831843", rgb: "131 24 67" }
    }
  },
  {
    label: "rose",
    shades: {
      "50": { hex: "#fff1f2", rgb: "255 241 242" },
      "100": { hex: "#ffe4e6", rgb: "255 228 230" },
      "200": { hex: "#fecdd3", rgb: "254 205 211" },
      "300": { hex: "#fda4af", rgb: "253 164 175" },
      "400": { hex: "#fb7185", rgb: "251 113 133" },
      "500": { hex: "#f43f5e", rgb: "244 63 94" },
      "600": { hex: "#e11d48", rgb: "225 29 72" },
      "700": { hex: "#be123c", rgb: "190 18 60" },
      "800": { hex: "#9f1239", rgb: "159 18 57" },
      "900": { hex: "#881337", rgb: "136 19 55" }
    }
  }
];

// node_modules/@skeletonlabs/skeleton/dist/components/ConicGradient/ConicGradient.svelte
var file10 = "node_modules/@skeletonlabs/skeleton/dist/components/ConicGradient/ConicGradient.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i].color;
  child_ctx[27] = list[i].label;
  child_ctx[28] = list[i].value;
  return child_ctx;
}
function create_if_block_24(ctx) {
  let figcaption;
  let figcaption_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  const block = {
    c: function create() {
      figcaption = element("figcaption");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      figcaption = claim_element(nodes, "FIGCAPTION", { class: true });
      var figcaption_nodes = children(figcaption);
      if (default_slot)
        default_slot.l(figcaption_nodes);
      figcaption_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figcaption, "class", figcaption_class_value = "conic-caption " + /*classesCaption*/
      ctx[7]);
      add_location(figcaption, file10, 56, 2, 1670);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figcaption, anchor);
      if (default_slot) {
        default_slot.m(figcaption, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesCaption*/
      128 && figcaption_class_value !== (figcaption_class_value = "conic-caption " + /*classesCaption*/
      ctx2[7])) {
        attr_dev(figcaption, "class", figcaption_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(figcaption);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_24.name,
    type: "if",
    source: "(56:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "conic-cone " + /*classesCone*/
      ctx[6]);
      toggle_class(
        div,
        "animate-spin",
        /*spin*/
        ctx[1]
      );
      set_style(
        div,
        "background",
        /*cone*/
        ctx[3]
      );
      add_location(div, file10, 60, 2, 1789);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*classesCone*/
      64 && div_class_value !== (div_class_value = "conic-cone " + /*classesCone*/
      ctx2[6])) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & /*classesCone, spin*/
      66) {
        toggle_class(
          div,
          "animate-spin",
          /*spin*/
          ctx2[1]
        );
      }
      if (dirty & /*cone*/
      8) {
        set_style(
          div,
          "background",
          /*cone*/
          ctx2[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(60:1) {#if cone}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let ul;
  let ul_class_value;
  let each_value = ensure_array_like_dev(
    /*generatedLegendList*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", ul_class_value = "conic-list list " + /*classesLegend*/
      ctx[5]);
      add_location(ul, file10, 64, 2, 1943);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*hover, generatedLegendList, cSwatch*/
      20) {
        each_value = ensure_array_like_dev(
          /*generatedLegendList*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*classesLegend*/
      32 && ul_class_value !== (ul_class_value = "conic-list list " + /*classesLegend*/
      ctx2[5])) {
        attr_dev(ul, "class", ul_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(64:1) {#if legend && generatedLegendList}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let li;
  let span0;
  let span0_class_value;
  let t0;
  let span1;
  let t1_value = (
    /*label*/
    ctx[27] + ""
  );
  let t1;
  let t2;
  let strong;
  let t3_value = (
    /*value*/
    ctx[28] + ""
  );
  let t3;
  let t4;
  let t5;
  let li_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      li = element("li");
      span0 = element("span");
      t0 = space();
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      strong = element("strong");
      t3 = text(t3_value);
      t4 = text("%");
      t5 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      span0 = claim_element(li_nodes, "SPAN", { class: true });
      children(span0).forEach(detach_dev);
      t0 = claim_space(li_nodes);
      span1 = claim_element(li_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, t1_value);
      span1_nodes.forEach(detach_dev);
      t2 = claim_space(li_nodes);
      strong = claim_element(li_nodes, "STRONG", { class: true });
      var strong_nodes = children(strong);
      t3 = claim_text(strong_nodes, t3_value);
      t4 = claim_text(strong_nodes, "%");
      strong_nodes.forEach(detach_dev);
      t5 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = "conic-swatch " + cSwatch);
      set_style(
        span0,
        "background",
        /*color*/
        ctx[26]
      );
      add_location(span0, file10, 69, 5, 2241);
      attr_dev(span1, "class", "conic-label flex-auto");
      add_location(span1, file10, 70, 5, 2311);
      attr_dev(strong, "class", "conic-value");
      add_location(strong, file10, 71, 5, 2367);
      attr_dev(li, "class", li_class_value = "conic-item " + /*hover*/
      ctx[2]);
      add_location(li, file10, 68, 4, 2163);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, span0);
      append_hydration_dev(li, t0);
      append_hydration_dev(li, span1);
      append_hydration_dev(span1, t1);
      append_hydration_dev(li, t2);
      append_hydration_dev(li, strong);
      append_hydration_dev(strong, t3);
      append_hydration_dev(strong, t4);
      append_hydration_dev(li, t5);
      if (!mounted) {
        dispose = [
          listen_dev(
            li,
            "click",
            /*click_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keydown",
            /*keydown_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keyup",
            /*keyup_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            li,
            "keypress",
            /*keypress_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*generatedLegendList*/
      16) {
        set_style(
          span0,
          "background",
          /*color*/
          ctx2[26]
        );
      }
      if (dirty & /*generatedLegendList*/
      16 && t1_value !== (t1_value = /*label*/
      ctx2[27] + ""))
        set_data_dev(t1, t1_value);
      if (dirty & /*generatedLegendList*/
      16 && t3_value !== (t3_value = /*value*/
      ctx2[28] + ""))
        set_data_dev(t3, t3_value);
      if (dirty & /*hover*/
      4 && li_class_value !== (li_class_value = "conic-item " + /*hover*/
      ctx2[2])) {
        attr_dev(li, "class", li_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(66:3) {#each generatedLegendList as { color, label, value }}",
    ctx
  });
  return block;
}
function create_fragment10(ctx) {
  let figure;
  let t0;
  let t1;
  let figure_class_value;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[9].default && create_if_block_24(ctx)
  );
  let if_block1 = (
    /*cone*/
    ctx[3] && create_if_block_14(ctx)
  );
  let if_block2 = (
    /*legend*/
    ctx[0] && /*generatedLegendList*/
    ctx[4] && create_if_block8(ctx)
  );
  const block = {
    c: function create() {
      figure = element("figure");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", { class: true, "data-testid": true });
      var figure_nodes = children(figure);
      if (if_block0)
        if_block0.l(figure_nodes);
      t0 = claim_space(figure_nodes);
      if (if_block1)
        if_block1.l(figure_nodes);
      t1 = claim_space(figure_nodes);
      if (if_block2)
        if_block2.l(figure_nodes);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(figure, "class", figure_class_value = "conic-gradient " + /*classesBase*/
      ctx[8]);
      attr_dev(figure, "data-testid", "conic-gradient");
      add_location(figure, file10, 53, 0, 1554);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      if (if_block0)
        if_block0.m(figure, null);
      append_hydration_dev(figure, t0);
      if (if_block1)
        if_block1.m(figure, null);
      append_hydration_dev(figure, t1);
      if (if_block2)
        if_block2.m(figure, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[9].default
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_24(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(figure, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*cone*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_14(ctx2);
          if_block1.c();
          if_block1.m(figure, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*legend*/
        ctx2[0] && /*generatedLegendList*/
        ctx2[4]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block8(ctx2);
          if_block2.c();
          if_block2.m(figure, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & /*classesBase*/
      256 && figure_class_value !== (figure_class_value = "conic-gradient " + /*classesBase*/
      ctx2[8])) {
        attr_dev(figure, "class", figure_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(figure);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase6 = "flex flex-col items-center space-y-4 w-";
var cCaption = "text-center";
var cCone = "block aspect-square rounded-full";
var cLegend = "text-sm w-full";
var cSwatch = "block aspect-square bg-black w-5 rounded-full mr-2";
function instance10($$self, $$props, $$invalidate) {
  let classesBase;
  let classesCaption;
  let classesCone;
  let classesLegend;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ConicGradient", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { stops = [
    {
      color: ["neutral", 500],
      start: 0,
      end: 100
    }
  ] } = $$props;
  let { legend = false } = $$props;
  let { spin = false } = $$props;
  let { width = "w-24" } = $$props;
  let { hover = "bg-primary-hover-token" } = $$props;
  let { digits = 0 } = $$props;
  let { regionCaption = "" } = $$props;
  let { regionCone = "" } = $$props;
  let { regionLegend = "" } = $$props;
  let cone;
  let generatedLegendList;
  function setColorValue(color) {
    if (typeof color === "string")
      return color;
    const colorSet = tailwindDefaultColors.find((c) => c.label === color[0]);
    return colorSet == null ? void 0 : colorSet.shades[color[1]].hex;
  }
  function genConicGradient() {
    let d = stops.map((v) => `${setColorValue(v.color)} ${v.start}% ${v.end}%`);
    $$invalidate(3, cone = `conic-gradient(${d.join(", ")})`);
  }
  function genLegend() {
    if (!legend)
      return;
    $$invalidate(4, generatedLegendList = stops.map((v) => {
      return {
        label: v.label,
        color: setColorValue(v.color),
        value: (v.end - v.start).toFixed(digits)
      };
    }));
  }
  afterUpdate(() => {
    genConicGradient();
    genLegend();
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(25, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("stops" in $$new_props)
      $$invalidate(10, stops = $$new_props.stops);
    if ("legend" in $$new_props)
      $$invalidate(0, legend = $$new_props.legend);
    if ("spin" in $$new_props)
      $$invalidate(1, spin = $$new_props.spin);
    if ("width" in $$new_props)
      $$invalidate(11, width = $$new_props.width);
    if ("hover" in $$new_props)
      $$invalidate(2, hover = $$new_props.hover);
    if ("digits" in $$new_props)
      $$invalidate(12, digits = $$new_props.digits);
    if ("regionCaption" in $$new_props)
      $$invalidate(13, regionCaption = $$new_props.regionCaption);
    if ("regionCone" in $$new_props)
      $$invalidate(14, regionCone = $$new_props.regionCone);
    if ("regionLegend" in $$new_props)
      $$invalidate(15, regionLegend = $$new_props.regionLegend);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    tailwindDefaultColors,
    stops,
    legend,
    spin,
    width,
    hover,
    digits,
    regionCaption,
    regionCone,
    regionLegend,
    cone,
    generatedLegendList,
    cBase: cBase6,
    cCaption,
    cCone,
    cLegend,
    cSwatch,
    setColorValue,
    genConicGradient,
    genLegend,
    classesLegend,
    classesCone,
    classesCaption,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(25, $$props = assign(assign({}, $$props), $$new_props));
    if ("stops" in $$props)
      $$invalidate(10, stops = $$new_props.stops);
    if ("legend" in $$props)
      $$invalidate(0, legend = $$new_props.legend);
    if ("spin" in $$props)
      $$invalidate(1, spin = $$new_props.spin);
    if ("width" in $$props)
      $$invalidate(11, width = $$new_props.width);
    if ("hover" in $$props)
      $$invalidate(2, hover = $$new_props.hover);
    if ("digits" in $$props)
      $$invalidate(12, digits = $$new_props.digits);
    if ("regionCaption" in $$props)
      $$invalidate(13, regionCaption = $$new_props.regionCaption);
    if ("regionCone" in $$props)
      $$invalidate(14, regionCone = $$new_props.regionCone);
    if ("regionLegend" in $$props)
      $$invalidate(15, regionLegend = $$new_props.regionLegend);
    if ("cone" in $$props)
      $$invalidate(3, cone = $$new_props.cone);
    if ("generatedLegendList" in $$props)
      $$invalidate(4, generatedLegendList = $$new_props.generatedLegendList);
    if ("classesLegend" in $$props)
      $$invalidate(5, classesLegend = $$new_props.classesLegend);
    if ("classesCone" in $$props)
      $$invalidate(6, classesCone = $$new_props.classesCone);
    if ("classesCaption" in $$props)
      $$invalidate(7, classesCaption = $$new_props.classesCaption);
    if ("classesBase" in $$props)
      $$invalidate(8, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(8, classesBase = `${cBase6} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*regionCaption*/
    8192) {
      $:
        $$invalidate(7, classesCaption = `${cCaption} ${regionCaption}`);
    }
    if ($$self.$$.dirty & /*width, regionCone*/
    18432) {
      $:
        $$invalidate(6, classesCone = `${cCone} ${width} ${regionCone}`);
    }
    if ($$self.$$.dirty & /*regionLegend*/
    32768) {
      $:
        $$invalidate(5, classesLegend = `${cLegend} ${regionLegend}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    legend,
    spin,
    hover,
    cone,
    generatedLegendList,
    classesLegend,
    classesCone,
    classesCaption,
    classesBase,
    $$slots,
    stops,
    width,
    digits,
    regionCaption,
    regionCone,
    regionLegend,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler
  ];
}
var ConicGradient = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {
      stops: 10,
      legend: 0,
      spin: 1,
      width: 11,
      hover: 2,
      digits: 12,
      regionCaption: 13,
      regionCone: 14,
      regionLegend: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ConicGradient",
      options,
      id: create_fragment10.name
    });
  }
  get stops() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stops(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get legend() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set legend(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spin() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spin(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get digits() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set digits(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionCaption() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionCaption(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionCone() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionCone(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLegend() {
    throw new Error("<ConicGradient>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLegend(value) {
    throw new Error("<ConicGradient>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ConicGradient_default = ConicGradient;

// node_modules/@skeletonlabs/skeleton/dist/components/FileButton/FileButton.svelte
var file11 = "node_modules/@skeletonlabs/skeleton/dist/components/FileButton/FileButton.svelte";
function fallback_block3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Select a File");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Select a File");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block3.name,
    type: "fallback",
    source: "(35:8) Select a File",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let div1;
  let div0;
  let input;
  let t;
  let button_1;
  let button_1_class_value;
  let button_1_disabled_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "file" },
    { name: (
      /*name*/
      ctx[2]
    ) },
    /*prunedRestProps*/
    ctx[6]()
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block3(ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t = space();
      button_1 = element("button");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", { type: true, name: true });
      div0_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      button_1 = claim_element(div1_nodes, "BUTTON", { type: true, class: true });
      var button_1_nodes = children(button_1);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(button_1_nodes);
      button_1_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file11, 22, 2, 580);
      attr_dev(div0, "class", "w-0 h-0 overflow-hidden");
      add_location(div0, file11, 21, 1, 540);
      attr_dev(button_1, "type", "button");
      attr_dev(button_1, "class", button_1_class_value = "file-button-btn " + /*classesButton*/
      ctx[3]);
      button_1.disabled = button_1_disabled_value = /*$$restProps*/
      ctx[7].disabled;
      add_location(button_1, file11, 25, 1, 701);
      attr_dev(div1, "class", div1_class_value = "file-button " + /*classesBase*/
      ctx[4]);
      attr_dev(div1, "data-testid", "file-button");
      add_location(div1, file11, 19, 0, 397);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[16](input);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, button_1);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(button_1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[17]
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[15],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button_1,
            "click",
            /*onButtonClick*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button_1,
            "keydown",
            /*keydown_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button_1,
            "keyup",
            /*keyup_handler*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button_1,
            "keypress",
            /*keypress_handler*/
            ctx[14],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "file" },
        (!current || dirty & /*name*/
        4) && { name: (
          /*name*/
          ctx2[2]
        ) },
        /*prunedRestProps*/
        ctx2[6]()
      ]));
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesButton*/
      8 && button_1_class_value !== (button_1_class_value = "file-button-btn " + /*classesButton*/
      ctx2[3])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (!current || dirty & /*$$restProps*/
      128 && button_1_disabled_value !== (button_1_disabled_value = /*$$restProps*/
      ctx2[7].disabled)) {
        prop_dev(button_1, "disabled", button_1_disabled_value);
      }
      if (!current || dirty & /*classesBase*/
      16 && div1_class_value !== (div1_class_value = "file-button " + /*classesBase*/
      ctx2[4])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      ctx[16](null);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let classesBase;
  let classesButton;
  const omit_props_names = ["files", "fileInput", "name", "width", "button"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileButton", slots, ["default"]);
  let { files = void 0 } = $$props;
  let { fileInput = void 0 } = $$props;
  let { name } = $$props;
  let { width = "" } = $$props;
  let { button = "btn variant-filled" } = $$props;
  function onButtonClick() {
    if (fileInput)
      fileInput.click();
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<FileButton> was created without expected prop 'name'");
    }
  });
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fileInput = $$value;
      $$invalidate(1, fileInput);
    });
  }
  function input_change_handler() {
    files = this.files;
    $$invalidate(0, files);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("files" in $$new_props)
      $$invalidate(0, files = $$new_props.files);
    if ("fileInput" in $$new_props)
      $$invalidate(1, fileInput = $$new_props.fileInput);
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("width" in $$new_props)
      $$invalidate(8, width = $$new_props.width);
    if ("button" in $$new_props)
      $$invalidate(9, button = $$new_props.button);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    files,
    fileInput,
    name,
    width,
    button,
    onButtonClick,
    prunedRestProps,
    classesButton,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("files" in $$props)
      $$invalidate(0, files = $$new_props.files);
    if ("fileInput" in $$props)
      $$invalidate(1, fileInput = $$new_props.fileInput);
    if ("name" in $$props)
      $$invalidate(2, name = $$new_props.name);
    if ("width" in $$props)
      $$invalidate(8, width = $$new_props.width);
    if ("button" in $$props)
      $$invalidate(9, button = $$new_props.button);
    if ("classesButton" in $$props)
      $$invalidate(3, classesButton = $$new_props.classesButton);
    if ("classesBase" in $$props)
      $$invalidate(4, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, classesBase = `${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*button, width*/
    768) {
      $:
        $$invalidate(3, classesButton = `${button} ${width}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    files,
    fileInput,
    name,
    classesButton,
    classesBase,
    onButtonClick,
    prunedRestProps,
    $$restProps,
    width,
    button,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    change_handler,
    input_binding,
    input_change_handler
  ];
}
var FileButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      files: 0,
      fileInput: 1,
      name: 2,
      width: 8,
      button: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileButton",
      options,
      id: create_fragment11.name
    });
  }
  get files() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fileInput() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fileInput(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get button() {
    throw new Error("<FileButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set button(value) {
    throw new Error("<FileButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileButton_default = FileButton;

// node_modules/@skeletonlabs/skeleton/dist/components/FileDropzone/FileDropzone.svelte
var file12 = "node_modules/@skeletonlabs/skeleton/dist/components/FileDropzone/FileDropzone.svelte";
var get_meta_slot_changes = (dirty) => ({});
var get_meta_slot_context = (ctx) => ({});
var get_message_slot_changes = (dirty) => ({});
var get_message_slot_context = (ctx) => ({});
var get_lead_slot_changes6 = (dirty) => ({});
var get_lead_slot_context6 = (ctx) => ({});
function create_if_block_15(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[18].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_lead_slot_context6
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "dropzone-lead " + /*slotLead*/
      ctx[5]);
      add_location(div, file12, 53, 21, 1552);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty[0] & /*$$scope*/
        131072)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_lead_slot_changes6
            ),
            get_lead_slot_context6
          );
        }
      }
      if (!current || dirty[0] & /*slotLead*/
      32 && div_class_value !== (div_class_value = "dropzone-lead " + /*slotLead*/
      ctx2[5])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(54:3) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function fallback_block4(ctx) {
  let strong;
  let textContent = "Upload a file";
  let t1;
  const block = {
    c: function create() {
      strong = element("strong");
      strong.textContent = textContent;
      t1 = text(" or drag and drop");
      this.h();
    },
    l: function claim(nodes) {
      strong = claim_element(nodes, "STRONG", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(strong) !== "svelte-13uz6lq")
        strong.textContent = textContent;
      t1 = claim_text(nodes, " or drag and drop");
      this.h();
    },
    h: function hydrate() {
      add_location(strong, file12, 56, 25, 1715);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, strong, anchor);
      insert_hydration_dev(target, t1, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(strong);
        detach_dev(t1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block4.name,
    type: "fallback",
    source: "(57:25) <strong>",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let small;
  let small_class_value;
  let current;
  const meta_slot_template = (
    /*#slots*/
    ctx[18].meta
  );
  const meta_slot = create_slot(
    meta_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_meta_slot_context
  );
  const block = {
    c: function create() {
      small = element("small");
      if (meta_slot)
        meta_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      small = claim_element(nodes, "SMALL", { class: true });
      var small_nodes = children(small);
      if (meta_slot)
        meta_slot.l(small_nodes);
      small_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(small, "class", small_class_value = "dropzone-meta " + /*slotMeta*/
      ctx[7]);
      add_location(small, file12, 59, 21, 1823);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, small, anchor);
      if (meta_slot) {
        meta_slot.m(small, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (meta_slot) {
        if (meta_slot.p && (!current || dirty[0] & /*$$scope*/
        131072)) {
          update_slot_base(
            meta_slot,
            meta_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              meta_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_meta_slot_changes
            ),
            get_meta_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*slotMeta*/
      128 && small_class_value !== (small_class_value = "dropzone-meta " + /*slotMeta*/
      ctx2[7])) {
        attr_dev(small, "class", small_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(meta_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(meta_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(small);
      }
      if (meta_slot)
        meta_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(60:3) {#if $$slots.meta}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let div3;
  let input;
  let input_class_value;
  let t0;
  let div2;
  let div1;
  let t1;
  let div0;
  let div0_class_value;
  let t2;
  let div1_class_value;
  let div2_class_value;
  let div3_class_value;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "file" },
    { name: (
      /*name*/
      ctx[2]
    ) },
    {
      class: input_class_value = "dropzone-input " + /*classesInput*/
      ctx[9]
    },
    /*prunedRestProps*/
    ctx[11]()
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block0 = (
    /*$$slots*/
    ctx[13].lead && create_if_block_15(ctx)
  );
  const message_slot_template = (
    /*#slots*/
    ctx[18].message
  );
  const message_slot = create_slot(
    message_slot_template,
    ctx,
    /*$$scope*/
    ctx[17],
    get_message_slot_context
  );
  const message_slot_or_fallback = message_slot || fallback_block4(ctx);
  let if_block1 = (
    /*$$slots*/
    ctx[13].meta && create_if_block9(ctx)
  );
  const block = {
    c: function create() {
      div3 = element("div");
      input = element("input");
      t0 = space();
      div2 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      div0 = element("div");
      if (message_slot_or_fallback)
        message_slot_or_fallback.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div3_nodes = children(div3);
      input = claim_element(div3_nodes, "INPUT", { type: true, name: true, class: true });
      t0 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (message_slot_or_fallback)
        message_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file12, 29, 1, 1072);
      attr_dev(div0, "class", div0_class_value = "dropzone-message " + /*slotMessage*/
      ctx[6]);
      add_location(div0, file12, 55, 3, 1645);
      attr_dev(div1, "class", div1_class_value = "dropzone-interface-text " + /*regionInterfaceText*/
      ctx[4]);
      add_location(div1, file12, 51, 2, 1454);
      attr_dev(div2, "class", div2_class_value = "dropzone-interface " + /*classesInterface*/
      ctx[8] + " " + /*regionInterface*/
      ctx[3]);
      add_location(div2, file12, 50, 1, 1382);
      attr_dev(div3, "class", div3_class_value = "dropzone " + /*classesBase*/
      ctx[10]);
      attr_dev(div3, "data-testid", "file-dropzone");
      toggle_class(
        div3,
        "opacity-50",
        /*$$restProps*/
        ctx[12].disabled
      );
      add_location(div3, file12, 26, 0, 877);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, input);
      if (input.autofocus)
        input.focus();
      ctx[32](input);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      if (message_slot_or_fallback) {
        message_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[31]
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "dragenter",
            /*dragenter_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "dragover",
            /*dragover_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "dragleave",
            /*dragleave_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "drop",
            /*drop_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focusin",
            /*focusin_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focusout",
            /*focusout_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "file" },
        (!current || dirty[0] & /*name*/
        4) && { name: (
          /*name*/
          ctx2[2]
        ) },
        (!current || dirty[0] & /*classesInput*/
        512 && input_class_value !== (input_class_value = "dropzone-input " + /*classesInput*/
        ctx2[9])) && { class: input_class_value },
        /*prunedRestProps*/
        ctx2[11]()
      ]));
      if (
        /*$$slots*/
        ctx2[13].lead
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          8192) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_15(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (message_slot) {
        if (message_slot.p && (!current || dirty[0] & /*$$scope*/
        131072)) {
          update_slot_base(
            message_slot,
            message_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[17],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[17]
            ) : get_slot_changes(
              message_slot_template,
              /*$$scope*/
              ctx2[17],
              dirty,
              get_message_slot_changes
            ),
            get_message_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*slotMessage*/
      64 && div0_class_value !== (div0_class_value = "dropzone-message " + /*slotMessage*/
      ctx2[6])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*$$slots*/
        ctx2[13].meta
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          8192) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*regionInterfaceText*/
      16 && div1_class_value !== (div1_class_value = "dropzone-interface-text " + /*regionInterfaceText*/
      ctx2[4])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*classesInterface, regionInterface*/
      264 && div2_class_value !== (div2_class_value = "dropzone-interface " + /*classesInterface*/
      ctx2[8] + " " + /*regionInterface*/
      ctx2[3])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      1024 && div3_class_value !== (div3_class_value = "dropzone " + /*classesBase*/
      ctx2[10])) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*classesBase, $$restProps*/
      5120) {
        toggle_class(
          div3,
          "opacity-50",
          /*$$restProps*/
          ctx2[12].disabled
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(message_slot_or_fallback, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(message_slot_or_fallback, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      ctx[32](null);
      if (if_block0)
        if_block0.d();
      if (message_slot_or_fallback)
        message_slot_or_fallback.d(detaching);
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase7 = "textarea relative flex justify-center items-center";
var cInput = "w-full absolute top-0 left-0 right-0 bottom-0 z-[1] opacity-0 disabled:!opacity-0 cursor-pointer";
var cInterface2 = "flex justify-center items-center text-center";
function instance12($$self, $$props, $$invalidate) {
  let classesBase;
  let classesInput;
  let classesInterface;
  const omit_props_names = [
    "files",
    "fileInput",
    "name",
    "border",
    "padding",
    "rounded",
    "regionInterface",
    "regionInterfaceText",
    "slotLead",
    "slotMessage",
    "slotMeta"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FileDropzone", slots, ["lead", "message", "meta"]);
  const $$slots = compute_slots(slots);
  let { files = void 0 } = $$props;
  let { fileInput = void 0 } = $$props;
  let { name } = $$props;
  let { border = "border-2 border-dashed" } = $$props;
  let { padding = "p-4 py-8" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { regionInterface = "" } = $$props;
  let { regionInterfaceText = "" } = $$props;
  let { slotLead = "mb-4" } = $$props;
  let { slotMessage = "" } = $$props;
  let { slotMeta = "opacity-75" } = $$props;
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<FileDropzone> was created without expected prop 'name'");
    }
  });
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function dragenter_handler(event) {
    bubble.call(this, $$self, event);
  }
  function dragover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function dragleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function drop_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focusin_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focusout_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    files = this.files;
    $$invalidate(0, files);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      fileInput = $$value;
      $$invalidate(1, fileInput);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(33, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("files" in $$new_props)
      $$invalidate(0, files = $$new_props.files);
    if ("fileInput" in $$new_props)
      $$invalidate(1, fileInput = $$new_props.fileInput);
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("border" in $$new_props)
      $$invalidate(14, border = $$new_props.border);
    if ("padding" in $$new_props)
      $$invalidate(15, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(16, rounded = $$new_props.rounded);
    if ("regionInterface" in $$new_props)
      $$invalidate(3, regionInterface = $$new_props.regionInterface);
    if ("regionInterfaceText" in $$new_props)
      $$invalidate(4, regionInterfaceText = $$new_props.regionInterfaceText);
    if ("slotLead" in $$new_props)
      $$invalidate(5, slotLead = $$new_props.slotLead);
    if ("slotMessage" in $$new_props)
      $$invalidate(6, slotMessage = $$new_props.slotMessage);
    if ("slotMeta" in $$new_props)
      $$invalidate(7, slotMeta = $$new_props.slotMeta);
    if ("$$scope" in $$new_props)
      $$invalidate(17, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    files,
    fileInput,
    name,
    border,
    padding,
    rounded,
    regionInterface,
    regionInterfaceText,
    slotLead,
    slotMessage,
    slotMeta,
    cBase: cBase7,
    cInput,
    cInterface: cInterface2,
    prunedRestProps,
    classesInterface,
    classesInput,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(33, $$props = assign(assign({}, $$props), $$new_props));
    if ("files" in $$props)
      $$invalidate(0, files = $$new_props.files);
    if ("fileInput" in $$props)
      $$invalidate(1, fileInput = $$new_props.fileInput);
    if ("name" in $$props)
      $$invalidate(2, name = $$new_props.name);
    if ("border" in $$props)
      $$invalidate(14, border = $$new_props.border);
    if ("padding" in $$props)
      $$invalidate(15, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(16, rounded = $$new_props.rounded);
    if ("regionInterface" in $$props)
      $$invalidate(3, regionInterface = $$new_props.regionInterface);
    if ("regionInterfaceText" in $$props)
      $$invalidate(4, regionInterfaceText = $$new_props.regionInterfaceText);
    if ("slotLead" in $$props)
      $$invalidate(5, slotLead = $$new_props.slotLead);
    if ("slotMessage" in $$props)
      $$invalidate(6, slotMessage = $$new_props.slotMessage);
    if ("slotMeta" in $$props)
      $$invalidate(7, slotMeta = $$new_props.slotMeta);
    if ("classesInterface" in $$props)
      $$invalidate(8, classesInterface = $$new_props.classesInterface);
    if ("classesInput" in $$props)
      $$invalidate(9, classesInput = $$new_props.classesInput);
    if ("classesBase" in $$props)
      $$invalidate(10, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(10, classesBase = `${cBase7} ${border} ${padding} ${rounded} ${$$props.class ?? ""}`);
  };
  $:
    $$invalidate(9, classesInput = `${cInput}`);
  $:
    $$invalidate(8, classesInterface = `${cInterface2}`);
  $$props = exclude_internal_props($$props);
  return [
    files,
    fileInput,
    name,
    regionInterface,
    regionInterfaceText,
    slotLead,
    slotMessage,
    slotMeta,
    classesInterface,
    classesInput,
    classesBase,
    prunedRestProps,
    $$restProps,
    $$slots,
    border,
    padding,
    rounded,
    $$scope,
    slots,
    change_handler,
    dragenter_handler,
    dragover_handler,
    dragleave_handler,
    drop_handler,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    focus_handler,
    focusin_handler,
    focusout_handler,
    input_change_handler,
    input_binding
  ];
}
var FileDropzone = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance12,
      create_fragment12,
      safe_not_equal,
      {
        files: 0,
        fileInput: 1,
        name: 2,
        border: 14,
        padding: 15,
        rounded: 16,
        regionInterface: 3,
        regionInterfaceText: 4,
        slotLead: 5,
        slotMessage: 6,
        slotMeta: 7
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileDropzone",
      options,
      id: create_fragment12.name
    });
  }
  get files() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fileInput() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fileInput(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionInterface() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionInterface(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionInterfaceText() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionInterfaceText(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotLead() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotLead(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotMessage() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotMessage(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get slotMeta() {
    throw new Error("<FileDropzone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slotMeta(value) {
    throw new Error("<FileDropzone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FileDropzone_default = FileDropzone;

// node_modules/@skeletonlabs/skeleton/dist/components/InputChip/InputChip.svelte
var file13 = "node_modules/@skeletonlabs/skeleton/dist/components/InputChip/InputChip.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[66] = list[i].id;
  child_ctx[67] = list[i].val;
  child_ctx[69] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[70] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let option_1;
  let t_value = (
    /*option*/
    ctx[70] + ""
  );
  let t;
  let option_1_value_value;
  const block = {
    c: function create() {
      option_1 = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option_1 = claim_element(nodes, "OPTION", {});
      var option_1_nodes = children(option_1);
      t = claim_text(option_1_nodes, t_value);
      option_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option_1.__value = option_1_value_value = /*option*/
      ctx[70];
      set_input_value(option_1, option_1.__value);
      add_location(option_1, file13, 154, 26, 5236);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option_1, anchor);
      append_hydration_dev(option_1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value*/
      1 && t_value !== (t_value = /*option*/
      ctx2[70] + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*value*/
      1 && option_1_value_value !== (option_1_value_value = /*option*/
      ctx2[70])) {
        prop_dev(option_1, "__value", option_1_value_value);
        set_input_value(option_1, option_1.__value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option_1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(155:3) {#each value as option}",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_class_value;
  let div_intro;
  let div_outro;
  let current;
  let each_value = ensure_array_like_dev(
    /*chipValues*/
    ctx[16]
  );
  const get_key = (ctx2) => (
    /*id*/
    ctx2[66]
  );
  validate_each_keys(ctx, each_value, get_each_context3, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "input-chip-list " + /*classesChipList*/
      ctx[19]);
      add_location(div, file13, 175, 3, 5770);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*chips, chipTransitionOut, chipTransitionOutParams, transitions, removeChipInternally, chipValues*/
      16892064) {
        each_value = ensure_array_like_dev(
          /*chipValues*/
          ctx[16]
        );
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        validate_each_keys(ctx, each_value, get_each_context3, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, fix_and_outro_and_destroy_block, create_each_block3, null, get_each_context3);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
      if (!current || dirty[0] & /*classesChipList*/
      524288 && div_class_value !== (div_class_value = "input-chip-list " + /*classesChipList*/
      ctx[19])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(div, dynamicTransition, {
            transition: (
              /*listTransitionIn*/
              ctx[8]
            ),
            params: (
              /*listTransitionInParams*/
              ctx[9]
            ),
            enabled: (
              /*transitions*/
              ctx[7]
            )
          });
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div, dynamicTransition, {
          transition: (
            /*listTransitionOut*/
            ctx[10]
          ),
          params: (
            /*listTransitionOutParams*/
            ctx[11]
          ),
          enabled: (
            /*transitions*/
            ctx[7]
          )
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (detaching && div_outro)
        div_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(175:2) {#if chipValues.length}",
    ctx
  });
  return block;
}
function create_each_block3(key_1, ctx) {
  let div;
  let button;
  let span0;
  let t0_value = (
    /*val*/
    ctx[67] + ""
  );
  let t0;
  let t1;
  let span1;
  let textContent = "";
  let button_class_value;
  let button_intro;
  let button_outro;
  let t3;
  let rect;
  let stop_animation = noop;
  let current;
  let mounted;
  let dispose;
  function click_handler_1(...args) {
    return (
      /*click_handler_1*/
      ctx[53](
        /*i*/
        ctx[69],
        /*val*/
        ctx[67],
        ...args
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div = element("div");
      button = element("button");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      span1.textContent = textContent;
      t3 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      span0 = claim_element(button_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(button_nodes);
      span1 = claim_element(button_nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span1) !== "svelte-1p578dz")
        span1.textContent = textContent;
      button_nodes.forEach(detach_dev);
      t3 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span0, file13, 194, 7, 6662);
      add_location(span1, file13, 195, 7, 6688);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", button_class_value = "chip " + /*chips*/
      ctx[5]);
      add_location(button, file13, 183, 6, 6215);
      add_location(div, file13, 182, 5, 6175);
      this.first = div;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      append_hydration_dev(button, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, span1);
      append_hydration_dev(div, t3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", click_handler_1, false, false, false, false),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keypress",
            /*keypress_handler*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keydown",
            /*keydown_handler*/
            ctx[45],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button,
            "keyup",
            /*keyup_handler*/
            ctx[46],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*chipValues*/
      65536) && t0_value !== (t0_value = /*val*/
      ctx[67] + ""))
        set_data_dev(t0, t0_value);
      if (!current || dirty[0] & /*chips*/
      32 && button_class_value !== (button_class_value = "chip " + /*chips*/
      ctx[5])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    r: function measure() {
      rect = div.getBoundingClientRect();
    },
    f: function fix() {
      fix_position(div);
      stop_animation();
    },
    a: function animate() {
      stop_animation();
      stop_animation = create_animation(div, rect, flip, { duration: (
        /*duration*/
        ctx[3]
      ) });
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button_outro)
            button_outro.end(1);
          button_intro = create_in_transition(button, dynamicTransition, {
            transition: (
              /*chipTransitionIn*/
              ctx[12]
            ),
            params: (
              /*chipTransitionInParams*/
              ctx[13]
            ),
            enabled: (
              /*transitions*/
              ctx[7]
            )
          });
          button_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (button_intro)
        button_intro.invalidate();
      if (local) {
        button_outro = create_out_transition(button, dynamicTransition, {
          transition: (
            /*chipTransitionOut*/
            ctx[14]
          ),
          params: (
            /*chipTransitionOutParams*/
            ctx[15]
          ),
          enabled: (
            /*transitions*/
            ctx[7]
          )
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (detaching && button_outro)
        button_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(181:4) {#each chipValues as { id, val }",
    ctx
  });
  return block;
}
function create_fragment13(ctx) {
  let div2;
  let div0;
  let select;
  let t0;
  let div1;
  let form;
  let input_1;
  let input_1_placeholder_value;
  let input_1_class_value;
  let input_1_disabled_value;
  let t1;
  let div1_class_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like_dev(
    /*value*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let if_block = (
    /*chipValues*/
    ctx[16].length && create_if_block10(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      div1 = element("div");
      form = element("form");
      input_1 = element("input");
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      select = claim_element(div0_nodes, "SELECT", {
        name: true,
        "aria-label": true,
        tabindex: true
      });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      form = claim_element(div1_nodes, "FORM", {});
      var form_nodes = children(form);
      input_1 = claim_element(form_nodes, "INPUT", {
        type: true,
        placeholder: true,
        class: true
      });
      form_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        select,
        "name",
        /*name*/
        ctx[2]
      );
      select.multiple = true;
      select.required = /*required*/
      ctx[4];
      attr_dev(
        select,
        "aria-label",
        /*label*/
        ctx[6]
      );
      attr_dev(select, "tabindex", "-1");
      if (
        /*value*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[51].call(select)
        ));
      add_location(select, file13, 152, 2, 5064);
      attr_dev(div0, "class", "h-0 overflow-hidden");
      add_location(div0, file13, 151, 1, 5028);
      attr_dev(input_1, "type", "text");
      attr_dev(input_1, "placeholder", input_1_placeholder_value = /*$$restProps*/
      ctx[25].placeholder ?? "Enter values...");
      attr_dev(input_1, "class", input_1_class_value = "input-chip-field " + /*classesInput*/
      ctx[18]);
      input_1.disabled = input_1_disabled_value = /*$$restProps*/
      ctx[25].disabled;
      add_location(input_1, file13, 161, 3, 5447);
      add_location(form, file13, 160, 2, 5407);
      attr_dev(div1, "class", div1_class_value = "input-chip-wrapper " + /*classesChipWrapper*/
      ctx[20]);
      add_location(div1, file13, 158, 1, 5328);
      attr_dev(div2, "class", div2_class_value = "input-chip " + /*classesBase*/
      ctx[21]);
      toggle_class(
        div2,
        "opacity-50",
        /*$$restProps*/
        ctx[25].disabled
      );
      add_location(div2, file13, 149, 0, 4872);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      ctx[50](select);
      select_options(
        select,
        /*value*/
        ctx[0]
      );
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, form);
      append_hydration_dev(form, input_1);
      set_input_value(
        input_1,
        /*input*/
        ctx[1]
      );
      append_hydration_dev(div1, t1);
      if (if_block)
        if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[51]
          ),
          listen_dev(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[52]
          ),
          listen_dev(
            input_1,
            "input",
            /*onInputHandler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "input",
            /*input_handler*/
            ctx[47],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "focus",
            /*focus_handler*/
            ctx[48],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "blur",
            /*blur_handler*/
            ctx[49],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            form,
            "submit",
            /*addChipInternally*/
            ctx[23],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value*/
      1) {
        each_value_1 = ensure_array_like_dev(
          /*value*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (!current || dirty[0] & /*name*/
      4) {
        attr_dev(
          select,
          "name",
          /*name*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*required*/
      16) {
        prop_dev(
          select,
          "required",
          /*required*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*label*/
      64) {
        attr_dev(
          select,
          "aria-label",
          /*label*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*value*/
      1) {
        select_options(
          select,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*$$restProps*/
      33554432 && input_1_placeholder_value !== (input_1_placeholder_value = /*$$restProps*/
      ctx2[25].placeholder ?? "Enter values...")) {
        attr_dev(input_1, "placeholder", input_1_placeholder_value);
      }
      if (!current || dirty[0] & /*classesInput*/
      262144 && input_1_class_value !== (input_1_class_value = "input-chip-field " + /*classesInput*/
      ctx2[18])) {
        attr_dev(input_1, "class", input_1_class_value);
      }
      if (!current || dirty[0] & /*$$restProps*/
      33554432 && input_1_disabled_value !== (input_1_disabled_value = /*$$restProps*/
      ctx2[25].disabled)) {
        prop_dev(input_1, "disabled", input_1_disabled_value);
      }
      if (dirty[0] & /*input*/
      2 && input_1.value !== /*input*/
      ctx2[1]) {
        set_input_value(
          input_1,
          /*input*/
          ctx2[1]
        );
      }
      if (
        /*chipValues*/
        ctx2[16].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*chipValues*/
          65536) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classesChipWrapper*/
      1048576 && div1_class_value !== (div1_class_value = "input-chip-wrapper " + /*classesChipWrapper*/
      ctx2[20])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      2097152 && div2_class_value !== (div2_class_value = "input-chip " + /*classesBase*/
      ctx2[21])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*classesBase, $$restProps*/
      35651584) {
        toggle_class(
          div2,
          "opacity-50",
          /*$$restProps*/
          ctx2[25].disabled
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_each(each_blocks, detaching);
      ctx[50](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase8 = "textarea cursor-pointer";
var cChipWrapper = "space-y-4";
var cChipList = "flex flex-wrap gap-2";
var cInputField = "unstyled bg-transparent border-0 !ring-0 p-0 w-full";
function instance13($$self, $$props, $$invalidate) {
  let classesInvalid;
  let classesBase;
  let classesChipWrapper;
  let classesChipList;
  let classesInput;
  const omit_props_names = [
    "input",
    "name",
    "value",
    "whitelist",
    "max",
    "minlength",
    "maxlength",
    "allowUpperCase",
    "allowDuplicates",
    "validation",
    "duration",
    "required",
    "chips",
    "invalid",
    "padding",
    "rounded",
    "regionChipWrapper",
    "regionChipList",
    "regionInput",
    "label",
    "transitions",
    "listTransitionIn",
    "listTransitionInParams",
    "listTransitionOut",
    "listTransitionOutParams",
    "chipTransitionIn",
    "chipTransitionInParams",
    "chipTransitionOut",
    "chipTransitionOutParams",
    "addChip",
    "removeChip"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $prefersReducedMotionStore;
  validate_store(prefersReducedMotionStore, "prefersReducedMotionStore");
  component_subscribe($$self, prefersReducedMotionStore, ($$value) => $$invalidate(54, $prefersReducedMotionStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputChip", slots, []);
  const dispatch = createEventDispatcher();
  let { input = "" } = $$props;
  let { name } = $$props;
  let { value = [] } = $$props;
  let { whitelist = [] } = $$props;
  let { max = -1 } = $$props;
  let { minlength = -1 } = $$props;
  let { maxlength = -1 } = $$props;
  let { allowUpperCase = false } = $$props;
  let { allowDuplicates = false } = $$props;
  let { validation = () => true } = $$props;
  let { duration = 150 } = $$props;
  let { required = false } = $$props;
  let { chips = "variant-filled" } = $$props;
  let { invalid = "input-error" } = $$props;
  let { padding = "p-2" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { regionChipWrapper = "" } = $$props;
  let { regionChipList = "" } = $$props;
  let { regionInput = "" } = $$props;
  let { label = "Chips select" } = $$props;
  let { transitions = !$prefersReducedMotionStore } = $$props;
  let { listTransitionIn = fly } = $$props;
  let { listTransitionInParams = { duration: 150, opacity: 0, y: -20 } } = $$props;
  let { listTransitionOut = fly } = $$props;
  let { listTransitionOutParams = { duration: 150, opacity: 0, y: -20 } } = $$props;
  let { chipTransitionIn = scale } = $$props;
  let { chipTransitionInParams = { duration: 150, opacity: 0 } } = $$props;
  let { chipTransitionOut = scale } = $$props;
  let { chipTransitionOutParams = { duration: 150, opacity: 0 } } = $$props;
  let inputValid = true;
  let chipValues = (value == null ? void 0 : value.map((val) => {
    return { val, id: Math.random() };
  })) || [];
  function resetFormHandler() {
    $$invalidate(0, value = []);
  }
  let selectElement;
  onMount(() => {
    if (!selectElement.form)
      return;
    const externalForm = selectElement.form;
    externalForm.addEventListener("reset", resetFormHandler);
    return () => {
      externalForm.removeEventListener("reset", resetFormHandler);
    };
  });
  function onInputHandler() {
    $$invalidate(41, inputValid = true);
  }
  function validateCustom(chip) {
    return validation === void 0 || validation(chip);
  }
  function validateCount() {
    return max === -1 || value.length < max;
  }
  function validateLength(chip) {
    return (minlength === -1 || chip.length >= minlength) && (maxlength === -1 || chip.length <= maxlength);
  }
  function validateWhiteList(chip) {
    return whitelist.length === 0 || whitelist.includes(chip);
  }
  function validateDuplicates(chip) {
    return allowDuplicates || !value.includes(chip);
  }
  function validate(chip = "") {
    if (!chip && !input)
      return false;
    chip = chip !== "" ? chip.trim() : input.trim();
    return validateCustom(chip) && validateCount() && validateLength(chip) && validateWhiteList(chip) && validateDuplicates(chip);
  }
  function addChipCommon(chip) {
    chip = allowUpperCase ? chip : chip.toLowerCase();
    value.push(chip);
    $$invalidate(0, value);
    chipValues.push({ val: chip, id: Math.random() });
    $$invalidate(16, chipValues), $$invalidate(0, value);
  }
  function removeChipCommon(chip) {
    let chipIndex = value.indexOf(chip);
    value.splice(chipIndex, 1);
    $$invalidate(0, value);
    chipValues.splice(chipIndex, 1);
    $$invalidate(16, chipValues), $$invalidate(0, value);
  }
  function addChipInternally(event) {
    event.preventDefault();
    $$invalidate(41, inputValid = validate());
    if (inputValid === false) {
      dispatch("invalid", { event, input });
      return;
    }
    addChipCommon(input);
    dispatch("add", {
      event,
      chipIndex: value.length - 1,
      chipValue: input
    });
    $$invalidate(1, input = "");
  }
  function removeChipInternally(event, chipIndex, chipValue) {
    if ($$restProps.disabled)
      return;
    removeChipCommon(chipValue);
    dispatch("remove", { event, chipIndex, chipValue });
  }
  function addChip(chip) {
    $$invalidate(41, inputValid = validate(chip));
    if (inputValid === false) {
      dispatch("invalidManually", { input: chip });
      return;
    }
    addChipCommon(chip);
    dispatch("addManually", {
      chipIndex: value.length - 1,
      chipValue: chip
    });
  }
  function removeChip(chip) {
    if ($$restProps.disabled)
      return;
    removeChipCommon(chip);
    dispatch("removeManually", { chipValue: chip });
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<InputChip> was created without expected prop 'name'");
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      selectElement = $$value;
      $$invalidate(17, selectElement);
    });
  }
  function select_change_handler() {
    value = select_multiple_value(this);
    $$invalidate(0, value);
  }
  function input_1_input_handler() {
    input = this.value;
    $$invalidate(1, input);
  }
  const click_handler_1 = (i, val, e) => removeChipInternally(e, i, val);
  $$self.$$set = ($$new_props) => {
    $$invalidate(65, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("input" in $$new_props)
      $$invalidate(1, input = $$new_props.input);
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("whitelist" in $$new_props)
      $$invalidate(26, whitelist = $$new_props.whitelist);
    if ("max" in $$new_props)
      $$invalidate(27, max = $$new_props.max);
    if ("minlength" in $$new_props)
      $$invalidate(28, minlength = $$new_props.minlength);
    if ("maxlength" in $$new_props)
      $$invalidate(29, maxlength = $$new_props.maxlength);
    if ("allowUpperCase" in $$new_props)
      $$invalidate(30, allowUpperCase = $$new_props.allowUpperCase);
    if ("allowDuplicates" in $$new_props)
      $$invalidate(31, allowDuplicates = $$new_props.allowDuplicates);
    if ("validation" in $$new_props)
      $$invalidate(32, validation = $$new_props.validation);
    if ("duration" in $$new_props)
      $$invalidate(3, duration = $$new_props.duration);
    if ("required" in $$new_props)
      $$invalidate(4, required = $$new_props.required);
    if ("chips" in $$new_props)
      $$invalidate(5, chips = $$new_props.chips);
    if ("invalid" in $$new_props)
      $$invalidate(33, invalid = $$new_props.invalid);
    if ("padding" in $$new_props)
      $$invalidate(34, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(35, rounded = $$new_props.rounded);
    if ("regionChipWrapper" in $$new_props)
      $$invalidate(36, regionChipWrapper = $$new_props.regionChipWrapper);
    if ("regionChipList" in $$new_props)
      $$invalidate(37, regionChipList = $$new_props.regionChipList);
    if ("regionInput" in $$new_props)
      $$invalidate(38, regionInput = $$new_props.regionInput);
    if ("label" in $$new_props)
      $$invalidate(6, label = $$new_props.label);
    if ("transitions" in $$new_props)
      $$invalidate(7, transitions = $$new_props.transitions);
    if ("listTransitionIn" in $$new_props)
      $$invalidate(8, listTransitionIn = $$new_props.listTransitionIn);
    if ("listTransitionInParams" in $$new_props)
      $$invalidate(9, listTransitionInParams = $$new_props.listTransitionInParams);
    if ("listTransitionOut" in $$new_props)
      $$invalidate(10, listTransitionOut = $$new_props.listTransitionOut);
    if ("listTransitionOutParams" in $$new_props)
      $$invalidate(11, listTransitionOutParams = $$new_props.listTransitionOutParams);
    if ("chipTransitionIn" in $$new_props)
      $$invalidate(12, chipTransitionIn = $$new_props.chipTransitionIn);
    if ("chipTransitionInParams" in $$new_props)
      $$invalidate(13, chipTransitionInParams = $$new_props.chipTransitionInParams);
    if ("chipTransitionOut" in $$new_props)
      $$invalidate(14, chipTransitionOut = $$new_props.chipTransitionOut);
    if ("chipTransitionOutParams" in $$new_props)
      $$invalidate(15, chipTransitionOutParams = $$new_props.chipTransitionOutParams);
  };
  $$self.$capture_state = () => ({
    fly,
    scale,
    prefersReducedMotionStore,
    dynamicTransition,
    createEventDispatcher,
    onMount,
    flip,
    dispatch,
    input,
    name,
    value,
    whitelist,
    max,
    minlength,
    maxlength,
    allowUpperCase,
    allowDuplicates,
    validation,
    duration,
    required,
    chips,
    invalid,
    padding,
    rounded,
    regionChipWrapper,
    regionChipList,
    regionInput,
    label,
    transitions,
    listTransitionIn,
    listTransitionInParams,
    listTransitionOut,
    listTransitionOutParams,
    chipTransitionIn,
    chipTransitionInParams,
    chipTransitionOut,
    chipTransitionOutParams,
    cBase: cBase8,
    cChipWrapper,
    cChipList,
    cInputField,
    inputValid,
    chipValues,
    resetFormHandler,
    selectElement,
    onInputHandler,
    validateCustom,
    validateCount,
    validateLength,
    validateWhiteList,
    validateDuplicates,
    validate,
    addChipCommon,
    removeChipCommon,
    addChipInternally,
    removeChipInternally,
    addChip,
    removeChip,
    classesInput,
    classesChipList,
    classesChipWrapper,
    classesInvalid,
    classesBase,
    $prefersReducedMotionStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(65, $$props = assign(assign({}, $$props), $$new_props));
    if ("input" in $$props)
      $$invalidate(1, input = $$new_props.input);
    if ("name" in $$props)
      $$invalidate(2, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("whitelist" in $$props)
      $$invalidate(26, whitelist = $$new_props.whitelist);
    if ("max" in $$props)
      $$invalidate(27, max = $$new_props.max);
    if ("minlength" in $$props)
      $$invalidate(28, minlength = $$new_props.minlength);
    if ("maxlength" in $$props)
      $$invalidate(29, maxlength = $$new_props.maxlength);
    if ("allowUpperCase" in $$props)
      $$invalidate(30, allowUpperCase = $$new_props.allowUpperCase);
    if ("allowDuplicates" in $$props)
      $$invalidate(31, allowDuplicates = $$new_props.allowDuplicates);
    if ("validation" in $$props)
      $$invalidate(32, validation = $$new_props.validation);
    if ("duration" in $$props)
      $$invalidate(3, duration = $$new_props.duration);
    if ("required" in $$props)
      $$invalidate(4, required = $$new_props.required);
    if ("chips" in $$props)
      $$invalidate(5, chips = $$new_props.chips);
    if ("invalid" in $$props)
      $$invalidate(33, invalid = $$new_props.invalid);
    if ("padding" in $$props)
      $$invalidate(34, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(35, rounded = $$new_props.rounded);
    if ("regionChipWrapper" in $$props)
      $$invalidate(36, regionChipWrapper = $$new_props.regionChipWrapper);
    if ("regionChipList" in $$props)
      $$invalidate(37, regionChipList = $$new_props.regionChipList);
    if ("regionInput" in $$props)
      $$invalidate(38, regionInput = $$new_props.regionInput);
    if ("label" in $$props)
      $$invalidate(6, label = $$new_props.label);
    if ("transitions" in $$props)
      $$invalidate(7, transitions = $$new_props.transitions);
    if ("listTransitionIn" in $$props)
      $$invalidate(8, listTransitionIn = $$new_props.listTransitionIn);
    if ("listTransitionInParams" in $$props)
      $$invalidate(9, listTransitionInParams = $$new_props.listTransitionInParams);
    if ("listTransitionOut" in $$props)
      $$invalidate(10, listTransitionOut = $$new_props.listTransitionOut);
    if ("listTransitionOutParams" in $$props)
      $$invalidate(11, listTransitionOutParams = $$new_props.listTransitionOutParams);
    if ("chipTransitionIn" in $$props)
      $$invalidate(12, chipTransitionIn = $$new_props.chipTransitionIn);
    if ("chipTransitionInParams" in $$props)
      $$invalidate(13, chipTransitionInParams = $$new_props.chipTransitionInParams);
    if ("chipTransitionOut" in $$props)
      $$invalidate(14, chipTransitionOut = $$new_props.chipTransitionOut);
    if ("chipTransitionOutParams" in $$props)
      $$invalidate(15, chipTransitionOutParams = $$new_props.chipTransitionOutParams);
    if ("inputValid" in $$props)
      $$invalidate(41, inputValid = $$new_props.inputValid);
    if ("chipValues" in $$props)
      $$invalidate(16, chipValues = $$new_props.chipValues);
    if ("selectElement" in $$props)
      $$invalidate(17, selectElement = $$new_props.selectElement);
    if ("classesInput" in $$props)
      $$invalidate(18, classesInput = $$new_props.classesInput);
    if ("classesChipList" in $$props)
      $$invalidate(19, classesChipList = $$new_props.classesChipList);
    if ("classesChipWrapper" in $$props)
      $$invalidate(20, classesChipWrapper = $$new_props.classesChipWrapper);
    if ("classesInvalid" in $$props)
      $$invalidate(42, classesInvalid = $$new_props.classesInvalid);
    if ("classesBase" in $$props)
      $$invalidate(21, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*inputValid, invalid*/
    1028) {
      $:
        $$invalidate(42, classesInvalid = inputValid === false ? invalid : "");
    }
    $:
      $$invalidate(21, classesBase = `${cBase8} ${padding} ${rounded} ${$$props.class ?? ""} ${classesInvalid}`);
    if ($$self.$$.dirty[1] & /*regionChipWrapper*/
    32) {
      $:
        $$invalidate(20, classesChipWrapper = `${cChipWrapper} ${regionChipWrapper}`);
    }
    if ($$self.$$.dirty[1] & /*regionChipList*/
    64) {
      $:
        $$invalidate(19, classesChipList = `${cChipList} ${regionChipList}`);
    }
    if ($$self.$$.dirty[1] & /*regionInput*/
    128) {
      $:
        $$invalidate(18, classesInput = `${cInputField} ${regionInput}`);
    }
    if ($$self.$$.dirty[0] & /*value, chipValues*/
    65537) {
      $:
        $$invalidate(16, chipValues = (value == null ? void 0 : value.map((val, i) => {
          var _a;
          if (((_a = chipValues[i]) == null ? void 0 : _a.val) === val)
            return chipValues[i];
          return { id: Math.random(), val };
        })) || []);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    input,
    name,
    duration,
    required,
    chips,
    label,
    transitions,
    listTransitionIn,
    listTransitionInParams,
    listTransitionOut,
    listTransitionOutParams,
    chipTransitionIn,
    chipTransitionInParams,
    chipTransitionOut,
    chipTransitionOutParams,
    chipValues,
    selectElement,
    classesInput,
    classesChipList,
    classesChipWrapper,
    classesBase,
    onInputHandler,
    addChipInternally,
    removeChipInternally,
    $$restProps,
    whitelist,
    max,
    minlength,
    maxlength,
    allowUpperCase,
    allowDuplicates,
    validation,
    invalid,
    padding,
    rounded,
    regionChipWrapper,
    regionChipList,
    regionInput,
    addChip,
    removeChip,
    inputValid,
    classesInvalid,
    click_handler,
    keypress_handler,
    keydown_handler,
    keyup_handler,
    input_handler,
    focus_handler,
    blur_handler,
    select_binding,
    select_change_handler,
    input_1_input_handler,
    click_handler_1
  ];
}
var InputChip = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance13,
      create_fragment13,
      safe_not_equal,
      {
        input: 1,
        name: 2,
        value: 0,
        whitelist: 26,
        max: 27,
        minlength: 28,
        maxlength: 29,
        allowUpperCase: 30,
        allowDuplicates: 31,
        validation: 32,
        duration: 3,
        required: 4,
        chips: 5,
        invalid: 33,
        padding: 34,
        rounded: 35,
        regionChipWrapper: 36,
        regionChipList: 37,
        regionInput: 38,
        label: 6,
        transitions: 7,
        listTransitionIn: 8,
        listTransitionInParams: 9,
        listTransitionOut: 10,
        listTransitionOutParams: 11,
        chipTransitionIn: 12,
        chipTransitionInParams: 13,
        chipTransitionOut: 14,
        chipTransitionOutParams: 15,
        addChip: 39,
        removeChip: 40
      },
      null,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputChip",
      options,
      id: create_fragment13.name
    });
  }
  get input() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get whitelist() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set whitelist(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minlength() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minlength(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxlength() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxlength(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowUpperCase() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowUpperCase(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowDuplicates() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowDuplicates(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validation() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validation(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chips() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chips(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionChipWrapper() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionChipWrapper(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionChipList() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionChipList(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionInput() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionInput(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitions() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitions(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listTransitionIn() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listTransitionIn(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listTransitionInParams() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listTransitionInParams(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listTransitionOut() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listTransitionOut(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get listTransitionOutParams() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set listTransitionOutParams(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chipTransitionIn() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chipTransitionIn(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chipTransitionInParams() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chipTransitionInParams(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chipTransitionOut() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chipTransitionOut(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chipTransitionOutParams() {
    throw new Error("<InputChip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chipTransitionOutParams(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addChip() {
    return this.$$.ctx[39];
  }
  set addChip(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeChip() {
    return this.$$.ctx[40];
  }
  set removeChip(value) {
    throw new Error("<InputChip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputChip_default = InputChip;

// node_modules/@skeletonlabs/skeleton/dist/components/ListBox/ListBox.svelte
var file14 = "node_modules/@skeletonlabs/skeleton/dist/components/ListBox/ListBox.svelte";
function create_fragment14(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-labelledby": true,
        "data-testid": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "listbox " + /*classesBase*/
      ctx[1]);
      attr_dev(div, "role", "listbox");
      attr_dev(
        div,
        "aria-labelledby",
        /*labelledby*/
        ctx[0]
      );
      attr_dev(div, "data-testid", "listbox");
      add_location(div, file14, 24, 0, 758);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesBase*/
      2 && div_class_value !== (div_class_value = "listbox " + /*classesBase*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*labelledby*/
      1) {
        attr_dev(
          div,
          "aria-labelledby",
          /*labelledby*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase9 = "";
function instance14($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBox", slots, ["default"]);
  let { multiple = false } = $$props;
  let { spacing = "space-y-1" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { active = "variant-filled" } = $$props;
  let { hover = "hover:variant-soft" } = $$props;
  let { padding = "px-4 py-2" } = $$props;
  let { regionLead = "" } = $$props;
  let { regionDefault = "" } = $$props;
  let { regionTrail = "" } = $$props;
  let { labelledby = "" } = $$props;
  setContext("multiple", multiple);
  setContext("rounded", rounded);
  setContext("active", active);
  setContext("hover", hover);
  setContext("padding", padding);
  setContext("regionLead", regionLead);
  setContext("regionDefault", regionDefault);
  setContext("regionTrail", regionTrail);
  $$self.$$set = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("multiple" in $$new_props)
      $$invalidate(2, multiple = $$new_props.multiple);
    if ("spacing" in $$new_props)
      $$invalidate(3, spacing = $$new_props.spacing);
    if ("rounded" in $$new_props)
      $$invalidate(4, rounded = $$new_props.rounded);
    if ("active" in $$new_props)
      $$invalidate(5, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(6, hover = $$new_props.hover);
    if ("padding" in $$new_props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("regionLead" in $$new_props)
      $$invalidate(8, regionLead = $$new_props.regionLead);
    if ("regionDefault" in $$new_props)
      $$invalidate(9, regionDefault = $$new_props.regionDefault);
    if ("regionTrail" in $$new_props)
      $$invalidate(10, regionTrail = $$new_props.regionTrail);
    if ("labelledby" in $$new_props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    multiple,
    spacing,
    rounded,
    active,
    hover,
    padding,
    regionLead,
    regionDefault,
    regionTrail,
    labelledby,
    cBase: cBase9,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    if ("multiple" in $$props)
      $$invalidate(2, multiple = $$new_props.multiple);
    if ("spacing" in $$props)
      $$invalidate(3, spacing = $$new_props.spacing);
    if ("rounded" in $$props)
      $$invalidate(4, rounded = $$new_props.rounded);
    if ("active" in $$props)
      $$invalidate(5, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(6, hover = $$new_props.hover);
    if ("padding" in $$props)
      $$invalidate(7, padding = $$new_props.padding);
    if ("regionLead" in $$props)
      $$invalidate(8, regionLead = $$new_props.regionLead);
    if ("regionDefault" in $$props)
      $$invalidate(9, regionDefault = $$new_props.regionDefault);
    if ("regionTrail" in $$props)
      $$invalidate(10, regionTrail = $$new_props.regionTrail);
    if ("labelledby" in $$props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("classesBase" in $$props)
      $$invalidate(1, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classesBase = `${cBase9} ${spacing} ${rounded} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    labelledby,
    classesBase,
    multiple,
    spacing,
    rounded,
    active,
    hover,
    padding,
    regionLead,
    regionDefault,
    regionTrail,
    $$scope,
    slots
  ];
}
var ListBox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      multiple: 2,
      spacing: 3,
      rounded: 4,
      active: 5,
      hover: 6,
      padding: 7,
      regionLead: 8,
      regionDefault: 9,
      regionTrail: 10,
      labelledby: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBox",
      options,
      id: create_fragment14.name
    });
  }
  get multiple() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLead() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLead(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionDefault() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionDefault(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionTrail() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionTrail(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<ListBox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<ListBox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBox_default = ListBox;

// node_modules/@skeletonlabs/skeleton/dist/components/ListBox/ListBoxItem.svelte
var file15 = "node_modules/@skeletonlabs/skeleton/dist/components/ListBox/ListBoxItem.svelte";
var get_trail_slot_changes3 = (dirty) => ({});
var get_trail_slot_context3 = (ctx) => ({});
var get_lead_slot_changes7 = (dirty) => ({});
var get_lead_slot_context7 = (ctx) => ({});
function create_else_block4(ctx) {
  let input;
  let value_has_changed = false;
  let binding_group;
  let mounted;
  let dispose;
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[35][0]
  );
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, name: true, tabindex: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "radio");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[1]
      );
      input.__value = /*value*/
      ctx[2];
      set_input_value(input, input.__value);
      attr_dev(input, "tabindex", "-1");
      add_location(input, file15, 99, 4, 2718);
      binding_group.p(input);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      ctx[33](input);
      input.checked = input.__value === /*group*/
      ctx[0];
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler_1*/
            ctx[34]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler_1*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler_1*/
            ctx[30],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*name*/
      2) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      if (dirty[0] & /*value*/
      4) {
        prop_dev(
          input,
          "__value",
          /*value*/
          ctx2[2]
        );
        set_input_value(input, input.__value);
        value_has_changed = true;
      }
      if (value_has_changed || dirty[0] & /*group*/
      1) {
        input.checked = input.__value === /*group*/
        ctx2[0];
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[33](null);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block4.name,
    type: "else",
    source: "(99:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_25(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, name: true, tabindex: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "checkbox");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[1]
      );
      input.__value = /*value*/
      ctx[2];
      set_input_value(input, input.__value);
      attr_dev(input, "tabindex", "-1");
      add_location(input, file15, 97, 4, 2594);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      ctx[31](input);
      input.checked = /*checked*/
      ctx[4];
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[32]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*name*/
      2) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      if (dirty[0] & /*value*/
      4) {
        prop_dev(
          input,
          "__value",
          /*value*/
          ctx2[2]
        );
        set_input_value(input, input.__value);
      }
      if (dirty[0] & /*checked*/
      16) {
        input.checked = /*checked*/
        ctx2[4];
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      ctx[31](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_25.name,
    type: "if",
    source: "(97:3) {#if multiple}",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let div;
  let div_class_value;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[23].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    get_lead_slot_context7
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "listbox-label-lead " + /*classesRegionLead*/
      ctx[9]);
      add_location(div, file15, 105, 21, 2949);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty[0] & /*$$scope*/
        4194304)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              get_lead_slot_changes7
            ),
            get_lead_slot_context7
          );
        }
      }
      if (!current || dirty[0] & /*classesRegionLead*/
      512 && div_class_value !== (div_class_value = "listbox-label-lead " + /*classesRegionLead*/
      ctx2[9])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(106:3) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let div;
  let div_class_value;
  let current;
  const trail_slot_template = (
    /*#slots*/
    ctx[23].trail
  );
  const trail_slot = create_slot(
    trail_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    get_trail_slot_context3
  );
  const block = {
    c: function create() {
      div = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (trail_slot)
        trail_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "listbox-label-trail " + /*classesRegionTrail*/
      ctx[7]);
      add_location(div, file15, 109, 22, 3181);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (trail_slot) {
        trail_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty[0] & /*$$scope*/
        4194304)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              trail_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              get_trail_slot_changes3
            ),
            get_trail_slot_context3
          );
        }
      }
      if (!current || dirty[0] & /*classesRegionTrail*/
      128 && div_class_value !== (div_class_value = "listbox-label-trail " + /*classesRegionTrail*/
      ctx2[7])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(110:3) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let label;
  let div3;
  let div0;
  let t0;
  let div2;
  let t1;
  let div1;
  let div1_class_value;
  let t2;
  let div2_class_value;
  let div3_class_value;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*multiple*/
      ctx2[3]
    )
      return create_if_block_25;
    return create_else_block4;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*$$slots*/
    ctx[13].lead && create_if_block_16(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  let if_block2 = (
    /*$$slots*/
    ctx[13].trail && create_if_block11(ctx)
  );
  const block = {
    c: function create() {
      label = element("label");
      div3 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      div2 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", {});
      var label_nodes = children(label);
      div3 = claim_element(label_nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-selected": true,
        tabindex: true
      });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block0.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block1)
        if_block1.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      if (if_block2)
        if_block2.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "h-0 w-0 overflow-hidden");
      add_location(div0, file15, 95, 2, 2534);
      attr_dev(div1, "class", div1_class_value = "listbox-label-content " + /*classesRegionDefault*/
      ctx[8]);
      add_location(div1, file15, 107, 3, 3062);
      attr_dev(div2, "class", div2_class_value = "listbox-label " + /*classesLabel*/
      ctx[10]);
      add_location(div2, file15, 103, 2, 2862);
      attr_dev(div3, "class", div3_class_value = "listbox-item " + /*classesBase*/
      ctx[11]);
      attr_dev(div3, "data-testid", "listbox-item");
      attr_dev(div3, "role", "option");
      attr_dev(
        div3,
        "aria-selected",
        /*selected*/
        ctx[5]
      );
      attr_dev(div3, "tabindex", "0");
      add_location(div3, file15, 83, 1, 2260);
      add_location(label, file15, 81, 0, 2198);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, div3);
      append_hydration_dev(div3, div0);
      if_block0.m(div0, null);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div2);
      if (if_block1)
        if_block1.m(div2, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div3,
            "keydown",
            /*onKeyDown*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            /*keydown_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keyup",
            /*keyup_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keypress",
            /*keypress_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if (
        /*$$slots*/
        ctx2[13].lead
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          8192) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_16(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classesRegionDefault*/
      256 && div1_class_value !== (div1_class_value = "listbox-label-content " + /*classesRegionDefault*/
      ctx2[8])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (
        /*$$slots*/
        ctx2[13].trail
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          8192) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block11(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classesLabel*/
      1024 && div2_class_value !== (div2_class_value = "listbox-label " + /*classesLabel*/
      ctx2[10])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      2048 && div3_class_value !== (div3_class_value = "listbox-item " + /*classesBase*/
      ctx2[11])) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*selected*/
      32) {
        attr_dev(
          div3,
          "aria-selected",
          /*selected*/
          ctx2[5]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      transition_in(default_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      transition_out(default_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase10 = "cursor-pointer -outline-offset-[3px]";
var cLabel3 = "flex items-center space-x-4";
var cRegionLead2 = "";
var cRegionDefault2 = "flex-1";
var cRegionTrail2 = "";
function areDeeplyEqual(param1, param2) {
  if (param1 === param2)
    return true;
  if (!(param1 instanceof Object) || !(param2 instanceof Object))
    return false;
  const keys1 = Object.keys(param1);
  const keys2 = Object.keys(param2);
  if (keys1.length !== keys2.length)
    return false;
  for (const key of keys1) {
    const value1 = param1[key];
    const value2 = param2[key];
    if (!areDeeplyEqual(value1, value2))
      return false;
  }
  return true;
}
function instance15($$self, $$props, $$invalidate) {
  let selected;
  let classesActive;
  let classesBase;
  let classesLabel;
  let classesRegionLead;
  let classesRegionDefault;
  let classesRegionTrail;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ListBoxItem", slots, ["lead", "default", "trail"]);
  const $$slots = compute_slots(slots);
  let { group } = $$props;
  let { name } = $$props;
  let { value } = $$props;
  let { multiple = getContext("multiple") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { active = getContext("active") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { regionLead = getContext("regionLead") } = $$props;
  let { regionDefault = getContext("regionDefault") } = $$props;
  let { regionTrail = getContext("regionTrail") } = $$props;
  let checked;
  let elemInput;
  function updateCheckbox(group2) {
    $$invalidate(4, checked = group2.indexOf(value) >= 0);
  }
  function updateGroup(checked2) {
    const index = group.indexOf(value);
    if (checked2) {
      if (index < 0) {
        group.push(value);
        $$invalidate(0, group);
      }
    } else {
      if (index >= 0) {
        group.splice(index, 1);
        $$invalidate(0, group);
      }
    }
  }
  function onKeyDown2(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      elemInput.click();
    }
  }
  $$self.$$.on_mount.push(function() {
    if (group === void 0 && !("group" in $$props || $$self.$$.bound[$$self.$$.props["group"]])) {
      console.warn("<ListBoxItem> was created without expected prop 'group'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<ListBoxItem> was created without expected prop 'name'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<ListBoxItem> was created without expected prop 'value'");
    }
  });
  const $$binding_groups = [[]];
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemInput = $$value;
      $$invalidate(6, elemInput);
    });
  }
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(4, checked);
  }
  function input_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemInput = $$value;
      $$invalidate(6, elemInput);
    });
  }
  function input_change_handler_1() {
    group = this.__value;
    $$invalidate(0, group);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(38, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("group" in $$new_props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("multiple" in $$new_props)
      $$invalidate(3, multiple = $$new_props.multiple);
    if ("rounded" in $$new_props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("active" in $$new_props)
      $$invalidate(15, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(16, hover = $$new_props.hover);
    if ("padding" in $$new_props)
      $$invalidate(17, padding = $$new_props.padding);
    if ("regionLead" in $$new_props)
      $$invalidate(18, regionLead = $$new_props.regionLead);
    if ("regionDefault" in $$new_props)
      $$invalidate(19, regionDefault = $$new_props.regionDefault);
    if ("regionTrail" in $$new_props)
      $$invalidate(20, regionTrail = $$new_props.regionTrail);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    group,
    name,
    value,
    multiple,
    rounded,
    active,
    hover,
    padding,
    regionLead,
    regionDefault,
    regionTrail,
    cBase: cBase10,
    cLabel: cLabel3,
    checked,
    elemInput,
    areDeeplyEqual,
    updateCheckbox,
    updateGroup,
    onKeyDown: onKeyDown2,
    cRegionLead: cRegionLead2,
    cRegionDefault: cRegionDefault2,
    cRegionTrail: cRegionTrail2,
    classesRegionTrail,
    classesRegionDefault,
    classesRegionLead,
    classesLabel,
    classesActive,
    classesBase,
    selected
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(38, $$props = assign(assign({}, $$props), $$new_props));
    if ("group" in $$props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("multiple" in $$props)
      $$invalidate(3, multiple = $$new_props.multiple);
    if ("rounded" in $$props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("active" in $$props)
      $$invalidate(15, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(16, hover = $$new_props.hover);
    if ("padding" in $$props)
      $$invalidate(17, padding = $$new_props.padding);
    if ("regionLead" in $$props)
      $$invalidate(18, regionLead = $$new_props.regionLead);
    if ("regionDefault" in $$props)
      $$invalidate(19, regionDefault = $$new_props.regionDefault);
    if ("regionTrail" in $$props)
      $$invalidate(20, regionTrail = $$new_props.regionTrail);
    if ("checked" in $$props)
      $$invalidate(4, checked = $$new_props.checked);
    if ("elemInput" in $$props)
      $$invalidate(6, elemInput = $$new_props.elemInput);
    if ("classesRegionTrail" in $$props)
      $$invalidate(7, classesRegionTrail = $$new_props.classesRegionTrail);
    if ("classesRegionDefault" in $$props)
      $$invalidate(8, classesRegionDefault = $$new_props.classesRegionDefault);
    if ("classesRegionLead" in $$props)
      $$invalidate(9, classesRegionLead = $$new_props.classesRegionLead);
    if ("classesLabel" in $$props)
      $$invalidate(10, classesLabel = $$new_props.classesLabel);
    if ("classesActive" in $$props)
      $$invalidate(21, classesActive = $$new_props.classesActive);
    if ("classesBase" in $$props)
      $$invalidate(11, classesBase = $$new_props.classesBase);
    if ("selected" in $$props)
      $$invalidate(5, selected = $$new_props.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*multiple, group*/
    9) {
      $:
        if (multiple)
          updateCheckbox(group);
    }
    if ($$self.$$.dirty[0] & /*multiple, checked*/
    24) {
      $:
        if (multiple)
          updateGroup(checked);
    }
    if ($$self.$$.dirty[0] & /*multiple, group, value*/
    13) {
      $:
        $$invalidate(5, selected = multiple ? group.some((groupVal) => areDeeplyEqual(value, groupVal)) : areDeeplyEqual(group, value));
    }
    if ($$self.$$.dirty[0] & /*selected, active, hover*/
    98336) {
      $:
        $$invalidate(21, classesActive = selected ? active : hover);
    }
    $:
      $$invalidate(11, classesBase = `${cBase10} ${rounded} ${padding} ${classesActive} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*regionLead*/
    262144) {
      $:
        $$invalidate(9, classesRegionLead = `${cRegionLead2} ${regionLead}`);
    }
    if ($$self.$$.dirty[0] & /*regionDefault*/
    524288) {
      $:
        $$invalidate(8, classesRegionDefault = `${cRegionDefault2} ${regionDefault}`);
    }
    if ($$self.$$.dirty[0] & /*regionTrail*/
    1048576) {
      $:
        $$invalidate(7, classesRegionTrail = `${cRegionTrail2} ${regionTrail}`);
    }
  };
  $:
    $$invalidate(10, classesLabel = `${cLabel3}`);
  $$props = exclude_internal_props($$props);
  return [
    group,
    name,
    value,
    multiple,
    checked,
    selected,
    elemInput,
    classesRegionTrail,
    classesRegionDefault,
    classesRegionLead,
    classesLabel,
    classesBase,
    onKeyDown2,
    $$slots,
    rounded,
    active,
    hover,
    padding,
    regionLead,
    regionDefault,
    regionTrail,
    classesActive,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    click_handler,
    change_handler,
    click_handler_1,
    change_handler_1,
    input_binding,
    input_change_handler,
    input_binding_1,
    input_change_handler_1,
    $$binding_groups
  ];
}
var ListBoxItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance15,
      create_fragment15,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        multiple: 3,
        rounded: 14,
        active: 15,
        hover: 16,
        padding: 17,
        regionLead: 18,
        regionDefault: 19,
        regionTrail: 20
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ListBoxItem",
      options,
      id: create_fragment15.name
    });
  }
  get group() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLead() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLead(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionDefault() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionDefault(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionTrail() {
    throw new Error("<ListBoxItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionTrail(value) {
    throw new Error("<ListBoxItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ListBoxItem_default = ListBoxItem;

// node_modules/@skeletonlabs/skeleton/dist/components/Paginator/icons.js
var leftArrow = `<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg>`;
var rightArrow = `<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z"/></svg>`;
var leftAngles = `<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160zm352-160l-160 160c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L301.3 256 438.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0z"/></svg>`;
var rightAngles = `<svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M470.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 256 265.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160zm-352 160l160-160c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L210.7 256 73.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"/></svg>`;

// node_modules/@skeletonlabs/skeleton/dist/components/Paginator/Paginator.svelte
var file16 = "node_modules/@skeletonlabs/skeleton/dist/components/Paginator/Paginator.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[43] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[46] = list[i];
  return child_ctx;
}
function create_if_block_52(ctx) {
  let label;
  let select_1;
  let select_1_class_value;
  let label_class_value;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like_dev(
    /*settings*/
    ctx[0].amounts
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      label = element("label");
      select_1 = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true });
      var label_nodes = children(label);
      select_1 = claim_element(label_nodes, "SELECT", { class: true, "aria-label": true });
      var select_1_nodes = children(select_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_1_nodes);
      }
      select_1_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(select_1, "class", select_1_class_value = "paginator-select " + /*classesSelect*/
      ctx[19]);
      select_1.disabled = /*disabled*/
      ctx[1];
      attr_dev(select_1, "aria-label", "Select Amount");
      if (
        /*settings*/
        ctx[0].limit === void 0
      )
        add_render_callback(() => (
          /*select_1_change_handler*/
          ctx[32].call(select_1)
        ));
      add_location(select_1, file16, 103, 3, 3427);
      attr_dev(label, "class", label_class_value = "paginator-label " + /*classesLabel*/
      ctx[20]);
      add_location(label, file16, 102, 2, 3377);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, select_1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select_1, null);
        }
      }
      select_option(
        select_1,
        /*settings*/
        ctx[0].limit,
        true
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            select_1,
            "change",
            /*select_1_change_handler*/
            ctx[32]
          ),
          listen_dev(
            select_1,
            "change",
            /*onChangeLength*/
            ctx[23],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*settings, amountText*/
      33) {
        each_value_1 = ensure_array_like_dev(
          /*settings*/
          ctx2[0].amounts
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select_1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty[0] & /*classesSelect*/
      524288 && select_1_class_value !== (select_1_class_value = "paginator-select " + /*classesSelect*/
      ctx2[19])) {
        attr_dev(select_1, "class", select_1_class_value);
      }
      if (dirty[0] & /*disabled*/
      2) {
        prop_dev(
          select_1,
          "disabled",
          /*disabled*/
          ctx2[1]
        );
      }
      if (dirty[0] & /*settings*/
      1) {
        select_option(
          select_1,
          /*settings*/
          ctx2[0].limit
        );
      }
      if (dirty[0] & /*classesLabel*/
      1048576 && label_class_value !== (label_class_value = "paginator-label " + /*classesLabel*/
      ctx2[20])) {
        attr_dev(label, "class", label_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_52.name,
    type: "if",
    source: "(102:1) {#if settings.amounts.length}",
    ctx
  });
  return block;
}
function create_each_block_12(ctx) {
  let option;
  let t0_value = (
    /*amount*/
    ctx[46] + ""
  );
  let t0;
  let t1;
  let t2;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(
        /*amountText*/
        ctx[5]
      );
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t0 = claim_text(option_nodes, t0_value);
      t1 = claim_space(option_nodes);
      t2 = claim_text(
        option_nodes,
        /*amountText*/
        ctx[5]
      );
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*amount*/
      ctx[46];
      set_input_value(option, option.__value);
      add_location(option, file16, 110, 38, 3632);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t0);
      append_hydration_dev(option, t1);
      append_hydration_dev(option, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*settings*/
      1 && t0_value !== (t0_value = /*amount*/
      ctx2[46] + ""))
        set_data_dev(t0, t0_value);
      if (dirty[0] & /*amountText*/
      32)
        set_data_dev(
          t2,
          /*amountText*/
          ctx2[5]
        );
      if (dirty[0] & /*settings*/
      1 && option_value_value !== (option_value_value = /*amount*/
      ctx2[46])) {
        prop_dev(option, "__value", option_value_value);
        set_input_value(option, option.__value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(111:4) {#each settings.amounts as amount}",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let button;
  let html_tag;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      html_tag = claim_html_tag(button_nodes, false);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-label",
        /*labelFirst*/
        ctx[12]
      );
      attr_dev(
        button,
        "class",
        /*buttonClasses*/
        ctx[6]
      );
      button.disabled = button_disabled_value = /*disabled*/
      ctx[1] || /*settings*/
      ctx[0].page === 0;
      add_location(button, file16, 118, 3, 3852);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      html_tag.m(
        /*buttonTextFirst*/
        ctx[9],
        button
      );
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[33],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextFirst*/
      512)
        html_tag.p(
          /*buttonTextFirst*/
          ctx2[9]
        );
      if (dirty[0] & /*labelFirst*/
      4096) {
        attr_dev(
          button,
          "aria-label",
          /*labelFirst*/
          ctx2[12]
        );
      }
      if (dirty[0] & /*buttonClasses*/
      64) {
        attr_dev(
          button,
          "class",
          /*buttonClasses*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*disabled, settings*/
      3 && button_disabled_value !== (button_disabled_value = /*disabled*/
      ctx2[1] || /*settings*/
      ctx2[0].page === 0)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(118:2) {#if showFirstLastButtons}",
    ctx
  });
  return block;
}
function create_if_block_33(ctx) {
  let button;
  let html_tag;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      html_tag = claim_html_tag(button_nodes, false);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-label",
        /*labelPrevious*/
        ctx[13]
      );
      attr_dev(
        button,
        "class",
        /*buttonClasses*/
        ctx[6]
      );
      button.disabled = button_disabled_value = /*disabled*/
      ctx[1] || /*settings*/
      ctx[0].page === 0;
      add_location(button, file16, 132, 3, 4139);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      html_tag.m(
        /*buttonTextPrevious*/
        ctx[7],
        button
      );
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[34],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextPrevious*/
      128)
        html_tag.p(
          /*buttonTextPrevious*/
          ctx2[7]
        );
      if (dirty[0] & /*labelPrevious*/
      8192) {
        attr_dev(
          button,
          "aria-label",
          /*labelPrevious*/
          ctx2[13]
        );
      }
      if (dirty[0] & /*buttonClasses*/
      64) {
        attr_dev(
          button,
          "class",
          /*buttonClasses*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*disabled, settings*/
      3 && button_disabled_value !== (button_disabled_value = /*disabled*/
      ctx2[1] || /*settings*/
      ctx2[0].page === 0)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_33.name,
    type: "if",
    source: "(132:2) {#if showPreviousNextButtons}",
    ctx
  });
  return block;
}
function create_else_block5(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like_dev(
    /*controlPages*/
    ctx[17]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*disabled, buttonClasses, classesButtonActive, controlPages, gotoPage*/
      21102658) {
        each_value = ensure_array_like_dev(
          /*controlPages*/
          ctx2[17]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block5.name,
    type: "else",
    source: "(153:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_26(ctx) {
  let button;
  let t0_value = (
    /*settings*/
    ctx[0].page * /*settings*/
    ctx[0].limit + 1 + ""
  );
  let t0;
  let t1;
  let t2_value = Math.min(
    /*settings*/
    ctx[0].page * /*settings*/
    ctx[0].limit + /*settings*/
    ctx[0].limit,
    /*settings*/
    ctx[0].size
  ) + "";
  let t2;
  let t3;
  let span;
  let t4;
  let t5;
  let t6_value = (
    /*settings*/
    ctx[0].size + ""
  );
  let t6;
  let button_class_value;
  const block = {
    c: function create() {
      button = element("button");
      t0 = text(t0_value);
      t1 = text("-");
      t2 = text(t2_value);
      t3 = text("");
      span = element("span");
      t4 = text(
        /*separatorText*/
        ctx[11]
      );
      t5 = space();
      t6 = text(t6_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t0 = claim_text(button_nodes, t0_value);
      t1 = claim_text(button_nodes, "-");
      t2 = claim_text(button_nodes, t2_value);
      t3 = claim_text(button_nodes, "");
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t4 = claim_text(
        span_nodes,
        /*separatorText*/
        ctx[11]
      );
      t5 = claim_space(span_nodes);
      t6 = claim_text(span_nodes, t6_value);
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "opacity-50");
      add_location(span, file16, 148, 121, 4658);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", button_class_value = /*buttonClasses*/
      ctx[6] + " pointer-events-none !text-sm");
      add_location(button, file16, 147, 3, 4461);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, t2);
      append_hydration_dev(button, t3);
      append_hydration_dev(button, span);
      append_hydration_dev(span, t4);
      append_hydration_dev(span, t5);
      append_hydration_dev(span, t6);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*settings*/
      1 && t0_value !== (t0_value = /*settings*/
      ctx2[0].page * /*settings*/
      ctx2[0].limit + 1 + ""))
        set_data_dev(t0, t0_value);
      if (dirty[0] & /*settings*/
      1 && t2_value !== (t2_value = Math.min(
        /*settings*/
        ctx2[0].page * /*settings*/
        ctx2[0].limit + /*settings*/
        ctx2[0].limit,
        /*settings*/
        ctx2[0].size
      ) + ""))
        set_data_dev(t2, t2_value);
      if (dirty[0] & /*separatorText*/
      2048)
        set_data_dev(
          t4,
          /*separatorText*/
          ctx2[11]
        );
      if (dirty[0] & /*settings*/
      1 && t6_value !== (t6_value = /*settings*/
      ctx2[0].size + ""))
        set_data_dev(t6, t6_value);
      if (dirty[0] & /*buttonClasses*/
      64 && button_class_value !== (button_class_value = /*buttonClasses*/
      ctx2[6] + " pointer-events-none !text-sm")) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_26.name,
    type: "if",
    source: "(146:2) {#if showNumerals === false}",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let button;
  let t0_value = (
    /*page*/
    (ctx[43] >= 0 ? (
      /*page*/
      ctx[43] + 1
    ) : "...") + ""
  );
  let t0;
  let t1;
  let button_class_value;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[35](
        /*page*/
        ctx[43]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t0 = claim_text(button_nodes, t0_value);
      t1 = claim_space(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      button.disabled = /*disabled*/
      ctx[1];
      attr_dev(button, "class", button_class_value = /*buttonClasses*/
      ctx[6] + " " + /*classesButtonActive*/
      ctx[22](
        /*page*/
        ctx[43]
      ));
      add_location(button, file16, 155, 4, 4815);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler_2, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*controlPages*/
      131072 && t0_value !== (t0_value = /*page*/
      (ctx[43] >= 0 ? (
        /*page*/
        ctx[43] + 1
      ) : "...") + ""))
        set_data_dev(t0, t0_value);
      if (dirty[0] & /*disabled*/
      2) {
        prop_dev(
          button,
          "disabled",
          /*disabled*/
          ctx[1]
        );
      }
      if (dirty[0] & /*buttonClasses, classesButtonActive, controlPages*/
      4325440 && button_class_value !== (button_class_value = /*buttonClasses*/
      ctx[6] + " " + /*classesButtonActive*/
      ctx[22](
        /*page*/
        ctx[43]
      ))) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(155:3) {#each controlPages as page}",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let button;
  let html_tag;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      html_tag = claim_html_tag(button_nodes, false);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-label",
        /*labelNext*/
        ctx[14]
      );
      attr_dev(
        button,
        "class",
        /*buttonClasses*/
        ctx[6]
      );
      button.disabled = button_disabled_value = /*disabled*/
      ctx[1] || /*settings*/
      (ctx[0].page + 1) * /*settings*/
      ctx[0].limit >= /*settings*/
      ctx[0].size;
      add_location(button, file16, 162, 3, 5061);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      html_tag.m(
        /*buttonTextNext*/
        ctx[8],
        button
      );
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_3*/
          ctx[36],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextNext*/
      256)
        html_tag.p(
          /*buttonTextNext*/
          ctx2[8]
        );
      if (dirty[0] & /*labelNext*/
      16384) {
        attr_dev(
          button,
          "aria-label",
          /*labelNext*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*buttonClasses*/
      64) {
        attr_dev(
          button,
          "class",
          /*buttonClasses*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*disabled, settings*/
      3 && button_disabled_value !== (button_disabled_value = /*disabled*/
      ctx2[1] || /*settings*/
      (ctx2[0].page + 1) * /*settings*/
      ctx2[0].limit >= /*settings*/
      ctx2[0].size)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(162:2) {#if showPreviousNextButtons}",
    ctx
  });
  return block;
}
function create_if_block12(ctx) {
  let button;
  let html_tag;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      html_tag = claim_html_tag(button_nodes, false);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(button, "type", "button");
      attr_dev(
        button,
        "aria-label",
        /*labelLast*/
        ctx[15]
      );
      attr_dev(
        button,
        "class",
        /*buttonClasses*/
        ctx[6]
      );
      button.disabled = button_disabled_value = /*disabled*/
      ctx[1] || /*settings*/
      (ctx[0].page + 1) * /*settings*/
      ctx[0].limit >= /*settings*/
      ctx[0].size;
      add_location(button, file16, 176, 3, 5393);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      html_tag.m(
        /*buttonTextLast*/
        ctx[10],
        button
      );
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_4*/
          ctx[37],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextLast*/
      1024)
        html_tag.p(
          /*buttonTextLast*/
          ctx2[10]
        );
      if (dirty[0] & /*labelLast*/
      32768) {
        attr_dev(
          button,
          "aria-label",
          /*labelLast*/
          ctx2[15]
        );
      }
      if (dirty[0] & /*buttonClasses*/
      64) {
        attr_dev(
          button,
          "class",
          /*buttonClasses*/
          ctx2[6]
        );
      }
      if (dirty[0] & /*disabled, settings*/
      3 && button_disabled_value !== (button_disabled_value = /*disabled*/
      ctx2[1] || /*settings*/
      (ctx2[0].page + 1) * /*settings*/
      ctx2[0].limit >= /*settings*/
      ctx2[0].size)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block12.name,
    type: "if",
    source: "(176:2) {#if showFirstLastButtons}",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let t2;
  let t3;
  let t4;
  let div0_class_value;
  let div1_class_value;
  let if_block0 = (
    /*settings*/
    ctx[0].amounts.length && create_if_block_52(ctx)
  );
  let if_block1 = (
    /*showFirstLastButtons*/
    ctx[3] && create_if_block_42(ctx)
  );
  let if_block2 = (
    /*showPreviousNextButtons*/
    ctx[2] && create_if_block_33(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*showNumerals*/
      ctx2[4] === false
    )
      return create_if_block_26;
    return create_else_block5;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block3 = current_block_type(ctx);
  let if_block4 = (
    /*showPreviousNextButtons*/
    ctx[2] && create_if_block_17(ctx)
  );
  let if_block5 = (
    /*showFirstLastButtons*/
    ctx[3] && create_if_block12(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if_block3.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      if (if_block4)
        if_block4.l(div0_nodes);
      t4 = claim_space(div0_nodes);
      if (if_block5)
        if_block5.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "paginator-controls " + /*classesControls*/
      ctx[18]);
      add_location(div0, file16, 115, 1, 3744);
      attr_dev(div1, "class", div1_class_value = "paginator " + /*classesBase*/
      ctx[21]);
      attr_dev(div1, "data-testid", "paginator");
      add_location(div1, file16, 99, 0, 3258);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration_dev(div0, t2);
      if_block3.m(div0, null);
      append_hydration_dev(div0, t3);
      if (if_block4)
        if_block4.m(div0, null);
      append_hydration_dev(div0, t4);
      if (if_block5)
        if_block5.m(div0, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*settings*/
        ctx2[0].amounts.length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_52(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*showFirstLastButtons*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_42(ctx2);
          if_block1.c();
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*showPreviousNextButtons*/
        ctx2[2]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_33(ctx2);
          if_block2.c();
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block3) {
        if_block3.p(ctx2, dirty);
      } else {
        if_block3.d(1);
        if_block3 = current_block_type(ctx2);
        if (if_block3) {
          if_block3.c();
          if_block3.m(div0, t3);
        }
      }
      if (
        /*showPreviousNextButtons*/
        ctx2[2]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_17(ctx2);
          if_block4.c();
          if_block4.m(div0, t4);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*showFirstLastButtons*/
        ctx2[3]
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block12(ctx2);
          if_block5.c();
          if_block5.m(div0, null);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if (dirty[0] & /*classesControls*/
      262144 && div0_class_value !== (div0_class_value = "paginator-controls " + /*classesControls*/
      ctx2[18])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty[0] & /*classesBase*/
      2097152 && div1_class_value !== (div1_class_value = "paginator " + /*classesBase*/
      ctx2[21])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase11 = "flex flex-col md:flex-row items-center space-y-4 md:space-y-0 md:space-x-4";
var cLabel4 = "w-full md:w-auto";
function instance16($$self, $$props, $$invalidate) {
  let classesButtonActive;
  let classesBase;
  let classesLabel;
  let classesSelect;
  let classesControls;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Paginator", slots, []);
  const dispatch = createEventDispatcher();
  let { settings = {
    page: 0,
    limit: 5,
    size: 0,
    amounts: [1, 2, 5, 10]
  } } = $$props;
  let { disabled = false } = $$props;
  let { showPreviousNextButtons = true } = $$props;
  let { showFirstLastButtons = false } = $$props;
  let { showNumerals = false } = $$props;
  let { maxNumerals = 1 } = $$props;
  let { justify = "justify-between" } = $$props;
  let { select = "select min-w-[150px]" } = $$props;
  let { amountText = "Items" } = $$props;
  let { regionControl = "btn-group" } = $$props;
  let { controlVariant = "variant-filled" } = $$props;
  let { controlSeparator = "" } = $$props;
  let { active = "variant-filled-primary" } = $$props;
  let { buttonClasses = "!px-3 !py-1.5 fill-current" } = $$props;
  let { buttonTextPrevious = leftArrow } = $$props;
  let { buttonTextNext = rightArrow } = $$props;
  let { buttonTextFirst = leftAngles } = $$props;
  let { buttonTextLast = rightAngles } = $$props;
  let { separatorText = "of" } = $$props;
  let { labelFirst = "First page" } = $$props;
  let { labelPrevious = "Previous page" } = $$props;
  let { labelNext = "Next page" } = $$props;
  let { labelLast = "Last page" } = $$props;
  let lastPage = Math.max(0, Math.ceil(settings.size / settings.limit - 1));
  let controlPages = getNumerals();
  function onChangeLength() {
    dispatch("amount", settings.limit);
    $$invalidate(16, lastPage = Math.max(0, Math.ceil(settings.size / settings.limit - 1)));
    if (settings.page > lastPage) {
      $$invalidate(0, settings.page = lastPage, settings);
    }
    $$invalidate(17, controlPages = getNumerals());
  }
  function gotoPage(page) {
    if (page < 0)
      return;
    $$invalidate(0, settings.page = page, settings);
    dispatch("page", settings.page);
    $$invalidate(17, controlPages = getNumerals());
  }
  function getFullNumerals() {
    const pages = [];
    for (let index = 0; index <= lastPage; index++) {
      pages.push(index);
    }
    return pages;
  }
  function getNumerals() {
    const pages = [];
    const isWithinLeftSection = settings.page < maxNumerals + 2;
    const isWithinRightSection = settings.page > lastPage - (maxNumerals + 2);
    if (lastPage <= maxNumerals * 2 + 1)
      return getFullNumerals();
    pages.push(0);
    if (!isWithinLeftSection)
      pages.push(-1);
    if (isWithinLeftSection || isWithinRightSection) {
      const sectionStart = isWithinLeftSection ? 1 : lastPage - (maxNumerals + 2);
      const sectionEnd = isWithinRightSection ? lastPage - 1 : maxNumerals + 2;
      for (let i = sectionStart; i <= sectionEnd; i++) {
        pages.push(i);
      }
    } else {
      for (let i = settings.page - maxNumerals; i <= settings.page + maxNumerals; i++) {
        pages.push(i);
      }
    }
    if (!isWithinRightSection)
      pages.push(-1);
    pages.push(lastPage);
    return pages;
  }
  function updateSize(size) {
    $$invalidate(16, lastPage = Math.max(0, Math.ceil(size / settings.limit - 1)));
    $$invalidate(17, controlPages = getNumerals());
  }
  function select_1_change_handler() {
    settings.limit = select_value(this);
    $$invalidate(0, settings);
  }
  const click_handler = () => {
    gotoPage(0);
  };
  const click_handler_1 = () => {
    gotoPage(settings.page - 1);
  };
  const click_handler_2 = (page) => gotoPage(page);
  const click_handler_3 = () => {
    gotoPage(settings.page + 1);
  };
  const click_handler_4 = () => {
    gotoPage(lastPage);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(42, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("settings" in $$new_props)
      $$invalidate(0, settings = $$new_props.settings);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("showPreviousNextButtons" in $$new_props)
      $$invalidate(2, showPreviousNextButtons = $$new_props.showPreviousNextButtons);
    if ("showFirstLastButtons" in $$new_props)
      $$invalidate(3, showFirstLastButtons = $$new_props.showFirstLastButtons);
    if ("showNumerals" in $$new_props)
      $$invalidate(4, showNumerals = $$new_props.showNumerals);
    if ("maxNumerals" in $$new_props)
      $$invalidate(25, maxNumerals = $$new_props.maxNumerals);
    if ("justify" in $$new_props)
      $$invalidate(26, justify = $$new_props.justify);
    if ("select" in $$new_props)
      $$invalidate(27, select = $$new_props.select);
    if ("amountText" in $$new_props)
      $$invalidate(5, amountText = $$new_props.amountText);
    if ("regionControl" in $$new_props)
      $$invalidate(28, regionControl = $$new_props.regionControl);
    if ("controlVariant" in $$new_props)
      $$invalidate(29, controlVariant = $$new_props.controlVariant);
    if ("controlSeparator" in $$new_props)
      $$invalidate(30, controlSeparator = $$new_props.controlSeparator);
    if ("active" in $$new_props)
      $$invalidate(31, active = $$new_props.active);
    if ("buttonClasses" in $$new_props)
      $$invalidate(6, buttonClasses = $$new_props.buttonClasses);
    if ("buttonTextPrevious" in $$new_props)
      $$invalidate(7, buttonTextPrevious = $$new_props.buttonTextPrevious);
    if ("buttonTextNext" in $$new_props)
      $$invalidate(8, buttonTextNext = $$new_props.buttonTextNext);
    if ("buttonTextFirst" in $$new_props)
      $$invalidate(9, buttonTextFirst = $$new_props.buttonTextFirst);
    if ("buttonTextLast" in $$new_props)
      $$invalidate(10, buttonTextLast = $$new_props.buttonTextLast);
    if ("separatorText" in $$new_props)
      $$invalidate(11, separatorText = $$new_props.separatorText);
    if ("labelFirst" in $$new_props)
      $$invalidate(12, labelFirst = $$new_props.labelFirst);
    if ("labelPrevious" in $$new_props)
      $$invalidate(13, labelPrevious = $$new_props.labelPrevious);
    if ("labelNext" in $$new_props)
      $$invalidate(14, labelNext = $$new_props.labelNext);
    if ("labelLast" in $$new_props)
      $$invalidate(15, labelLast = $$new_props.labelLast);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    leftAngles,
    leftArrow,
    rightAngles,
    rightArrow,
    dispatch,
    settings,
    disabled,
    showPreviousNextButtons,
    showFirstLastButtons,
    showNumerals,
    maxNumerals,
    justify,
    select,
    amountText,
    regionControl,
    controlVariant,
    controlSeparator,
    active,
    buttonClasses,
    buttonTextPrevious,
    buttonTextNext,
    buttonTextFirst,
    buttonTextLast,
    separatorText,
    labelFirst,
    labelPrevious,
    labelNext,
    labelLast,
    cBase: cBase11,
    cLabel: cLabel4,
    lastPage,
    controlPages,
    onChangeLength,
    gotoPage,
    getFullNumerals,
    getNumerals,
    updateSize,
    classesControls,
    classesSelect,
    classesLabel,
    classesBase,
    classesButtonActive
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(42, $$props = assign(assign({}, $$props), $$new_props));
    if ("settings" in $$props)
      $$invalidate(0, settings = $$new_props.settings);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("showPreviousNextButtons" in $$props)
      $$invalidate(2, showPreviousNextButtons = $$new_props.showPreviousNextButtons);
    if ("showFirstLastButtons" in $$props)
      $$invalidate(3, showFirstLastButtons = $$new_props.showFirstLastButtons);
    if ("showNumerals" in $$props)
      $$invalidate(4, showNumerals = $$new_props.showNumerals);
    if ("maxNumerals" in $$props)
      $$invalidate(25, maxNumerals = $$new_props.maxNumerals);
    if ("justify" in $$props)
      $$invalidate(26, justify = $$new_props.justify);
    if ("select" in $$props)
      $$invalidate(27, select = $$new_props.select);
    if ("amountText" in $$props)
      $$invalidate(5, amountText = $$new_props.amountText);
    if ("regionControl" in $$props)
      $$invalidate(28, regionControl = $$new_props.regionControl);
    if ("controlVariant" in $$props)
      $$invalidate(29, controlVariant = $$new_props.controlVariant);
    if ("controlSeparator" in $$props)
      $$invalidate(30, controlSeparator = $$new_props.controlSeparator);
    if ("active" in $$props)
      $$invalidate(31, active = $$new_props.active);
    if ("buttonClasses" in $$props)
      $$invalidate(6, buttonClasses = $$new_props.buttonClasses);
    if ("buttonTextPrevious" in $$props)
      $$invalidate(7, buttonTextPrevious = $$new_props.buttonTextPrevious);
    if ("buttonTextNext" in $$props)
      $$invalidate(8, buttonTextNext = $$new_props.buttonTextNext);
    if ("buttonTextFirst" in $$props)
      $$invalidate(9, buttonTextFirst = $$new_props.buttonTextFirst);
    if ("buttonTextLast" in $$props)
      $$invalidate(10, buttonTextLast = $$new_props.buttonTextLast);
    if ("separatorText" in $$props)
      $$invalidate(11, separatorText = $$new_props.separatorText);
    if ("labelFirst" in $$props)
      $$invalidate(12, labelFirst = $$new_props.labelFirst);
    if ("labelPrevious" in $$props)
      $$invalidate(13, labelPrevious = $$new_props.labelPrevious);
    if ("labelNext" in $$props)
      $$invalidate(14, labelNext = $$new_props.labelNext);
    if ("labelLast" in $$props)
      $$invalidate(15, labelLast = $$new_props.labelLast);
    if ("lastPage" in $$props)
      $$invalidate(16, lastPage = $$new_props.lastPage);
    if ("controlPages" in $$props)
      $$invalidate(17, controlPages = $$new_props.controlPages);
    if ("classesControls" in $$props)
      $$invalidate(18, classesControls = $$new_props.classesControls);
    if ("classesSelect" in $$props)
      $$invalidate(19, classesSelect = $$new_props.classesSelect);
    if ("classesLabel" in $$props)
      $$invalidate(20, classesLabel = $$new_props.classesLabel);
    if ("classesBase" in $$props)
      $$invalidate(21, classesBase = $$new_props.classesBase);
    if ("classesButtonActive" in $$props)
      $$invalidate(22, classesButtonActive = $$new_props.classesButtonActive);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*settings*/
    1 | $$self.$$.dirty[1] & /*active*/
    1) {
      $:
        $$invalidate(22, classesButtonActive = (page) => {
          return page === settings.page ? `${active} pointer-events-none` : "";
        });
    }
    if ($$self.$$.dirty[0] & /*maxNumerals*/
    33554432) {
      $:
        maxNumerals, onChangeLength();
    }
    if ($$self.$$.dirty[0] & /*settings*/
    1) {
      $:
        updateSize(settings.size);
    }
    $:
      $$invalidate(21, classesBase = `${cBase11} ${justify} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*select*/
    134217728) {
      $:
        $$invalidate(19, classesSelect = `${select}`);
    }
    if ($$self.$$.dirty[0] & /*regionControl, controlVariant, controlSeparator*/
    1879048192) {
      $:
        $$invalidate(18, classesControls = `${regionControl} ${controlVariant} ${controlSeparator}`);
    }
  };
  $:
    $$invalidate(20, classesLabel = `${cLabel4}`);
  $$props = exclude_internal_props($$props);
  return [
    settings,
    disabled,
    showPreviousNextButtons,
    showFirstLastButtons,
    showNumerals,
    amountText,
    buttonClasses,
    buttonTextPrevious,
    buttonTextNext,
    buttonTextFirst,
    buttonTextLast,
    separatorText,
    labelFirst,
    labelPrevious,
    labelNext,
    labelLast,
    lastPage,
    controlPages,
    classesControls,
    classesSelect,
    classesLabel,
    classesBase,
    classesButtonActive,
    onChangeLength,
    gotoPage,
    maxNumerals,
    justify,
    select,
    regionControl,
    controlVariant,
    controlSeparator,
    active,
    select_1_change_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4
  ];
}
var Paginator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance16,
      create_fragment16,
      safe_not_equal,
      {
        settings: 0,
        disabled: 1,
        showPreviousNextButtons: 2,
        showFirstLastButtons: 3,
        showNumerals: 4,
        maxNumerals: 25,
        justify: 26,
        select: 27,
        amountText: 5,
        regionControl: 28,
        controlVariant: 29,
        controlSeparator: 30,
        active: 31,
        buttonClasses: 6,
        buttonTextPrevious: 7,
        buttonTextNext: 8,
        buttonTextFirst: 9,
        buttonTextLast: 10,
        separatorText: 11,
        labelFirst: 12,
        labelPrevious: 13,
        labelNext: 14,
        labelLast: 15
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Paginator",
      options,
      id: create_fragment16.name
    });
  }
  get settings() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set settings(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showPreviousNextButtons() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showPreviousNextButtons(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showFirstLastButtons() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showFirstLastButtons(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showNumerals() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showNumerals(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxNumerals() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxNumerals(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get select() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set select(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get amountText() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set amountText(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionControl() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionControl(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controlVariant() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controlVariant(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controlSeparator() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controlSeparator(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonClasses() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonClasses(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextPrevious() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextPrevious(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextNext() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextNext(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextFirst() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextFirst(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextLast() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextLast(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get separatorText() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set separatorText(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelFirst() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelFirst(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelPrevious() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelPrevious(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelNext() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelNext(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelLast() {
    throw new Error("<Paginator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelLast(value) {
    throw new Error("<Paginator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Paginator_default = Paginator;

// node_modules/@skeletonlabs/skeleton/dist/components/ProgressBar/ProgressBar.svelte
var file17 = "node_modules/@skeletonlabs/skeleton/dist/components/ProgressBar/ProgressBar.svelte";
function add_css(target) {
  append_styles(target, "svelte-12wvf64", ".anim-indeterminate.svelte-12wvf64{transform-origin:0% 50%;animation:svelte-12wvf64-anim-indeterminate 2s infinite linear}@keyframes svelte-12wvf64-anim-indeterminate{0%{transform:translateX(0) scaleX(0)}40%{transform:translateX(0) scaleX(0.4)}100%{transform:translateX(100%) scaleX(0.5)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvZ3Jlc3NCYXIuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiL2hvbWUvbWluZy9XZWJzdG9ybVByb2plY3RzL1RyeUNvcHlGaXgvbm9kZV9tb2R1bGVzL0Bza2VsZXRvbmxhYnMvc2tlbGV0b24vZGlzdC9jb21wb25lbnRzL1Byb2dyZXNzQmFyL1Byb2dyZXNzQmFyLnN2ZWx0ZSJdfQ== */");
}
function create_fragment17(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let style_width = `${/*indeterminate*/
  ctx[4] ? 100 : (
    /*fillPercent*/
    ctx[7]
  )}%`;
  let div1_class_value;
  let div1_aria_valuemax_value;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-labelledby": true,
        "aria-valuenow": true,
        "aria-valuemin": true,
        "aria-valuemax": true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "progress-bar-meter " + /*classesMeter*/
      ctx[5] + " svelte-12wvf64");
      set_style(div0, "width", style_width);
      add_location(div0, file17, 35, 1, 1027);
      attr_dev(div1, "class", div1_class_value = "progress-bar " + /*classesTrack*/
      ctx[6] + " svelte-12wvf64");
      attr_dev(div1, "data-testid", "progress-bar");
      attr_dev(div1, "role", "progressbar");
      attr_dev(
        div1,
        "aria-labelledby",
        /*labelledby*/
        ctx[3]
      );
      attr_dev(
        div1,
        "aria-valuenow",
        /*value*/
        ctx[0]
      );
      attr_dev(
        div1,
        "aria-valuemin",
        /*min*/
        ctx[1]
      );
      attr_dev(div1, "aria-valuemax", div1_aria_valuemax_value = /*max*/
      ctx[2] - /*min*/
      ctx[1]);
      add_location(div1, file17, 25, 0, 817);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*classesMeter*/
      32 && div0_class_value !== (div0_class_value = "progress-bar-meter " + /*classesMeter*/
      ctx2[5] + " svelte-12wvf64")) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & /*indeterminate, fillPercent*/
      144 && style_width !== (style_width = `${/*indeterminate*/
      ctx2[4] ? 100 : (
        /*fillPercent*/
        ctx2[7]
      )}%`)) {
        set_style(div0, "width", style_width);
      }
      if (dirty & /*classesTrack*/
      64 && div1_class_value !== (div1_class_value = "progress-bar " + /*classesTrack*/
      ctx2[6] + " svelte-12wvf64")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (dirty & /*labelledby*/
      8) {
        attr_dev(
          div1,
          "aria-labelledby",
          /*labelledby*/
          ctx2[3]
        );
      }
      if (dirty & /*value*/
      1) {
        attr_dev(
          div1,
          "aria-valuenow",
          /*value*/
          ctx2[0]
        );
      }
      if (dirty & /*min*/
      2) {
        attr_dev(
          div1,
          "aria-valuemin",
          /*min*/
          ctx2[1]
        );
      }
      if (dirty & /*max, min*/
      6 && div1_aria_valuemax_value !== (div1_aria_valuemax_value = /*max*/
      ctx2[2] - /*min*/
      ctx2[1])) {
        attr_dev(div1, "aria-valuemax", div1_aria_valuemax_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cTrack = "w-full overflow-hidden";
var cMeter = "h-full";
function instance17($$self, $$props, $$invalidate) {
  let fillPercent;
  let indeterminate;
  let classesIndeterminate;
  let classesTrack;
  let classesMeter;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressBar", slots, []);
  let { value = void 0 } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { height = "h-2" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { transition = "transition-[width]" } = $$props;
  let { animIndeterminate = "anim-indeterminate" } = $$props;
  let { meter = "bg-surface-900-50-token" } = $$props;
  let { track = "bg-surface-200-700-token" } = $$props;
  let { labelledby = "" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(1, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(2, max = $$new_props.max);
    if ("height" in $$new_props)
      $$invalidate(8, height = $$new_props.height);
    if ("rounded" in $$new_props)
      $$invalidate(9, rounded = $$new_props.rounded);
    if ("transition" in $$new_props)
      $$invalidate(10, transition = $$new_props.transition);
    if ("animIndeterminate" in $$new_props)
      $$invalidate(11, animIndeterminate = $$new_props.animIndeterminate);
    if ("meter" in $$new_props)
      $$invalidate(12, meter = $$new_props.meter);
    if ("track" in $$new_props)
      $$invalidate(13, track = $$new_props.track);
    if ("labelledby" in $$new_props)
      $$invalidate(3, labelledby = $$new_props.labelledby);
  };
  $$self.$capture_state = () => ({
    value,
    min,
    max,
    height,
    rounded,
    transition,
    animIndeterminate,
    meter,
    track,
    labelledby,
    cTrack,
    cMeter,
    classesIndeterminate,
    classesMeter,
    classesTrack,
    indeterminate,
    fillPercent
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$props)
      $$invalidate(1, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(2, max = $$new_props.max);
    if ("height" in $$props)
      $$invalidate(8, height = $$new_props.height);
    if ("rounded" in $$props)
      $$invalidate(9, rounded = $$new_props.rounded);
    if ("transition" in $$props)
      $$invalidate(10, transition = $$new_props.transition);
    if ("animIndeterminate" in $$props)
      $$invalidate(11, animIndeterminate = $$new_props.animIndeterminate);
    if ("meter" in $$props)
      $$invalidate(12, meter = $$new_props.meter);
    if ("track" in $$props)
      $$invalidate(13, track = $$new_props.track);
    if ("labelledby" in $$props)
      $$invalidate(3, labelledby = $$new_props.labelledby);
    if ("classesIndeterminate" in $$props)
      $$invalidate(14, classesIndeterminate = $$new_props.classesIndeterminate);
    if ("classesMeter" in $$props)
      $$invalidate(5, classesMeter = $$new_props.classesMeter);
    if ("classesTrack" in $$props)
      $$invalidate(6, classesTrack = $$new_props.classesTrack);
    if ("indeterminate" in $$props)
      $$invalidate(4, indeterminate = $$new_props.indeterminate);
    if ("fillPercent" in $$props)
      $$invalidate(7, fillPercent = $$new_props.fillPercent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value, min, max*/
    7) {
      $:
        $$invalidate(7, fillPercent = value ? 100 * (value - min) / (max - min) : 0);
    }
    if ($$self.$$.dirty & /*value*/
    1) {
      $:
        $$invalidate(4, indeterminate = value === void 0 || value < 0);
    }
    if ($$self.$$.dirty & /*indeterminate, animIndeterminate*/
    2064) {
      $:
        $$invalidate(14, classesIndeterminate = indeterminate ? animIndeterminate : "");
    }
    $:
      $$invalidate(6, classesTrack = `${cTrack} ${track} ${height} ${rounded} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*meter, rounded, classesIndeterminate, transition*/
    22016) {
      $:
        $$invalidate(5, classesMeter = `${cMeter} ${meter} ${rounded} ${classesIndeterminate} ${transition}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    min,
    max,
    labelledby,
    indeterminate,
    classesMeter,
    classesTrack,
    fillPercent,
    height,
    rounded,
    transition,
    animIndeterminate,
    meter,
    track,
    classesIndeterminate
  ];
}
var ProgressBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance17,
      create_fragment17,
      safe_not_equal,
      {
        value: 0,
        min: 1,
        max: 2,
        height: 8,
        rounded: 9,
        transition: 10,
        animIndeterminate: 11,
        meter: 12,
        track: 13,
        labelledby: 3
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressBar",
      options,
      id: create_fragment17.name
    });
  }
  get value() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animIndeterminate() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animIndeterminate(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get meter() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set meter(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get track() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set track(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressBar_default = ProgressBar;

// node_modules/@skeletonlabs/skeleton/dist/components/ProgressRadial/ProgressRadial.svelte
var file18 = "node_modules/@skeletonlabs/skeleton/dist/components/ProgressRadial/ProgressRadial.svelte";
function create_if_block13(ctx) {
  let text_1;
  let text_1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      text_1 = claim_svg_element(nodes, "text", {
        x: true,
        y: true,
        "text-anchor": true,
        "dominant-baseline": true,
        "font-weight": true,
        "font-size": true,
        class: true
      });
      var text_1_nodes = children(text_1);
      if (default_slot)
        default_slot.l(text_1_nodes);
      text_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "x", "50%");
      attr_dev(text_1, "y", "50%");
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "dominant-baseline", "middle");
      attr_dev(text_1, "font-weight", "bold");
      attr_dev(
        text_1,
        "font-size",
        /*font*/
        ctx[2]
      );
      attr_dev(text_1, "class", text_1_class_value = "progress-radial-text " + /*fill*/
      ctx[7]);
      add_location(text_1, file18, 61, 3, 1949);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, text_1, anchor);
      if (default_slot) {
        default_slot.m(text_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*font*/
      4) {
        attr_dev(
          text_1,
          "font-size",
          /*font*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*fill*/
      128 && text_1_class_value !== (text_1_class_value = "progress-radial-text " + /*fill*/
      ctx2[7])) {
        attr_dev(text_1, "class", text_1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(text_1);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block13.name,
    type: "if",
    source: "(61:2) {#if value != undefined && value >= 0 && $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let figure;
  let svg;
  let circle0;
  let circle0_class_value;
  let circle1;
  let circle1_class_value;
  let style_stroke_dasharray = `${/*circumference*/
  ctx[9]}
			${/*circumference*/
  ctx[9]}`;
  let svg_viewBox_value;
  let figure_class_value;
  let figure_aria_valuenow_value;
  let figure_aria_valuetext_value;
  let figure_aria_valuemin_value;
  let figure_aria_valuemax_value;
  let current;
  let if_block = (
    /*value*/
    ctx[0] != void 0 && /*value*/
    ctx[0] >= 0 && /*$$slots*/
    ctx[13].default && create_if_block13(ctx)
  );
  const block = {
    c: function create() {
      figure = element("figure");
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      figure = claim_element(nodes, "FIGURE", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-labelledby": true,
        "aria-valuenow": true,
        "aria-valuetext": true,
        "aria-valuemin": true,
        "aria-valuemax": true
      });
      var figure_nodes = children(figure);
      svg = claim_svg_element(figure_nodes, "svg", { viewBox: true, class: true });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        "stroke-width": true,
        r: true,
        cx: true,
        cy: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        "stroke-width": true,
        r: true,
        cx: true,
        cy: true,
        "stroke-linecap": true
      });
      children(circle1).forEach(detach_dev);
      if (if_block)
        if_block.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      figure_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "class", circle0_class_value = "progress-radial-track " + cBaseTrack + " " + /*track*/
      ctx[6]);
      attr_dev(
        circle0,
        "stroke-width",
        /*stroke*/
        ctx[1]
      );
      attr_dev(
        circle0,
        "r",
        /*radius*/
        ctx[12]
      );
      attr_dev(circle0, "cx", "50%");
      attr_dev(circle0, "cy", "50%");
      add_location(circle0, file18, 44, 2, 1449);
      attr_dev(circle1, "class", circle1_class_value = "progress-radial-meter " + cBaseMeter + " " + /*meter*/
      ctx[5] + " " + /*transition*/
      ctx[4]);
      attr_dev(
        circle1,
        "stroke-width",
        /*stroke*/
        ctx[1]
      );
      attr_dev(
        circle1,
        "r",
        /*radius*/
        ctx[12]
      );
      attr_dev(circle1, "cx", "50%");
      attr_dev(circle1, "cy", "50%");
      attr_dev(
        circle1,
        "stroke-linecap",
        /*strokeLinecap*/
        ctx[3]
      );
      set_style(circle1, "stroke-dasharray", style_stroke_dasharray);
      set_style(
        circle1,
        "stroke-dashoffset",
        /*dashoffset*/
        ctx[10]
      );
      add_location(circle1, file18, 47, 2, 1582);
      attr_dev(svg, "viewBox", svg_viewBox_value = "0 0 " + baseSize + " " + baseSize);
      attr_dev(svg, "class", "rounded-full");
      toggle_class(
        svg,
        "animate-spin",
        /*value*/
        ctx[0] === void 0
      );
      add_location(svg, file18, 42, 1, 1326);
      attr_dev(figure, "class", figure_class_value = "progress-radial " + /*classesBase*/
      ctx[11]);
      attr_dev(figure, "data-testid", "progress-radial");
      attr_dev(figure, "role", "meter");
      attr_dev(
        figure,
        "aria-labelledby",
        /*labelledby*/
        ctx[8]
      );
      attr_dev(figure, "aria-valuenow", figure_aria_valuenow_value = /*value*/
      ctx[0] || 0);
      attr_dev(figure, "aria-valuetext", figure_aria_valuetext_value = /*value*/
      ctx[0] ? `${/*value*/
      ctx[0]}%` : "Indeterminate Spinner");
      attr_dev(figure, "aria-valuemin", figure_aria_valuemin_value = 0);
      attr_dev(figure, "aria-valuemax", figure_aria_valuemax_value = 100);
      add_location(figure, file18, 31, 0, 1050);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, figure, anchor);
      append_hydration_dev(figure, svg);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      if (if_block)
        if_block.m(svg, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*track*/
      64 && circle0_class_value !== (circle0_class_value = "progress-radial-track " + cBaseTrack + " " + /*track*/
      ctx2[6])) {
        attr_dev(circle0, "class", circle0_class_value);
      }
      if (!current || dirty & /*stroke*/
      2) {
        attr_dev(
          circle0,
          "stroke-width",
          /*stroke*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*meter, transition*/
      48 && circle1_class_value !== (circle1_class_value = "progress-radial-meter " + cBaseMeter + " " + /*meter*/
      ctx2[5] + " " + /*transition*/
      ctx2[4])) {
        attr_dev(circle1, "class", circle1_class_value);
      }
      if (!current || dirty & /*stroke*/
      2) {
        attr_dev(
          circle1,
          "stroke-width",
          /*stroke*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*strokeLinecap*/
      8) {
        attr_dev(
          circle1,
          "stroke-linecap",
          /*strokeLinecap*/
          ctx2[3]
        );
      }
      if (dirty & /*circumference*/
      512 && style_stroke_dasharray !== (style_stroke_dasharray = `${/*circumference*/
      ctx2[9]}
			${/*circumference*/
      ctx2[9]}`)) {
        set_style(circle1, "stroke-dasharray", style_stroke_dasharray);
      }
      if (dirty & /*dashoffset*/
      1024) {
        set_style(
          circle1,
          "stroke-dashoffset",
          /*dashoffset*/
          ctx2[10]
        );
      }
      if (
        /*value*/
        ctx2[0] != void 0 && /*value*/
        ctx2[0] >= 0 && /*$$slots*/
        ctx2[13].default
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*value, $$slots*/
          8193) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(svg, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*value, undefined*/
      1) {
        toggle_class(
          svg,
          "animate-spin",
          /*value*/
          ctx2[0] === void 0
        );
      }
      if (!current || dirty & /*classesBase*/
      2048 && figure_class_value !== (figure_class_value = "progress-radial " + /*classesBase*/
      ctx2[11])) {
        attr_dev(figure, "class", figure_class_value);
      }
      if (!current || dirty & /*labelledby*/
      256) {
        attr_dev(
          figure,
          "aria-labelledby",
          /*labelledby*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*value*/
      1 && figure_aria_valuenow_value !== (figure_aria_valuenow_value = /*value*/
      ctx2[0] || 0)) {
        attr_dev(figure, "aria-valuenow", figure_aria_valuenow_value);
      }
      if (!current || dirty & /*value*/
      1 && figure_aria_valuetext_value !== (figure_aria_valuetext_value = /*value*/
      ctx2[0] ? `${/*value*/
      ctx2[0]}%` : "Indeterminate Spinner")) {
        attr_dev(figure, "aria-valuetext", figure_aria_valuetext_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(figure);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase12 = "progress-radial relative overflow-hidden";
var cBaseTrack = "fill-transparent";
var cBaseMeter = "fill-transparent -rotate-90 origin-[50%_50%]";
var baseSize = 512;
function instance18($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressRadial", slots, ["default"]);
  const $$slots = compute_slots(slots);
  let { value = void 0 } = $$props;
  let { stroke = 40 } = $$props;
  let { font = 56 } = $$props;
  let { strokeLinecap = "butt" } = $$props;
  let { transition = "transition-[stroke-dashoffset]" } = $$props;
  let { width = "w-36" } = $$props;
  let { meter = "stroke-surface-900 dark:stroke-surface-50" } = $$props;
  let { track = "stroke-surface-500/30" } = $$props;
  let { fill = "fill-token" } = $$props;
  let { labelledby = "" } = $$props;
  const radius = baseSize / 2 - stroke / 2;
  let circumference = radius;
  let dashoffset;
  function setProgress(percent) {
    $$invalidate(9, circumference = radius * 2 * Math.PI);
    $$invalidate(10, dashoffset = circumference - percent / 100 * circumference);
  }
  setProgress(0);
  afterUpdate(() => {
    setProgress(value === void 0 ? 25 : value);
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("stroke" in $$new_props)
      $$invalidate(1, stroke = $$new_props.stroke);
    if ("font" in $$new_props)
      $$invalidate(2, font = $$new_props.font);
    if ("strokeLinecap" in $$new_props)
      $$invalidate(3, strokeLinecap = $$new_props.strokeLinecap);
    if ("transition" in $$new_props)
      $$invalidate(4, transition = $$new_props.transition);
    if ("width" in $$new_props)
      $$invalidate(14, width = $$new_props.width);
    if ("meter" in $$new_props)
      $$invalidate(5, meter = $$new_props.meter);
    if ("track" in $$new_props)
      $$invalidate(6, track = $$new_props.track);
    if ("fill" in $$new_props)
      $$invalidate(7, fill = $$new_props.fill);
    if ("labelledby" in $$new_props)
      $$invalidate(8, labelledby = $$new_props.labelledby);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    value,
    stroke,
    font,
    strokeLinecap,
    transition,
    width,
    meter,
    track,
    fill,
    labelledby,
    cBase: cBase12,
    cBaseTrack,
    cBaseMeter,
    baseSize,
    radius,
    circumference,
    dashoffset,
    setProgress,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("stroke" in $$props)
      $$invalidate(1, stroke = $$new_props.stroke);
    if ("font" in $$props)
      $$invalidate(2, font = $$new_props.font);
    if ("strokeLinecap" in $$props)
      $$invalidate(3, strokeLinecap = $$new_props.strokeLinecap);
    if ("transition" in $$props)
      $$invalidate(4, transition = $$new_props.transition);
    if ("width" in $$props)
      $$invalidate(14, width = $$new_props.width);
    if ("meter" in $$props)
      $$invalidate(5, meter = $$new_props.meter);
    if ("track" in $$props)
      $$invalidate(6, track = $$new_props.track);
    if ("fill" in $$props)
      $$invalidate(7, fill = $$new_props.fill);
    if ("labelledby" in $$props)
      $$invalidate(8, labelledby = $$new_props.labelledby);
    if ("circumference" in $$props)
      $$invalidate(9, circumference = $$new_props.circumference);
    if ("dashoffset" in $$props)
      $$invalidate(10, dashoffset = $$new_props.dashoffset);
    if ("classesBase" in $$props)
      $$invalidate(11, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(11, classesBase = `${cBase12} ${width} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    stroke,
    font,
    strokeLinecap,
    transition,
    meter,
    track,
    fill,
    labelledby,
    circumference,
    dashoffset,
    classesBase,
    radius,
    $$slots,
    width,
    $$scope,
    slots
  ];
}
var ProgressRadial = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, {
      value: 0,
      stroke: 1,
      font: 2,
      strokeLinecap: 3,
      transition: 4,
      width: 14,
      meter: 5,
      track: 6,
      fill: 7,
      labelledby: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressRadial",
      options,
      id: create_fragment18.name
    });
  }
  get value() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stroke() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stroke(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get font() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set font(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strokeLinecap() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strokeLinecap(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get meter() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set meter(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get track() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set track(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<ProgressRadial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<ProgressRadial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressRadial_default = ProgressRadial;

// node_modules/@skeletonlabs/skeleton/dist/components/Ratings/Ratings.svelte
var file19 = "node_modules/@skeletonlabs/skeleton/dist/components/Ratings/Ratings.svelte";
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  child_ctx[17] = i;
  return child_ctx;
}
var get_empty_slot_changes_1 = (dirty) => ({});
var get_empty_slot_context_1 = (ctx) => ({});
var get_half_slot_changes_1 = (dirty) => ({});
var get_half_slot_context_1 = (ctx) => ({});
var get_full_slot_changes_1 = (dirty) => ({});
var get_full_slot_context_1 = (ctx) => ({});
var get_empty_slot_changes = (dirty) => ({});
var get_empty_slot_context = (ctx) => ({});
var get_half_slot_changes = (dirty) => ({});
var get_half_slot_context = (ctx) => ({});
var get_full_slot_changes = (dirty) => ({});
var get_full_slot_context = (ctx) => ({});
function create_else_block_12(ctx) {
  let span;
  let show_if;
  let show_if_1;
  let current_block_type_index;
  let if_block;
  let t;
  let span_class_value;
  let current;
  const if_block_creators = [create_if_block_34, create_if_block_43, create_else_block_2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (dirty & /*value*/
    1)
      show_if = null;
    if (dirty & /*value*/
    1)
      show_if_1 = null;
    if (show_if == null)
      show_if = !!isFull(
        /*value*/
        ctx2[0],
        /*i*/
        ctx2[17]
      );
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!isHalf(
        /*value*/
        ctx2[0],
        /*i*/
        ctx2[17]
      );
    if (show_if_1)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_2(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      span = element("span");
      if_block.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if_block.l(span_nodes);
      t = claim_space(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = "rating-icon " + /*regionIcon*/
      ctx[3]);
      add_location(span, file19, 40, 3, 1150);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      append_hydration_dev(span, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(span, t);
      }
      if (!current || dirty & /*regionIcon*/
      8 && span_class_value !== (span_class_value = "rating-icon " + /*regionIcon*/
      ctx2[3])) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_12.name,
    type: "else",
    source: "(40:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block14(ctx) {
  let button;
  let show_if;
  let show_if_1;
  let current_block_type_index;
  let if_block;
  let t;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_18, create_if_block_27, create_else_block6];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty & /*value*/
    1)
      show_if = null;
    if (dirty & /*value*/
    1)
      show_if_1 = null;
    if (show_if == null)
      show_if = !!isFull(
        /*value*/
        ctx2[0],
        /*i*/
        ctx2[17]
      );
    if (show_if)
      return 0;
    if (show_if_1 == null)
      show_if_1 = !!isHalf(
        /*value*/
        ctx2[0],
        /*i*/
        ctx2[17]
      );
    if (show_if_1)
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function click_handler() {
    return (
      /*click_handler*/
      ctx[12](
        /*i*/
        ctx[17]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      if_block.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, type: true });
      var button_nodes = children(button);
      if_block.l(button_nodes);
      t = claim_space(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = "rating-icon " + /*regionIcon*/
      ctx[3]);
      attr_dev(button, "type", "button");
      add_location(button, file19, 30, 3, 878);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      append_hydration_dev(button, t);
      current = true;
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(button, t);
      }
      if (!current || dirty & /*regionIcon*/
      8 && button_class_value !== (button_class_value = "rating-icon " + /*regionIcon*/
      ctx[3])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block14.name,
    type: "if",
    source: "(30:2) {#if interactive}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let current;
  const empty_slot_template = (
    /*#slots*/
    ctx[11].empty
  );
  const empty_slot = create_slot(
    empty_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_empty_slot_context_1
  );
  const block = {
    c: function create() {
      if (empty_slot)
        empty_slot.c();
    },
    l: function claim(nodes) {
      if (empty_slot)
        empty_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (empty_slot) {
        empty_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (empty_slot) {
        if (empty_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            empty_slot,
            empty_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              empty_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_empty_slot_changes_1
            ),
            get_empty_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(empty_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(empty_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (empty_slot)
        empty_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(46:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_43(ctx) {
  let current;
  const half_slot_template = (
    /*#slots*/
    ctx[11].half
  );
  const half_slot = create_slot(
    half_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_half_slot_context_1
  );
  const block = {
    c: function create() {
      if (half_slot)
        half_slot.c();
    },
    l: function claim(nodes) {
      if (half_slot)
        half_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (half_slot) {
        half_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (half_slot) {
        if (half_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            half_slot,
            half_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              half_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_half_slot_changes_1
            ),
            get_half_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(half_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(half_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (half_slot)
        half_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_43.name,
    type: "if",
    source: "(44:31) ",
    ctx
  });
  return block;
}
function create_if_block_34(ctx) {
  let current;
  const full_slot_template = (
    /*#slots*/
    ctx[11].full
  );
  const full_slot = create_slot(
    full_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_full_slot_context_1
  );
  const block = {
    c: function create() {
      if (full_slot)
        full_slot.c();
    },
    l: function claim(nodes) {
      if (full_slot)
        full_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (full_slot) {
        full_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (full_slot) {
        if (full_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            full_slot,
            full_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              full_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_full_slot_changes_1
            ),
            get_full_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(full_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(full_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (full_slot)
        full_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_34.name,
    type: "if",
    source: "(42:4) {#if isFull(value, i)}",
    ctx
  });
  return block;
}
function create_else_block6(ctx) {
  let current;
  const empty_slot_template = (
    /*#slots*/
    ctx[11].empty
  );
  const empty_slot = create_slot(
    empty_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_empty_slot_context
  );
  const block = {
    c: function create() {
      if (empty_slot)
        empty_slot.c();
    },
    l: function claim(nodes) {
      if (empty_slot)
        empty_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (empty_slot) {
        empty_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (empty_slot) {
        if (empty_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            empty_slot,
            empty_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              empty_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_empty_slot_changes
            ),
            get_empty_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(empty_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(empty_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (empty_slot)
        empty_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block6.name,
    type: "else",
    source: "(36:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_27(ctx) {
  let current;
  const half_slot_template = (
    /*#slots*/
    ctx[11].half
  );
  const half_slot = create_slot(
    half_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_half_slot_context
  );
  const block = {
    c: function create() {
      if (half_slot)
        half_slot.c();
    },
    l: function claim(nodes) {
      if (half_slot)
        half_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (half_slot) {
        half_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (half_slot) {
        if (half_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            half_slot,
            half_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              half_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_half_slot_changes
            ),
            get_half_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(half_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(half_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (half_slot)
        half_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_27.name,
    type: "if",
    source: "(34:31) ",
    ctx
  });
  return block;
}
function create_if_block_18(ctx) {
  let current;
  const full_slot_template = (
    /*#slots*/
    ctx[11].full
  );
  const full_slot = create_slot(
    full_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_full_slot_context
  );
  const block = {
    c: function create() {
      if (full_slot)
        full_slot.c();
    },
    l: function claim(nodes) {
      if (full_slot)
        full_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (full_slot) {
        full_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (full_slot) {
        if (full_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            full_slot,
            full_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              full_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_full_slot_changes
            ),
            get_full_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(full_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(full_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (full_slot)
        full_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_18.name,
    type: "if",
    source: "(32:4) {#if isFull(value, i)}",
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block14, create_else_block_12];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*interactive*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(29:1) {#each { length: max } as _, i}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let div;
  let div_class_value;
  let current;
  let each_value = ensure_array_like_dev({ length: (
    /*max*/
    ctx[1]
  ) });
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "ratings " + /*classesBase*/
      ctx[4]);
      attr_dev(div, "data-testid", "rating-bar");
      add_location(div, file19, 26, 0, 692);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*regionIcon, iconClick, $$scope, isFull, value, isHalf, interactive, max*/
      1071) {
        each_value = ensure_array_like_dev({ length: (
          /*max*/
          ctx2[1]
        ) });
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      16 && div_class_value !== (div_class_value = "ratings " + /*classesBase*/
      ctx2[4])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase13 = "w-full flex";
function isFull(value2, index) {
  return Math.floor(value2) >= index + 1;
}
function isHalf(value2, index) {
  return value2 === index + 0.5;
}
function instance19($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Ratings", slots, ["full", "half", "empty"]);
  let { value = 0 } = $$props;
  let { max = 5 } = $$props;
  let { interactive = false } = $$props;
  let { text: text2 = "text-token" } = $$props;
  let { fill = "fill-token" } = $$props;
  let { justify = "justify-center" } = $$props;
  let { spacing = "space-x-2" } = $$props;
  let { regionIcon = "" } = $$props;
  const dispatch = createEventDispatcher();
  function iconClick(index) {
    dispatch("icon", { index: index + 1 });
  }
  const click_handler = (i) => iconClick(i);
  $$self.$$set = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("max" in $$new_props)
      $$invalidate(1, max = $$new_props.max);
    if ("interactive" in $$new_props)
      $$invalidate(2, interactive = $$new_props.interactive);
    if ("text" in $$new_props)
      $$invalidate(6, text2 = $$new_props.text);
    if ("fill" in $$new_props)
      $$invalidate(7, fill = $$new_props.fill);
    if ("justify" in $$new_props)
      $$invalidate(8, justify = $$new_props.justify);
    if ("spacing" in $$new_props)
      $$invalidate(9, spacing = $$new_props.spacing);
    if ("regionIcon" in $$new_props)
      $$invalidate(3, regionIcon = $$new_props.regionIcon);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    value,
    max,
    interactive,
    text: text2,
    fill,
    justify,
    spacing,
    regionIcon,
    dispatch,
    iconClick,
    isFull,
    isHalf,
    cBase: cBase13,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("max" in $$props)
      $$invalidate(1, max = $$new_props.max);
    if ("interactive" in $$props)
      $$invalidate(2, interactive = $$new_props.interactive);
    if ("text" in $$props)
      $$invalidate(6, text2 = $$new_props.text);
    if ("fill" in $$props)
      $$invalidate(7, fill = $$new_props.fill);
    if ("justify" in $$props)
      $$invalidate(8, justify = $$new_props.justify);
    if ("spacing" in $$props)
      $$invalidate(9, spacing = $$new_props.spacing);
    if ("regionIcon" in $$props)
      $$invalidate(3, regionIcon = $$new_props.regionIcon);
    if ("classesBase" in $$props)
      $$invalidate(4, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, classesBase = `${cBase13} ${text2} ${fill} ${justify} ${spacing} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    max,
    interactive,
    regionIcon,
    classesBase,
    iconClick,
    text2,
    fill,
    justify,
    spacing,
    $$scope,
    slots,
    click_handler
  ];
}
var Ratings = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, {
      value: 0,
      max: 1,
      interactive: 2,
      text: 6,
      fill: 7,
      justify: 8,
      spacing: 9,
      regionIcon: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Ratings",
      options,
      id: create_fragment19.name
    });
  }
  get value() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionIcon() {
    throw new Error("<Ratings>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionIcon(value) {
    throw new Error("<Ratings>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Ratings_default = Ratings;

// node_modules/@skeletonlabs/skeleton/dist/components/Radio/RadioGroup.svelte
var file20 = "node_modules/@skeletonlabs/skeleton/dist/components/Radio/RadioGroup.svelte";
function create_fragment20(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-labelledby": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "radio-group " + /*classesBase*/
      ctx[1]);
      attr_dev(div, "data-testid", "radio-group");
      attr_dev(div, "role", "radiogroup");
      attr_dev(
        div,
        "aria-labelledby",
        /*labelledby*/
        ctx[0]
      );
      add_location(div, file20, 26, 0, 888);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesBase*/
      2 && div_class_value !== (div_class_value = "radio-group " + /*classesBase*/
      ctx2[1])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*labelledby*/
      1) {
        attr_dev(
          div,
          "aria-labelledby",
          /*labelledby*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase14 = "p-1";
function instance20($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioGroup", slots, ["default"]);
  let { display = "inline-flex" } = $$props;
  let { flexDirection = "flex-row" } = $$props;
  let { gap = "gap-1" } = $$props;
  let { background = "bg-surface-200-700-token" } = $$props;
  let { border = "border-token border-surface-400-500-token" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  let { padding = "px-4 py-1" } = $$props;
  let { active = "variant-filled" } = $$props;
  let { hover = "hover:variant-soft" } = $$props;
  let { color = "" } = $$props;
  let { fill = "" } = $$props;
  let { regionLabel = "" } = $$props;
  let { labelledby = "" } = $$props;
  setContext("rounded", rounded);
  setContext("padding", padding);
  setContext("active", active);
  setContext("hover", hover);
  setContext("color", color);
  setContext("fill", fill);
  setContext("regionLabel", regionLabel);
  $$self.$$set = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("display" in $$new_props)
      $$invalidate(2, display = $$new_props.display);
    if ("flexDirection" in $$new_props)
      $$invalidate(3, flexDirection = $$new_props.flexDirection);
    if ("gap" in $$new_props)
      $$invalidate(4, gap = $$new_props.gap);
    if ("background" in $$new_props)
      $$invalidate(5, background = $$new_props.background);
    if ("border" in $$new_props)
      $$invalidate(6, border = $$new_props.border);
    if ("rounded" in $$new_props)
      $$invalidate(7, rounded = $$new_props.rounded);
    if ("padding" in $$new_props)
      $$invalidate(8, padding = $$new_props.padding);
    if ("active" in $$new_props)
      $$invalidate(9, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("color" in $$new_props)
      $$invalidate(11, color = $$new_props.color);
    if ("fill" in $$new_props)
      $$invalidate(12, fill = $$new_props.fill);
    if ("regionLabel" in $$new_props)
      $$invalidate(13, regionLabel = $$new_props.regionLabel);
    if ("labelledby" in $$new_props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    display,
    flexDirection,
    gap,
    background,
    border,
    rounded,
    padding,
    active,
    hover,
    color,
    fill,
    regionLabel,
    labelledby,
    cBase: cBase14,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(16, $$props = assign(assign({}, $$props), $$new_props));
    if ("display" in $$props)
      $$invalidate(2, display = $$new_props.display);
    if ("flexDirection" in $$props)
      $$invalidate(3, flexDirection = $$new_props.flexDirection);
    if ("gap" in $$props)
      $$invalidate(4, gap = $$new_props.gap);
    if ("background" in $$props)
      $$invalidate(5, background = $$new_props.background);
    if ("border" in $$props)
      $$invalidate(6, border = $$new_props.border);
    if ("rounded" in $$props)
      $$invalidate(7, rounded = $$new_props.rounded);
    if ("padding" in $$props)
      $$invalidate(8, padding = $$new_props.padding);
    if ("active" in $$props)
      $$invalidate(9, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(10, hover = $$new_props.hover);
    if ("color" in $$props)
      $$invalidate(11, color = $$new_props.color);
    if ("fill" in $$props)
      $$invalidate(12, fill = $$new_props.fill);
    if ("regionLabel" in $$props)
      $$invalidate(13, regionLabel = $$new_props.regionLabel);
    if ("labelledby" in $$props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("classesBase" in $$props)
      $$invalidate(1, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(1, classesBase = `${cBase14} ${display} ${flexDirection} ${gap} ${background} ${border} ${rounded} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    labelledby,
    classesBase,
    display,
    flexDirection,
    gap,
    background,
    border,
    rounded,
    padding,
    active,
    hover,
    color,
    fill,
    regionLabel,
    $$scope,
    slots
  ];
}
var RadioGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {
      display: 2,
      flexDirection: 3,
      gap: 4,
      background: 5,
      border: 6,
      rounded: 7,
      padding: 8,
      active: 9,
      hover: 10,
      color: 11,
      fill: 12,
      regionLabel: 13,
      labelledby: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioGroup",
      options,
      id: create_fragment20.name
    });
  }
  get display() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set display(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flexDirection() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flexDirection(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLabel() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLabel(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<RadioGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<RadioGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioGroup_default = RadioGroup;

// node_modules/@skeletonlabs/skeleton/dist/components/Radio/RadioItem.svelte
var file21 = "node_modules/@skeletonlabs/skeleton/dist/components/Radio/RadioItem.svelte";
function create_fragment21(ctx) {
  let label_1;
  let div1;
  let div0;
  let input;
  let t;
  let div1_class_value;
  let label_1_class_value;
  let current;
  let binding_group;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "radio" },
    { name: (
      /*name*/
      ctx[1]
    ) },
    { __value: (
      /*value*/
      ctx[2]
    ) },
    /*prunedRestProps*/
    ctx[11](),
    { tabindex: "-1" }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[29][0]
  );
  const block = {
    c: function create() {
      label_1 = element("label");
      div1 = element("div");
      div0 = element("div");
      input = element("input");
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true });
      var label_1_nodes = children(label_1);
      div1 = claim_element(label_1_nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-checked": true,
        "aria-label": true,
        tabindex: true,
        title: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", { type: true, name: true, tabindex: true });
      div0_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file21, 56, 3, 1578);
      attr_dev(div0, "class", "h-0 w-0 overflow-hidden");
      add_location(div0, file21, 55, 2, 1537);
      attr_dev(div1, "class", div1_class_value = "radio-item " + /*classesWrapper*/
      ctx[8]);
      attr_dev(div1, "data-testid", "radio-item");
      attr_dev(div1, "role", "radio");
      attr_dev(
        div1,
        "aria-checked",
        /*checked*/
        ctx[6]
      );
      attr_dev(
        div1,
        "aria-label",
        /*label*/
        ctx[4]
      );
      attr_dev(div1, "tabindex", "0");
      attr_dev(
        div1,
        "title",
        /*title*/
        ctx[3]
      );
      add_location(div1, file21, 41, 1, 1236);
      attr_dev(label_1, "class", label_1_class_value = "radio-label " + /*classsBase*/
      ctx[9] + " " + /*regionLabel*/
      ctx[5]);
      add_location(label_1, file21, 39, 0, 1127);
      binding_group.p(input);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      append_hydration_dev(label_1, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[27](input);
      input.checked = input.__value === /*group*/
      ctx[0];
      append_hydration_dev(div1, t);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[28]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*onKeyDown*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*keydown_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keyup",
            /*keyup_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keypress",
            /*keypress_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "radio" },
        (!current || dirty[0] & /*name*/
        2) && { name: (
          /*name*/
          ctx2[1]
        ) },
        (!current || dirty[0] & /*value*/
        4) && { __value: (
          /*value*/
          ctx2[2]
        ) },
        /*prunedRestProps*/
        ctx2[11](),
        { tabindex: "-1" }
      ]));
      if (dirty[0] & /*group*/
      1) {
        input.checked = input.__value === /*group*/
        ctx2[0];
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classesWrapper*/
      256 && div1_class_value !== (div1_class_value = "radio-item " + /*classesWrapper*/
      ctx2[8])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*checked*/
      64) {
        attr_dev(
          div1,
          "aria-checked",
          /*checked*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*label*/
      16) {
        attr_dev(
          div1,
          "aria-label",
          /*label*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*title*/
      8) {
        attr_dev(
          div1,
          "title",
          /*title*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*classsBase, regionLabel*/
      544 && label_1_class_value !== (label_1_class_value = "radio-label " + /*classsBase*/
      ctx2[9] + " " + /*regionLabel*/
      ctx2[5])) {
        attr_dev(label_1, "class", label_1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
      ctx[27](null);
      if (default_slot)
        default_slot.d(detaching);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase15 = "flex-auto";
var cWrapper3 = "text-base text-center cursor-pointer";
var cDisabled = "opacity-50 cursor-not-allowed";
function instance21($$self, $$props, $$invalidate) {
  let checked;
  let classesActive;
  let classesDisabled;
  let classsBase;
  let classesWrapper;
  const omit_props_names = [
    "group",
    "name",
    "value",
    "title",
    "label",
    "rounded",
    "padding",
    "active",
    "hover",
    "color",
    "fill",
    "regionLabel"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RadioItem", slots, ["default"]);
  let { group } = $$props;
  let { name } = $$props;
  let { value } = $$props;
  let { title = "" } = $$props;
  let { label = "" } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { active = getContext("active") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { color = getContext("color") } = $$props;
  let { fill = getContext("fill") } = $$props;
  let { regionLabel = getContext("regionLabel") } = $$props;
  let elemInput;
  function onKeyDown2(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      elemInput.click();
    }
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (group === void 0 && !("group" in $$props || $$self.$$.bound[$$self.$$.props["group"]])) {
      console.warn("<RadioItem> was created without expected prop 'group'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<RadioItem> was created without expected prop 'name'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<RadioItem> was created without expected prop 'value'");
    }
  });
  const $$binding_groups = [[]];
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemInput = $$value;
      $$invalidate(7, elemInput);
    });
  }
  function input_change_handler() {
    group = this.__value;
    $$invalidate(0, group);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(31, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(30, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("group" in $$new_props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("title" in $$new_props)
      $$invalidate(3, title = $$new_props.title);
    if ("label" in $$new_props)
      $$invalidate(4, label = $$new_props.label);
    if ("rounded" in $$new_props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("padding" in $$new_props)
      $$invalidate(13, padding = $$new_props.padding);
    if ("active" in $$new_props)
      $$invalidate(14, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(15, hover = $$new_props.hover);
    if ("color" in $$new_props)
      $$invalidate(16, color = $$new_props.color);
    if ("fill" in $$new_props)
      $$invalidate(17, fill = $$new_props.fill);
    if ("regionLabel" in $$new_props)
      $$invalidate(5, regionLabel = $$new_props.regionLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    group,
    name,
    value,
    title,
    label,
    rounded,
    padding,
    active,
    hover,
    color,
    fill,
    regionLabel,
    cBase: cBase15,
    cWrapper: cWrapper3,
    cDisabled,
    elemInput,
    onKeyDown: onKeyDown2,
    prunedRestProps,
    classesDisabled,
    classesActive,
    classesWrapper,
    classsBase,
    checked
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(31, $$props = assign(assign({}, $$props), $$new_props));
    if ("group" in $$props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("title" in $$props)
      $$invalidate(3, title = $$new_props.title);
    if ("label" in $$props)
      $$invalidate(4, label = $$new_props.label);
    if ("rounded" in $$props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("padding" in $$props)
      $$invalidate(13, padding = $$new_props.padding);
    if ("active" in $$props)
      $$invalidate(14, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(15, hover = $$new_props.hover);
    if ("color" in $$props)
      $$invalidate(16, color = $$new_props.color);
    if ("fill" in $$props)
      $$invalidate(17, fill = $$new_props.fill);
    if ("regionLabel" in $$props)
      $$invalidate(5, regionLabel = $$new_props.regionLabel);
    if ("elemInput" in $$props)
      $$invalidate(7, elemInput = $$new_props.elemInput);
    if ("classesDisabled" in $$props)
      $$invalidate(18, classesDisabled = $$new_props.classesDisabled);
    if ("classesActive" in $$props)
      $$invalidate(19, classesActive = $$new_props.classesActive);
    if ("classesWrapper" in $$props)
      $$invalidate(8, classesWrapper = $$new_props.classesWrapper);
    if ("classsBase" in $$props)
      $$invalidate(9, classsBase = $$new_props.classsBase);
    if ("checked" in $$props)
      $$invalidate(6, checked = $$new_props.checked);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value, group*/
    5) {
      $:
        $$invalidate(6, checked = value === group);
    }
    if ($$self.$$.dirty[0] & /*checked, active, color, fill, hover*/
    245824) {
      $:
        $$invalidate(19, classesActive = checked ? `${active} ${color} ${fill}` : hover);
    }
    $:
      $$invalidate(18, classesDisabled = $$props.disabled ? cDisabled : "");
    $:
      $$invalidate(8, classesWrapper = `${cWrapper3} ${padding} ${rounded} ${classesActive} ${classesDisabled} ${$$props.class ?? ""}`);
  };
  $:
    $$invalidate(9, classsBase = `${cBase15}`);
  $$props = exclude_internal_props($$props);
  return [
    group,
    name,
    value,
    title,
    label,
    regionLabel,
    checked,
    elemInput,
    classesWrapper,
    classsBase,
    onKeyDown2,
    prunedRestProps,
    rounded,
    padding,
    active,
    hover,
    color,
    fill,
    classesDisabled,
    classesActive,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    click_handler,
    change_handler,
    input_binding,
    input_change_handler,
    $$binding_groups
  ];
}
var RadioItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance21,
      create_fragment21,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        label: 4,
        rounded: 12,
        padding: 13,
        active: 14,
        hover: 15,
        color: 16,
        fill: 17,
        regionLabel: 5
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RadioItem",
      options,
      id: create_fragment21.name
    });
  }
  get group() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fill() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fill(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLabel() {
    throw new Error("<RadioItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLabel(value) {
    throw new Error("<RadioItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RadioItem_default = RadioItem;

// node_modules/@skeletonlabs/skeleton/dist/components/RangeSlider/RangeSlider.svelte
var file22 = "node_modules/@skeletonlabs/skeleton/dist/components/RangeSlider/RangeSlider.svelte";
var get_trail_slot_changes4 = (dirty) => ({});
var get_trail_slot_context4 = (ctx) => ({});
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function create_if_block_28(ctx) {
  let label_1;
  let label_1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      label_1 = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true, for: true });
      var label_1_nodes = children(label_1);
      if (default_slot)
        default_slot.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(label_1, "class", label_1_class_value = "range-slider-label " + cBaseLabel);
      attr_dev(
        label_1,
        "for",
        /*id*/
        ctx[2]
      );
      add_location(label_1, file22, 37, 22, 951);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      if (default_slot) {
        default_slot.m(label_1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      4) {
        attr_dev(
          label_1,
          "for",
          /*id*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label_1);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_28.name,
    type: "if",
    source: "(38:1) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_if_block_19(ctx) {
  let datalist;
  let datalist_id_value;
  let each_value = ensure_array_like_dev(
    /*tickmarks*/
    ctx[8]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      datalist = element("datalist");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      datalist = claim_element(nodes, "DATALIST", { id: true, class: true });
      var datalist_nodes = children(datalist);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(datalist_nodes);
      }
      datalist_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(datalist, "id", datalist_id_value = "tickmarks-" + /*id*/
      ctx[2]);
      attr_dev(datalist, "class", "range-slider-ticks");
      add_location(datalist, file22, 61, 3, 1426);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, datalist, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(datalist, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tickmarks*/
      256) {
        each_value = ensure_array_like_dev(
          /*tickmarks*/
          ctx2[8]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(datalist, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*id*/
      4 && datalist_id_value !== (datalist_id_value = "tickmarks-" + /*id*/
      ctx2[2])) {
        attr_dev(datalist, "id", datalist_id_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(datalist);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_19.name,
    type: "if",
    source: "(61:2) {#if ticked && tickmarks && tickmarks.length}",
    ctx
  });
  return block;
}
function create_each_block6(ctx) {
  let option;
  let option_value_value;
  let option_label_value;
  const block = {
    c: function create() {
      option = element("option");
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", { label: true });
      children(option).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*tm*/
      ctx[23];
      set_input_value(option, option.__value);
      attr_dev(option, "label", option_label_value = /*tm*/
      ctx[23]);
      add_location(option, file22, 63, 5, 1517);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tickmarks*/
      256 && option_value_value !== (option_value_value = /*tm*/
      ctx2[23])) {
        prop_dev(option, "__value", option_value_value);
        set_input_value(option, option.__value);
      }
      if (dirty & /*tickmarks*/
      256 && option_label_value !== (option_label_value = /*tm*/
      ctx2[23])) {
        attr_dev(option, "label", option_label_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(63:4) {#each tickmarks as tm}",
    ctx
  });
  return block;
}
function create_if_block15(ctx) {
  let div;
  let current;
  const trail_slot_template = (
    /*#slots*/
    ctx[15].trail
  );
  const trail_slot = create_slot(
    trail_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_trail_slot_context4
  );
  const block = {
    c: function create() {
      div = element("div");
      if (trail_slot)
        trail_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (trail_slot)
        trail_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "range-slider-trail");
      add_location(div, file22, 70, 20, 1636);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (trail_slot) {
        trail_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trail_slot) {
        if (trail_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            trail_slot,
            trail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              trail_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_trail_slot_changes4
            ),
            get_trail_slot_context4
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (trail_slot)
        trail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block15.name,
    type: "if",
    source: "(71:1) {#if $$slots.trail}",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let div1;
  let t0;
  let div0;
  let input;
  let input_class_value;
  let input_list_value;
  let t1;
  let div0_class_value;
  let t2;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[12].default && create_if_block_28(ctx)
  );
  let input_levels = [
    { type: "range" },
    { id: (
      /*id*/
      ctx[2]
    ) },
    { name: (
      /*name*/
      ctx[1]
    ) },
    {
      class: input_class_value = "range-slider-input " + /*classesInput*/
      ctx[9]
    },
    {
      list: input_list_value = "tickmarks-" + /*id*/
      ctx[2]
    },
    { "aria-label": (
      /*label*/
      ctx[7]
    ) },
    { min: (
      /*min*/
      ctx[3]
    ) },
    { max: (
      /*max*/
      ctx[4]
    ) },
    { step: (
      /*step*/
      ctx[5]
    ) },
    /*prunedRestProps*/
    ctx[11]()
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block1 = (
    /*ticked*/
    ctx[6] && /*tickmarks*/
    ctx[8] && /*tickmarks*/
    ctx[8].length && create_if_block_19(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[12].trail && create_if_block15(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      input = element("input");
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        class: true,
        list: true,
        "aria-label": true,
        min: true,
        max: true,
        step: true
      });
      t1 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      if (if_block2)
        if_block2.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file22, 42, 2, 1111);
      attr_dev(div0, "class", div0_class_value = "range-content " + cBaseContent);
      add_location(div0, file22, 40, 1, 1049);
      attr_dev(div1, "class", div1_class_value = "range-slider " + /*classesBase*/
      ctx[10]);
      attr_dev(div1, "data-testid", "range-slider");
      add_location(div1, file22, 35, 0, 837);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      append_hydration_dev(div0, t1);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div1, t2);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[19]
          ),
          listen_dev(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[19]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[12].default
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          4096) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_28(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "range" },
        (!current || dirty & /*id*/
        4) && { id: (
          /*id*/
          ctx2[2]
        ) },
        (!current || dirty & /*name*/
        2) && { name: (
          /*name*/
          ctx2[1]
        ) },
        (!current || dirty & /*classesInput*/
        512 && input_class_value !== (input_class_value = "range-slider-input " + /*classesInput*/
        ctx2[9])) && { class: input_class_value },
        (!current || dirty & /*id*/
        4 && input_list_value !== (input_list_value = "tickmarks-" + /*id*/
        ctx2[2])) && { list: input_list_value },
        (!current || dirty & /*label*/
        128) && { "aria-label": (
          /*label*/
          ctx2[7]
        ) },
        (!current || dirty & /*min*/
        8) && { min: (
          /*min*/
          ctx2[3]
        ) },
        (!current || dirty & /*max*/
        16) && { max: (
          /*max*/
          ctx2[4]
        ) },
        (!current || dirty & /*step*/
        32) && { step: (
          /*step*/
          ctx2[5]
        ) },
        /*prunedRestProps*/
        ctx2[11]()
      ]));
      if (dirty & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (
        /*ticked*/
        ctx2[6] && /*tickmarks*/
        ctx2[8] && /*tickmarks*/
        ctx2[8].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_19(ctx2);
          if_block1.c();
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$$slots*/
        ctx2[12].trail
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          4096) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block15(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      1024 && div1_class_value !== (div1_class_value = "range-slider " + /*classesBase*/
      ctx2[10])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase16 = "space-y-2";
var cBaseLabel = "";
var cBaseContent = "flex justify-center py-2";
var cBaseInput = "w-full h-2";
function instance22($$self, $$props, $$invalidate) {
  let classesBase;
  let classesInput;
  const omit_props_names = ["name", "id", "value", "min", "max", "step", "ticked", "accent", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RangeSlider", slots, ["default", "trail"]);
  const $$slots = compute_slots(slots);
  let { name } = $$props;
  let { id = String(Math.random()) } = $$props;
  let { value = 0 } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { step = 1 } = $$props;
  let { ticked = false } = $$props;
  let { accent = "accent-surface-900 dark:accent-surface-50" } = $$props;
  let { label = "" } = $$props;
  let tickmarks;
  function setTicks() {
    if (ticked == false)
      return;
    $$invalidate(8, tickmarks = Array.from({ length: max - min + 1 }, (_, i) => i + min));
  }
  if (ticked)
    setTicks();
  afterUpdate(() => {
    setTicks();
  });
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<RangeSlider> was created without expected prop 'name'");
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(21, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("id" in $$new_props)
      $$invalidate(2, id = $$new_props.id);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(3, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(4, max = $$new_props.max);
    if ("step" in $$new_props)
      $$invalidate(5, step = $$new_props.step);
    if ("ticked" in $$new_props)
      $$invalidate(6, ticked = $$new_props.ticked);
    if ("accent" in $$new_props)
      $$invalidate(13, accent = $$new_props.accent);
    if ("label" in $$new_props)
      $$invalidate(7, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    afterUpdate,
    name,
    id,
    value,
    min,
    max,
    step,
    ticked,
    accent,
    label,
    cBase: cBase16,
    cBaseLabel,
    cBaseContent,
    cBaseInput,
    tickmarks,
    setTicks,
    prunedRestProps,
    classesInput,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("id" in $$props)
      $$invalidate(2, id = $$new_props.id);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$props)
      $$invalidate(3, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(4, max = $$new_props.max);
    if ("step" in $$props)
      $$invalidate(5, step = $$new_props.step);
    if ("ticked" in $$props)
      $$invalidate(6, ticked = $$new_props.ticked);
    if ("accent" in $$props)
      $$invalidate(13, accent = $$new_props.accent);
    if ("label" in $$props)
      $$invalidate(7, label = $$new_props.label);
    if ("tickmarks" in $$props)
      $$invalidate(8, tickmarks = $$new_props.tickmarks);
    if ("classesInput" in $$props)
      $$invalidate(9, classesInput = $$new_props.classesInput);
    if ("classesBase" in $$props)
      $$invalidate(10, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(10, classesBase = `${cBase16} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*accent*/
    8192) {
      $:
        $$invalidate(9, classesInput = `${cBaseInput} ${accent}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    name,
    id,
    min,
    max,
    step,
    ticked,
    label,
    tickmarks,
    classesInput,
    classesBase,
    prunedRestProps,
    $$slots,
    accent,
    $$scope,
    slots,
    click_handler,
    change_handler,
    blur_handler,
    input_change_input_handler
  ];
}
var RangeSlider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      name: 1,
      id: 2,
      value: 0,
      min: 3,
      max: 4,
      step: 5,
      ticked: 6,
      accent: 13,
      label: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RangeSlider",
      options,
      id: create_fragment22.name
    });
  }
  get name() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticked() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticked(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get accent() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set accent(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RangeSlider_default = RangeSlider;

// node_modules/@skeletonlabs/skeleton/dist/components/SlideToggle/SlideToggle.svelte
var file23 = "node_modules/@skeletonlabs/skeleton/dist/components/SlideToggle/SlideToggle.svelte";
function create_if_block16(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "slide-toggle-text ml-3");
      add_location(div, file23, 88, 23, 2466);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block16.name,
    type: "if",
    source: "(89:2) {#if $$slots.default}",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let div2;
  let label_1;
  let input;
  let input_disabled_value;
  let t0;
  let div1;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let t1;
  let label_1_class_value;
  let div2_class_value;
  let current;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "checkbox" },
    { class: "slide-toggle-input hidden" },
    { name: (
      /*name*/
      ctx[1]
    ) },
    /*prunedRestProps*/
    ctx[8](),
    {
      disabled: input_disabled_value = /*$$props*/
      ctx[9].disabled
    }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block = (
    /*$$slots*/
    ctx[10].default && create_if_block16(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      label_1 = element("label");
      input = element("input");
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        id: true,
        class: true,
        "data-testid": true,
        role: true,
        "aria-label": true,
        "aria-checked": true,
        tabindex: true
      });
      var div2_nodes = children(div2);
      label_1 = claim_element(div2_nodes, "LABEL", { class: true });
      var label_1_nodes = children(label_1);
      input = claim_element(label_1_nodes, "INPUT", { type: true, class: true, name: true });
      t0 = claim_space(label_1_nodes);
      div1 = claim_element(label_1_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(label_1_nodes);
      if (if_block)
        if_block.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file23, 67, 2, 1940);
      attr_dev(div0, "class", div0_class_value = "slide-toggle-thumb " + /*classesThumb*/
      ctx[3]);
      toggle_class(
        div0,
        "cursor-not-allowed",
        /*$$props*/
        ctx[9].disabled
      );
      add_location(div0, file23, 85, 3, 2323);
      attr_dev(div1, "class", div1_class_value = "slide-toggle-track " + /*classesTrack*/
      ctx[4]);
      toggle_class(
        div1,
        "cursor-not-allowed",
        /*$$props*/
        ctx[9].disabled
      );
      add_location(div1, file23, 84, 2, 2228);
      attr_dev(label_1, "class", label_1_class_value = "slide-toggle-label " + /*classesLabel*/
      ctx[5]);
      add_location(label_1, file23, 65, 1, 1864);
      attr_dev(
        div2,
        "id",
        /*label*/
        ctx[2]
      );
      attr_dev(div2, "class", div2_class_value = "slide-toggle " + /*classesBase*/
      ctx[6]);
      attr_dev(div2, "data-testid", "slide-toggle");
      attr_dev(div2, "role", "switch");
      attr_dev(
        div2,
        "aria-label",
        /*label*/
        ctx[2]
      );
      attr_dev(
        div2,
        "aria-checked",
        /*checked*/
        ctx[0]
      );
      attr_dev(div2, "tabindex", "0");
      add_location(div2, file23, 55, 0, 1683);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, label_1);
      append_hydration_dev(label_1, input);
      if (input.autofocus)
        input.focus();
      input.checked = /*checked*/
      ctx[0];
      append_hydration_dev(label_1, t0);
      append_hydration_dev(label_1, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(label_1, t1);
      if (if_block)
        if_block.m(label_1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[31]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*keydown_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*keyup_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keypress",
            /*keypress_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mouseover",
            /*mouseover_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*blur_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "keydown",
            /*onKeyDown*/
            ctx[7],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "checkbox" },
        { class: "slide-toggle-input hidden" },
        (!current || dirty[0] & /*name*/
        2) && { name: (
          /*name*/
          ctx2[1]
        ) },
        /*prunedRestProps*/
        ctx2[8](),
        (!current || dirty[0] & /*$$props*/
        512 && input_disabled_value !== (input_disabled_value = /*$$props*/
        ctx2[9].disabled)) && { disabled: input_disabled_value }
      ]));
      if (dirty[0] & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
      if (!current || dirty[0] & /*classesThumb*/
      8 && div0_class_value !== (div0_class_value = "slide-toggle-thumb " + /*classesThumb*/
      ctx2[3])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*classesThumb, $$props*/
      520) {
        toggle_class(
          div0,
          "cursor-not-allowed",
          /*$$props*/
          ctx2[9].disabled
        );
      }
      if (!current || dirty[0] & /*classesTrack*/
      16 && div1_class_value !== (div1_class_value = "slide-toggle-track " + /*classesTrack*/
      ctx2[4])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*classesTrack, $$props*/
      528) {
        toggle_class(
          div1,
          "cursor-not-allowed",
          /*$$props*/
          ctx2[9].disabled
        );
      }
      if (
        /*$$slots*/
        ctx2[10].default
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block16(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(label_1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classesLabel*/
      32 && label_1_class_value !== (label_1_class_value = "slide-toggle-label " + /*classesLabel*/
      ctx2[5])) {
        attr_dev(label_1, "class", label_1_class_value);
      }
      if (!current || dirty[0] & /*label*/
      4) {
        attr_dev(
          div2,
          "id",
          /*label*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*classesBase*/
      64 && div2_class_value !== (div2_class_value = "slide-toggle " + /*classesBase*/
      ctx2[6])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*label*/
      4) {
        attr_dev(
          div2,
          "aria-label",
          /*label*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*checked*/
      1) {
        attr_dev(
          div2,
          "aria-checked",
          /*checked*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase17 = "inline-block";
var cLabel5 = "unstyled flex items-center";
var cTrack2 = "flex transition-all duration-[200ms] cursor-pointer";
var cThumb = "w-[50%] h-full scale-[0.8] transition-all duration-[200ms] shadow";
function instance23($$self, $$props, $$invalidate) {
  let cTrackActive;
  let cThumbBackground;
  let cThumbPos;
  let classesDisabled;
  let classesBase;
  let classesLabel;
  let classesTrack;
  let classesThumb;
  const omit_props_names = ["name", "checked", "size", "background", "active", "border", "rounded", "label"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SlideToggle", slots, ["default"]);
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { name } = $$props;
  let { checked = false } = $$props;
  let { size = "md" } = $$props;
  let { background = "bg-surface-400 dark:bg-surface-700" } = $$props;
  let { active = "bg-surface-900 dark:bg-surface-300" } = $$props;
  let { border = "" } = $$props;
  let { rounded = "rounded-full" } = $$props;
  let { label = "" } = $$props;
  let trackSize;
  switch (size) {
    case "sm":
      trackSize = "w-12 h-6";
      break;
    case "lg":
      trackSize = "w-20 h-10";
      break;
    default:
      trackSize = "w-16 h-8";
  }
  function onKeyDown2(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      dispatch("keyup", event);
      const inputElem = event.currentTarget.firstChild;
      inputElem.click();
    }
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<SlideToggle> was created without expected prop 'name'");
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(33, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("size" in $$new_props)
      $$invalidate(11, size = $$new_props.size);
    if ("background" in $$new_props)
      $$invalidate(12, background = $$new_props.background);
    if ("active" in $$new_props)
      $$invalidate(13, active = $$new_props.active);
    if ("border" in $$new_props)
      $$invalidate(14, border = $$new_props.border);
    if ("rounded" in $$new_props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("label" in $$new_props)
      $$invalidate(2, label = $$new_props.label);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    name,
    checked,
    size,
    background,
    active,
    border,
    rounded,
    label,
    cBase: cBase17,
    cLabel: cLabel5,
    cTrack: cTrack2,
    cThumb,
    trackSize,
    onKeyDown: onKeyDown2,
    prunedRestProps,
    cThumbPos,
    cThumbBackground,
    classesThumb,
    cTrackActive,
    classesTrack,
    classesLabel,
    classesDisabled,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("checked" in $$props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("size" in $$props)
      $$invalidate(11, size = $$new_props.size);
    if ("background" in $$props)
      $$invalidate(12, background = $$new_props.background);
    if ("active" in $$props)
      $$invalidate(13, active = $$new_props.active);
    if ("border" in $$props)
      $$invalidate(14, border = $$new_props.border);
    if ("rounded" in $$props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("label" in $$props)
      $$invalidate(2, label = $$new_props.label);
    if ("trackSize" in $$props)
      $$invalidate(16, trackSize = $$new_props.trackSize);
    if ("cThumbPos" in $$props)
      $$invalidate(17, cThumbPos = $$new_props.cThumbPos);
    if ("cThumbBackground" in $$props)
      $$invalidate(18, cThumbBackground = $$new_props.cThumbBackground);
    if ("classesThumb" in $$props)
      $$invalidate(3, classesThumb = $$new_props.classesThumb);
    if ("cTrackActive" in $$props)
      $$invalidate(19, cTrackActive = $$new_props.cTrackActive);
    if ("classesTrack" in $$props)
      $$invalidate(4, classesTrack = $$new_props.classesTrack);
    if ("classesLabel" in $$props)
      $$invalidate(5, classesLabel = $$new_props.classesLabel);
    if ("classesDisabled" in $$props)
      $$invalidate(20, classesDisabled = $$new_props.classesDisabled);
    if ("classesBase" in $$props)
      $$invalidate(6, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*checked, active, background*/
    12289) {
      $:
        $$invalidate(19, cTrackActive = checked ? active : `${background} cursor-pointer`);
    }
    if ($$self.$$.dirty[0] & /*checked*/
    1) {
      $:
        $$invalidate(18, cThumbBackground = checked ? "bg-white/75" : "bg-white");
    }
    if ($$self.$$.dirty[0] & /*checked*/
    1) {
      $:
        $$invalidate(17, cThumbPos = checked ? "translate-x-full" : "");
    }
    $:
      $$invalidate(20, classesDisabled = $$props.disabled === true ? "opacity-50" : "hover:brightness-[105%] dark:hover:brightness-110 cursor-pointer");
    $:
      $$invalidate(6, classesBase = `${cBase17} ${rounded} ${classesDisabled} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*border, rounded, trackSize, cTrackActive*/
    638976) {
      $:
        $$invalidate(4, classesTrack = `${cTrack2} ${border} ${rounded} ${trackSize} ${cTrackActive}`);
    }
    if ($$self.$$.dirty[0] & /*rounded, cThumbBackground, cThumbPos*/
    425984) {
      $:
        $$invalidate(3, classesThumb = `${cThumb} ${rounded} ${cThumbBackground} ${cThumbPos}`);
    }
  };
  $:
    $$invalidate(5, classesLabel = `${cLabel5}`);
  $$props = exclude_internal_props($$props);
  return [
    checked,
    name,
    label,
    classesThumb,
    classesTrack,
    classesLabel,
    classesBase,
    onKeyDown2,
    prunedRestProps,
    $$props,
    $$slots,
    size,
    background,
    active,
    border,
    rounded,
    trackSize,
    cThumbPos,
    cThumbBackground,
    cTrackActive,
    classesDisabled,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    mouseover_handler,
    change_handler,
    focus_handler,
    blur_handler,
    input_change_handler
  ];
}
var SlideToggle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance23,
      create_fragment23,
      safe_not_equal,
      {
        name: 1,
        checked: 0,
        size: 11,
        background: 12,
        active: 13,
        border: 14,
        rounded: 15,
        label: 2
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SlideToggle",
      options,
      id: create_fragment23.name
    });
  }
  get name() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<SlideToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<SlideToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SlideToggle_default = SlideToggle;

// node_modules/@skeletonlabs/skeleton/dist/components/Stepper/Stepper.svelte
var file24 = "node_modules/@skeletonlabs/skeleton/dist/components/Stepper/Stepper.svelte";
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[39] = list[i];
  return child_ctx;
}
function create_if_block17(ctx) {
  let header;
  let header_class_value;
  let header_intro;
  let header_outro;
  let current;
  let each_value = ensure_array_like_dev(Array.from(Array(
    /*$state*/
    ctx[7].total
  ).keys()));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      header = element("header");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(header_nodes);
      }
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "class", header_class_value = "stepper-header " + /*classesHeader*/
      ctx[11]);
      add_location(header, file24, 90, 2, 3438);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(header, null);
        }
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*classesHeaderStep, isActive, $state, classesBadge, stepTerm*/
      1729) {
        each_value = ensure_array_like_dev(Array.from(Array(
          /*$state*/
          ctx[7].total
        ).keys()));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(header, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty[0] & /*classesHeader*/
      2048 && header_class_value !== (header_class_value = "stepper-header " + /*classesHeader*/
      ctx[11])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (header_outro)
            header_outro.end(1);
          header_intro = create_in_transition(header, dynamicTransition, {
            transition: (
              /*transitionIn*/
              ctx[2]
            ),
            params: (
              /*transitionInParams*/
              ctx[3]
            ),
            enabled: (
              /*transitions*/
              ctx[1]
            )
          });
          header_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      if (header_intro)
        header_intro.invalidate();
      if (local) {
        header_outro = create_out_transition(header, dynamicTransition, {
          transition: (
            /*transitionOut*/
            ctx[4]
          ),
          params: (
            /*transitionOutParams*/
            ctx[5]
          ),
          enabled: (
            /*transitions*/
            ctx[1]
          )
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(header);
      }
      destroy_each(each_blocks, detaching);
      if (detaching && header_outro)
        header_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block17.name,
    type: "if",
    source: "(90:1) {#if $state.total}",
    ctx
  });
  return block;
}
function create_each_block7(ctx) {
  let div;
  let span;
  let t0_value = (
    /*isActive*/
    (ctx[6](
      /*step*/
      ctx[39]
    ) ? `${/*stepTerm*/
    ctx[0]} ${/*step*/
    ctx[39] + 1}` : (
      /*step*/
      ctx[39] + 1
    )) + ""
  );
  let t0;
  let span_class_value;
  let t1;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = "badge " + /*classesBadge*/
      ctx[9](
        /*step*/
        ctx[39]
      ));
      add_location(span, file24, 97, 5, 3868);
      attr_dev(div, "class", div_class_value = "stepper-header-step " + /*classesHeaderStep*/
      ctx[10]);
      toggle_class(
        div,
        "flex-1",
        /*isActive*/
        ctx[6](
          /*step*/
          ctx[39]
        )
      );
      add_location(div, file24, 96, 4, 3779);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*isActive, $state, stepTerm*/
      193 && t0_value !== (t0_value = /*isActive*/
      (ctx2[6](
        /*step*/
        ctx2[39]
      ) ? `${/*stepTerm*/
      ctx2[0]} ${/*step*/
      ctx2[39] + 1}` : (
        /*step*/
        ctx2[39] + 1
      )) + ""))
        set_data_dev(t0, t0_value);
      if (dirty[0] & /*classesBadge, $state*/
      640 && span_class_value !== (span_class_value = "badge " + /*classesBadge*/
      ctx2[9](
        /*step*/
        ctx2[39]
      ))) {
        attr_dev(span, "class", span_class_value);
      }
      if (dirty[0] & /*classesHeaderStep*/
      1024 && div_class_value !== (div_class_value = "stepper-header-step " + /*classesHeaderStep*/
      ctx2[10])) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty[0] & /*classesHeaderStep, isActive, $state*/
      1216) {
        toggle_class(
          div,
          "flex-1",
          /*isActive*/
          ctx2[6](
            /*step*/
            ctx2[39]
          )
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(96:3) {#each Array.from(Array($state.total).keys()) as step}",
    ctx
  });
  return block;
}
function create_fragment24(ctx) {
  let div1;
  let t;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let current;
  let if_block = (
    /*$state*/
    ctx[7].total && create_if_block17(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[32].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      if (if_block)
        if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "stepper-content " + /*classesContent*/
      ctx[8]);
      add_location(div0, file24, 103, 1, 4032);
      attr_dev(div1, "class", div1_class_value = "stepper " + /*classesBase*/
      ctx[12]);
      attr_dev(div1, "data-testid", "stepper");
      add_location(div1, file24, 87, 0, 3341);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$state*/
        ctx2[7].total
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$state*/
          128) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block17(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[31]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[31],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classesContent*/
      256 && div0_class_value !== (div0_class_value = "stepper-content " + /*classesContent*/
      ctx2[8])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      4096 && div1_class_value !== (div1_class_value = "stepper " + /*classesBase*/
      ctx2[12])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase18 = "space-y-4";
var cHeader = "flex items-center border-t mt-[15px]";
var cHeaderStep = "-mt-[15px] transition-all duration-300";
var cContent = "";
function instance24($$self, $$props, $$invalidate) {
  let isActive;
  let classesBase;
  let classesHeader;
  let classesHeaderStep;
  let classesBadge;
  let classesContent;
  let $state;
  let $prefersReducedMotionStore;
  validate_store(prefersReducedMotionStore, "prefersReducedMotionStore");
  component_subscribe($$self, prefersReducedMotionStore, ($$value) => $$invalidate(33, $prefersReducedMotionStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Stepper", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { gap = "gap-4" } = $$props;
  let { stepTerm = "Step" } = $$props;
  let { badge = "variant-filled-surface" } = $$props;
  let { active = "variant-filled" } = $$props;
  let { border = "border-surface-400-500-token" } = $$props;
  let { start = 0 } = $$props;
  let { justify = "justify-between" } = $$props;
  let { buttonBack = "variant-ghost" } = $$props;
  let { buttonBackType = "button" } = $$props;
  let { buttonBackLabel = "&larr; Back" } = $$props;
  let { buttonNext = "variant-filled" } = $$props;
  let { buttonNextType = "button" } = $$props;
  let { buttonNextLabel = "Next &rarr;" } = $$props;
  let { buttonComplete = "variant-filled-primary" } = $$props;
  let { buttonCompleteType = "button" } = $$props;
  let { buttonCompleteLabel = "Complete" } = $$props;
  let { regionHeader = "" } = $$props;
  let { regionContent = "" } = $$props;
  let { transitions = !$prefersReducedMotionStore } = $$props;
  let { transitionIn = fade } = $$props;
  let { transitionInParams = { duration: 100 } } = $$props;
  let { transitionOut = fade } = $$props;
  let { transitionOutParams = { duration: 100 } } = $$props;
  let state = writable({ current: start, total: 0 });
  validate_store(state, "state");
  component_subscribe($$self, state, (value) => $$invalidate(7, $state = value));
  async function onNext(locked, stepIndex) {
    await new Promise((resolve) => setTimeout(resolve));
    if (locked)
      return;
    set_store_value(state, $state.current++, $state);
    dispatch("next", { step: stepIndex, state: $state });
    dispatch("step", { step: stepIndex, state: $state });
  }
  function onBack(stepIndex) {
    set_store_value(state, $state.current--, $state);
    dispatch("back", { step: stepIndex, state: $state });
    dispatch("step", { step: stepIndex, state: $state });
  }
  function onComplete(stepIndex) {
    dispatch("complete", { step: stepIndex, state: $state });
  }
  setContext("state", state);
  setContext("stepTerm", stepTerm);
  setContext("gap", gap);
  setContext("justify", justify);
  setContext("onNext", onNext);
  setContext("onBack", onBack);
  setContext("onComplete", onComplete);
  setContext("buttonBack", buttonBack);
  setContext("buttonBackType", buttonBackType);
  setContext("buttonBackLabel", buttonBackLabel);
  setContext("buttonNext", buttonNext);
  setContext("buttonNextType", buttonNextType);
  setContext("buttonNextLabel", buttonNextLabel);
  setContext("buttonComplete", buttonComplete);
  setContext("buttonCompleteType", buttonCompleteType);
  setContext("buttonCompleteLabel", buttonCompleteLabel);
  setContext("transitions", transitions);
  setContext("transitionIn", transitionIn);
  setContext("transitionInParams", transitionInParams);
  setContext("transitionOut", transitionOut);
  setContext("transitionOutParams", transitionOutParams);
  $$self.$$set = ($$new_props) => {
    $$invalidate(38, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("gap" in $$new_props)
      $$invalidate(14, gap = $$new_props.gap);
    if ("stepTerm" in $$new_props)
      $$invalidate(0, stepTerm = $$new_props.stepTerm);
    if ("badge" in $$new_props)
      $$invalidate(15, badge = $$new_props.badge);
    if ("active" in $$new_props)
      $$invalidate(16, active = $$new_props.active);
    if ("border" in $$new_props)
      $$invalidate(17, border = $$new_props.border);
    if ("start" in $$new_props)
      $$invalidate(18, start = $$new_props.start);
    if ("justify" in $$new_props)
      $$invalidate(19, justify = $$new_props.justify);
    if ("buttonBack" in $$new_props)
      $$invalidate(20, buttonBack = $$new_props.buttonBack);
    if ("buttonBackType" in $$new_props)
      $$invalidate(21, buttonBackType = $$new_props.buttonBackType);
    if ("buttonBackLabel" in $$new_props)
      $$invalidate(22, buttonBackLabel = $$new_props.buttonBackLabel);
    if ("buttonNext" in $$new_props)
      $$invalidate(23, buttonNext = $$new_props.buttonNext);
    if ("buttonNextType" in $$new_props)
      $$invalidate(24, buttonNextType = $$new_props.buttonNextType);
    if ("buttonNextLabel" in $$new_props)
      $$invalidate(25, buttonNextLabel = $$new_props.buttonNextLabel);
    if ("buttonComplete" in $$new_props)
      $$invalidate(26, buttonComplete = $$new_props.buttonComplete);
    if ("buttonCompleteType" in $$new_props)
      $$invalidate(27, buttonCompleteType = $$new_props.buttonCompleteType);
    if ("buttonCompleteLabel" in $$new_props)
      $$invalidate(28, buttonCompleteLabel = $$new_props.buttonCompleteLabel);
    if ("regionHeader" in $$new_props)
      $$invalidate(29, regionHeader = $$new_props.regionHeader);
    if ("regionContent" in $$new_props)
      $$invalidate(30, regionContent = $$new_props.regionContent);
    if ("transitions" in $$new_props)
      $$invalidate(1, transitions = $$new_props.transitions);
    if ("transitionIn" in $$new_props)
      $$invalidate(2, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$new_props)
      $$invalidate(3, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$new_props)
      $$invalidate(4, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$new_props)
      $$invalidate(5, transitionOutParams = $$new_props.transitionOutParams);
    if ("$$scope" in $$new_props)
      $$invalidate(31, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    fade,
    prefersReducedMotionStore,
    createEventDispatcher,
    setContext,
    writable,
    dynamicTransition,
    dispatch,
    gap,
    stepTerm,
    badge,
    active,
    border,
    start,
    justify,
    buttonBack,
    buttonBackType,
    buttonBackLabel,
    buttonNext,
    buttonNextType,
    buttonNextLabel,
    buttonComplete,
    buttonCompleteType,
    buttonCompleteLabel,
    regionHeader,
    regionContent,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    state,
    onNext,
    onBack,
    onComplete,
    cBase: cBase18,
    cHeader,
    cHeaderStep,
    cContent,
    classesContent,
    isActive,
    classesBadge,
    classesHeaderStep,
    classesHeader,
    classesBase,
    $state,
    $prefersReducedMotionStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(38, $$props = assign(assign({}, $$props), $$new_props));
    if ("gap" in $$props)
      $$invalidate(14, gap = $$new_props.gap);
    if ("stepTerm" in $$props)
      $$invalidate(0, stepTerm = $$new_props.stepTerm);
    if ("badge" in $$props)
      $$invalidate(15, badge = $$new_props.badge);
    if ("active" in $$props)
      $$invalidate(16, active = $$new_props.active);
    if ("border" in $$props)
      $$invalidate(17, border = $$new_props.border);
    if ("start" in $$props)
      $$invalidate(18, start = $$new_props.start);
    if ("justify" in $$props)
      $$invalidate(19, justify = $$new_props.justify);
    if ("buttonBack" in $$props)
      $$invalidate(20, buttonBack = $$new_props.buttonBack);
    if ("buttonBackType" in $$props)
      $$invalidate(21, buttonBackType = $$new_props.buttonBackType);
    if ("buttonBackLabel" in $$props)
      $$invalidate(22, buttonBackLabel = $$new_props.buttonBackLabel);
    if ("buttonNext" in $$props)
      $$invalidate(23, buttonNext = $$new_props.buttonNext);
    if ("buttonNextType" in $$props)
      $$invalidate(24, buttonNextType = $$new_props.buttonNextType);
    if ("buttonNextLabel" in $$props)
      $$invalidate(25, buttonNextLabel = $$new_props.buttonNextLabel);
    if ("buttonComplete" in $$props)
      $$invalidate(26, buttonComplete = $$new_props.buttonComplete);
    if ("buttonCompleteType" in $$props)
      $$invalidate(27, buttonCompleteType = $$new_props.buttonCompleteType);
    if ("buttonCompleteLabel" in $$props)
      $$invalidate(28, buttonCompleteLabel = $$new_props.buttonCompleteLabel);
    if ("regionHeader" in $$props)
      $$invalidate(29, regionHeader = $$new_props.regionHeader);
    if ("regionContent" in $$props)
      $$invalidate(30, regionContent = $$new_props.regionContent);
    if ("transitions" in $$props)
      $$invalidate(1, transitions = $$new_props.transitions);
    if ("transitionIn" in $$props)
      $$invalidate(2, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$props)
      $$invalidate(3, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$props)
      $$invalidate(4, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$props)
      $$invalidate(5, transitionOutParams = $$new_props.transitionOutParams);
    if ("state" in $$props)
      $$invalidate(13, state = $$new_props.state);
    if ("classesContent" in $$props)
      $$invalidate(8, classesContent = $$new_props.classesContent);
    if ("isActive" in $$props)
      $$invalidate(6, isActive = $$new_props.isActive);
    if ("classesBadge" in $$props)
      $$invalidate(9, classesBadge = $$new_props.classesBadge);
    if ("classesHeaderStep" in $$props)
      $$invalidate(10, classesHeaderStep = $$new_props.classesHeaderStep);
    if ("classesHeader" in $$props)
      $$invalidate(11, classesHeader = $$new_props.classesHeader);
    if ("classesBase" in $$props)
      $$invalidate(12, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$state*/
    128) {
      $:
        $$invalidate(6, isActive = (step) => step === $state.current);
    }
    $:
      $$invalidate(12, classesBase = `${cBase18} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*border, gap, regionHeader*/
    537018368) {
      $:
        $$invalidate(11, classesHeader = `${cHeader} ${border} ${gap} ${regionHeader}`);
    }
    if ($$self.$$.dirty[0] & /*isActive, active, badge*/
    98368) {
      $:
        $$invalidate(9, classesBadge = (step) => isActive(step) ? active : badge);
    }
    if ($$self.$$.dirty[0] & /*regionContent*/
    1073741824) {
      $:
        $$invalidate(8, classesContent = `${cContent} ${regionContent}`);
    }
  };
  $:
    $$invalidate(10, classesHeaderStep = `${cHeaderStep}`);
  $$props = exclude_internal_props($$props);
  return [
    stepTerm,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    isActive,
    $state,
    classesContent,
    classesBadge,
    classesHeaderStep,
    classesHeader,
    classesBase,
    state,
    gap,
    badge,
    active,
    border,
    start,
    justify,
    buttonBack,
    buttonBackType,
    buttonBackLabel,
    buttonNext,
    buttonNextType,
    buttonNextLabel,
    buttonComplete,
    buttonCompleteType,
    buttonCompleteLabel,
    regionHeader,
    regionContent,
    $$scope,
    slots
  ];
}
var Stepper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance24,
      create_fragment24,
      safe_not_equal,
      {
        gap: 14,
        stepTerm: 0,
        badge: 15,
        active: 16,
        border: 17,
        start: 18,
        justify: 19,
        buttonBack: 20,
        buttonBackType: 21,
        buttonBackLabel: 22,
        buttonNext: 23,
        buttonNextType: 24,
        buttonNextLabel: 25,
        buttonComplete: 26,
        buttonCompleteType: 27,
        buttonCompleteLabel: 28,
        regionHeader: 29,
        regionContent: 30,
        transitions: 1,
        transitionIn: 2,
        transitionInParams: 3,
        transitionOut: 4,
        transitionOutParams: 5
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Stepper",
      options,
      id: create_fragment24.name
    });
  }
  get gap() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepTerm() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stepTerm(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get badge() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set badge(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get start() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set start(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBack() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBack(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBackType() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBackType(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBackLabel() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBackLabel(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNext() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNext(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNextType() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNextType(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNextLabel() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNextLabel(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonComplete() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonComplete(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonCompleteType() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonCompleteType(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonCompleteLabel() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonCompleteLabel(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHeader() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHeader(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionContent() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionContent(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitions() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitions(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionIn() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionIn(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionInParams() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionInParams(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOut() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOut(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOutParams() {
    throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOutParams(value) {
    throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Stepper_default = Stepper;

// node_modules/@skeletonlabs/skeleton/dist/components/Stepper/Step.svelte
var file25 = "node_modules/@skeletonlabs/skeleton/dist/components/Stepper/Step.svelte";
var get_navigation_slot_changes = (dirty) => ({});
var get_navigation_slot_context = (ctx) => ({});
var get_header_slot_changes2 = (dirty) => ({});
var get_header_slot_context2 = (ctx) => ({});
function create_if_block18(ctx) {
  let div1;
  let header;
  let header_class_value;
  let t0;
  let div0;
  let div0_class_value;
  let t1;
  let div1_class_value;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[33].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[32],
    get_header_slot_context2
  );
  const header_slot_or_fallback = header_slot || fallback_block_13(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[33].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[32],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block5(ctx);
  let if_block = (
    /*$state*/
    ctx[24].total > 1 && create_if_block_110(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      header = element("header");
      if (header_slot_or_fallback)
        header_slot_or_fallback.c();
      t0 = space();
      div0 = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      header = claim_element(div1_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      if (header_slot_or_fallback)
        header_slot_or_fallback.l(header_nodes);
      header_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "class", header_class_value = "step-header " + /*classesHeader*/
      ctx[22]);
      add_location(header, file25, 50, 2, 2051);
      attr_dev(div0, "class", div0_class_value = "step-content " + /*classesContent*/
      ctx[21]);
      add_location(div0, file25, 54, 2, 2192);
      attr_dev(div1, "class", div1_class_value = "step " + /*classesBase*/
      ctx[23]);
      attr_dev(div1, "data-testid", "step");
      add_location(div1, file25, 48, 1, 1973);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, header);
      if (header_slot_or_fallback) {
        header_slot_or_fallback.m(header, null);
      }
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div0, null);
      }
      append_hydration_dev(div1, t1);
      if (if_block)
        if_block.m(div1, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[32]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[32],
              dirty,
              get_header_slot_changes2
            ),
            get_header_slot_context2
          );
        }
      } else {
        if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty[0] & /*stepTerm*/
        4)) {
          header_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*classesHeader*/
      4194304 && header_class_value !== (header_class_value = "step-header " + /*classesHeader*/
      ctx2[22])) {
        attr_dev(header, "class", header_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[32]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[32],
              dirty,
              null
            ),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & /*stepTerm*/
        4)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*classesContent*/
      2097152 && div0_class_value !== (div0_class_value = "step-content " + /*classesContent*/
      ctx2[21])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*$state*/
        ctx2[24].total > 1
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$state*/
          16777216) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_110(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classesBase*/
      8388608 && div1_class_value !== (div1_class_value = "step " + /*classesBase*/
      ctx2[23])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot_or_fallback, local);
      transition_in(default_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot_or_fallback, local);
      transition_out(default_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (header_slot_or_fallback)
        header_slot_or_fallback.d(detaching);
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block18.name,
    type: "if",
    source: "(48:0) {#if stepIndex === $state.current}",
    ctx
  });
  return block;
}
function fallback_block_13(ctx) {
  let t0;
  let t1;
  let t2_value = (
    /*stepIndex*/
    ctx[25] + 1 + ""
  );
  let t2;
  const block = {
    c: function create() {
      t0 = text(
        /*stepTerm*/
        ctx[2]
      );
      t1 = space();
      t2 = text(t2_value);
    },
    l: function claim(nodes) {
      t0 = claim_text(
        nodes,
        /*stepTerm*/
        ctx[2]
      );
      t1 = claim_space(nodes);
      t2 = claim_text(nodes, t2_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, t2, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*stepTerm*/
      4)
        set_data_dev(
          t0,
          /*stepTerm*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_13.name,
    type: "fallback",
    source: "(52:23) {stepTerm}",
    ctx
  });
  return block;
}
function fallback_block5(ctx) {
  let t0;
  let t1;
  let t2;
  let t3_value = (
    /*stepIndex*/
    ctx[25] + 1 + ""
  );
  let t3;
  let t4;
  const block = {
    c: function create() {
      t0 = text("(");
      t1 = text(
        /*stepTerm*/
        ctx[2]
      );
      t2 = space();
      t3 = text(t3_value);
      t4 = text(" Content)");
    },
    l: function claim(nodes) {
      t0 = claim_text(nodes, "(");
      t1 = claim_text(
        nodes,
        /*stepTerm*/
        ctx[2]
      );
      t2 = claim_space(nodes);
      t3 = claim_text(nodes, t3_value);
      t4 = claim_text(nodes, " Content)");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, t3, anchor);
      insert_hydration_dev(target, t4, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*stepTerm*/
      4)
        set_data_dev(
          t1,
          /*stepTerm*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(t3);
        detach_dev(t4);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block5.name,
    type: "fallback",
    source: "(56:9) (",
    ctx
  });
  return block;
}
function create_if_block_110(ctx) {
  let div;
  let current_block_type_index;
  let if_block0;
  let t;
  let div_class_value;
  let div_intro;
  let div_outro;
  let current;
  const if_block_creators = [create_if_block_44, create_else_block_13];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*stepIndex*/
      ctx2[25] === 0 && /*$$slots*/
      ctx2[26].navigation
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function select_block_type_1(ctx2, dirty) {
    if (
      /*stepIndex*/
      ctx2[25] < /*$state*/
      ctx2[24].total - 1
    )
      return create_if_block_29;
    return create_else_block7;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block1 = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block0.c();
      t = space();
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "step-navigation " + /*classesNavigation*/
      ctx[20]);
      add_location(div, file25, 59, 3, 2348);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      append_hydration_dev(div, t);
      if_block1.m(div, null);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block0.c();
        } else {
          if_block0.p(ctx, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(div, t);
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block1) {
        if_block1.p(ctx, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type(ctx);
        if (if_block1) {
          if_block1.c();
          if_block1.m(div, null);
        }
      }
      if (!current || dirty[0] & /*classesNavigation*/
      1048576 && div_class_value !== (div_class_value = "step-navigation " + /*classesNavigation*/
      ctx[20])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(div, dynamicTransition, {
            transition: (
              /*transitionIn*/
              ctx[16]
            ),
            params: (
              /*transitionInParams*/
              ctx[17]
            ),
            enabled: (
              /*transitions*/
              ctx[15]
            )
          });
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div, dynamicTransition, {
          transition: (
            /*transitionOut*/
            ctx[18]
          ),
          params: (
            /*transitionOutParams*/
            ctx[19]
          ),
          enabled: (
            /*transitions*/
            ctx[15]
          )
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
      if_block1.d();
      if (detaching && div_outro)
        div_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_110.name,
    type: "if",
    source: "(59:2) {#if $state.total > 1}",
    ctx
  });
  return block;
}
function create_else_block_13(ctx) {
  let button;
  let html_tag;
  let button_class_value;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      html_tag = claim_html_tag(button_nodes, false);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(
        button,
        "type",
        /*buttonBackType*/
        ctx[7]
      );
      attr_dev(button, "class", button_class_value = "btn " + /*buttonBack*/
      ctx[6]);
      button.disabled = button_disabled_value = /*$state*/
      ctx[24].current === 0;
      add_location(button, file25, 71, 5, 2841);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      html_tag.m(
        /*buttonBackLabel*/
        ctx[8],
        button
      );
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[34],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonBackLabel*/
      256)
        html_tag.p(
          /*buttonBackLabel*/
          ctx2[8]
        );
      if (dirty[0] & /*buttonBackType*/
      128) {
        attr_dev(
          button,
          "type",
          /*buttonBackType*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*buttonBack*/
      64 && button_class_value !== (button_class_value = "btn " + /*buttonBack*/
      ctx2[6])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty[0] & /*$state*/
      16777216 && button_disabled_value !== (button_disabled_value = /*$state*/
      ctx2[24].current === 0)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_13.name,
    type: "else",
    source: "(70:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_44(ctx) {
  let div;
  let current;
  const navigation_slot_template = (
    /*#slots*/
    ctx[33].navigation
  );
  const navigation_slot = create_slot(
    navigation_slot_template,
    ctx,
    /*$$scope*/
    ctx[32],
    get_navigation_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (navigation_slot)
        navigation_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (navigation_slot)
        navigation_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "step-navigation-slot");
      add_location(div, file25, 66, 5, 2717);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (navigation_slot) {
        navigation_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (navigation_slot) {
        if (navigation_slot.p && (!current || dirty[1] & /*$$scope*/
        2)) {
          update_slot_base(
            navigation_slot,
            navigation_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[32],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[32]
            ) : get_slot_changes(
              navigation_slot_template,
              /*$$scope*/
              ctx2[32],
              dirty,
              get_navigation_slot_changes
            ),
            get_navigation_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(navigation_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(navigation_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (navigation_slot)
        navigation_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_44.name,
    type: "if",
    source: "(65:4) {#if stepIndex === 0 && $$slots.navigation}",
    ctx
  });
  return block;
}
function create_else_block7(ctx) {
  let button;
  let html_tag;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      html_tag = claim_html_tag(button_nodes, false);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(
        button,
        "type",
        /*buttonCompleteType*/
        ctx[13]
      );
      attr_dev(button, "class", button_class_value = "btn " + /*buttonComplete*/
      ctx[12]);
      button.disabled = /*locked*/
      ctx[0];
      add_location(button, file25, 89, 5, 3718);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      html_tag.m(
        /*buttonCompleteLabel*/
        ctx[14],
        button
      );
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_2*/
          ctx[36],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonCompleteLabel*/
      16384)
        html_tag.p(
          /*buttonCompleteLabel*/
          ctx2[14]
        );
      if (dirty[0] & /*buttonCompleteType*/
      8192) {
        attr_dev(
          button,
          "type",
          /*buttonCompleteType*/
          ctx2[13]
        );
      }
      if (dirty[0] & /*buttonComplete*/
      4096 && button_class_value !== (button_class_value = "btn " + /*buttonComplete*/
      ctx2[12])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty[0] & /*locked*/
      1) {
        prop_dev(
          button,
          "disabled",
          /*locked*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block7.name,
    type: "else",
    source: "(88:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_29(ctx) {
  let button;
  let t;
  let span;
  let html_tag;
  let button_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*locked*/
    ctx[0] && create_if_block_35(ctx)
  );
  const block = {
    c: function create() {
      button = element("button");
      if (if_block)
        if_block.c();
      t = space();
      span = element("span");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      if (if_block)
        if_block.l(button_nodes);
      t = claim_space(button_nodes);
      span = claim_element(button_nodes, "SPAN", {});
      var span_nodes = children(span);
      html_tag = claim_html_tag(span_nodes, false);
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      add_location(span, file25, 85, 6, 3618);
      attr_dev(
        button,
        "type",
        /*buttonNextType*/
        ctx[10]
      );
      attr_dev(button, "class", button_class_value = "btn " + /*buttonNext*/
      ctx[9]);
      button.disabled = /*locked*/
      ctx[0];
      add_location(button, file25, 77, 5, 3090);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (if_block)
        if_block.m(button, null);
      append_hydration_dev(button, t);
      append_hydration_dev(button, span);
      html_tag.m(
        /*buttonNextLabel*/
        ctx[11],
        span
      );
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler_1*/
          ctx[35],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*locked*/
        ctx2[0]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_35(ctx2);
          if_block.c();
          if_block.m(button, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*buttonNextLabel*/
      2048)
        html_tag.p(
          /*buttonNextLabel*/
          ctx2[11]
        );
      if (dirty[0] & /*buttonNextType*/
      1024) {
        attr_dev(
          button,
          "type",
          /*buttonNextType*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*buttonNext*/
      512 && button_class_value !== (button_class_value = "btn " + /*buttonNext*/
      ctx2[9])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty[0] & /*locked*/
      1) {
        prop_dev(
          button,
          "disabled",
          /*locked*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_29.name,
    type: "if",
    source: "(76:4) {#if stepIndex < $state.total - 1}",
    ctx
  });
  return block;
}
function create_if_block_35(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { class: true, xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M144 144v48H304V144c0-44.2-35.8-80-80-80s-80 35.8-80 80zM80 192V144C80 64.5 144.5 0 224 0s144 64.5 144 144v48h16c35.3 0 64 28.7 64 64V448c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V256c0-35.3 28.7-64 64-64H80z");
      add_location(path, file25, 80, 8, 3343);
      attr_dev(svg, "class", "w-3 aspect-square fill-current");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 448 512");
      add_location(svg, file25, 79, 7, 3233);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_35.name,
    type: "if",
    source: "(79:6) {#if locked}",
    ctx
  });
  return block;
}
function create_fragment25(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*stepIndex*/
    ctx[25] === /*$state*/
    ctx[24].current && create_if_block18(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*stepIndex*/
        ctx2[25] === /*$state*/
        ctx2[24].current
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$state*/
          16777216) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block18(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase19 = "space-y-4";
var cHeader2 = "text-2xl font-bold";
var cContent2 = "space-y-4";
var cNavigation = "flex";
function instance25($$self, $$props, $$invalidate) {
  let classesBase;
  let classesHeader;
  let classesContent;
  let classesNavigation;
  let $state, $$unsubscribe_state = noop, $$subscribe_state = () => ($$unsubscribe_state(), $$unsubscribe_state = subscribe(state, ($$value) => $$invalidate(24, $state = $$value)), state);
  $$self.$$.on_destroy.push(() => $$unsubscribe_state());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Step", slots, ["header", "default", "navigation"]);
  const $$slots = compute_slots(slots);
  let { locked = false } = $$props;
  let { regionHeader = "" } = $$props;
  let { regionContent = "" } = $$props;
  let { regionNavigation = "" } = $$props;
  let { state = getContext("state") } = $$props;
  validate_store(state, "state");
  $$subscribe_state();
  let { stepTerm = getContext("stepTerm") } = $$props;
  let { gap = getContext("gap") } = $$props;
  let { justify = getContext("justify") } = $$props;
  let { onNext = getContext("onNext") } = $$props;
  let { onBack = getContext("onBack") } = $$props;
  let { onComplete = getContext("onComplete") } = $$props;
  let { buttonBack = getContext("buttonBack") } = $$props;
  let { buttonBackType = getContext("buttonBackType") } = $$props;
  let { buttonBackLabel = getContext("buttonBackLabel") } = $$props;
  let { buttonNext = getContext("buttonNext") } = $$props;
  let { buttonNextType = getContext("buttonNextType") } = $$props;
  let { buttonNextLabel = getContext("buttonNextLabel") } = $$props;
  let { buttonComplete = getContext("buttonComplete") } = $$props;
  let { buttonCompleteType = getContext("buttonCompleteType") } = $$props;
  let { buttonCompleteLabel = getContext("buttonCompleteLabel") } = $$props;
  let { transitions = getContext("transitions") } = $$props;
  let { transitionIn = getContext("transitionIn") } = $$props;
  let { transitionInParams = getContext("transitionInParams") } = $$props;
  let { transitionOut = getContext("transitionOut") } = $$props;
  let { transitionOutParams = getContext("transitionOutParams") } = $$props;
  const stepIndex = $state.total;
  set_store_value(state, $state.total++, $state);
  onDestroy(() => {
    set_store_value(state, $state.total--, $state);
  });
  const click_handler = () => onBack(stepIndex);
  const click_handler_1 = () => onNext(locked, stepIndex);
  const click_handler_2 = () => onComplete(stepIndex);
  $$self.$$set = ($$new_props) => {
    $$invalidate(37, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("locked" in $$new_props)
      $$invalidate(0, locked = $$new_props.locked);
    if ("regionHeader" in $$new_props)
      $$invalidate(27, regionHeader = $$new_props.regionHeader);
    if ("regionContent" in $$new_props)
      $$invalidate(28, regionContent = $$new_props.regionContent);
    if ("regionNavigation" in $$new_props)
      $$invalidate(29, regionNavigation = $$new_props.regionNavigation);
    if ("state" in $$new_props)
      $$subscribe_state($$invalidate(1, state = $$new_props.state));
    if ("stepTerm" in $$new_props)
      $$invalidate(2, stepTerm = $$new_props.stepTerm);
    if ("gap" in $$new_props)
      $$invalidate(30, gap = $$new_props.gap);
    if ("justify" in $$new_props)
      $$invalidate(31, justify = $$new_props.justify);
    if ("onNext" in $$new_props)
      $$invalidate(3, onNext = $$new_props.onNext);
    if ("onBack" in $$new_props)
      $$invalidate(4, onBack = $$new_props.onBack);
    if ("onComplete" in $$new_props)
      $$invalidate(5, onComplete = $$new_props.onComplete);
    if ("buttonBack" in $$new_props)
      $$invalidate(6, buttonBack = $$new_props.buttonBack);
    if ("buttonBackType" in $$new_props)
      $$invalidate(7, buttonBackType = $$new_props.buttonBackType);
    if ("buttonBackLabel" in $$new_props)
      $$invalidate(8, buttonBackLabel = $$new_props.buttonBackLabel);
    if ("buttonNext" in $$new_props)
      $$invalidate(9, buttonNext = $$new_props.buttonNext);
    if ("buttonNextType" in $$new_props)
      $$invalidate(10, buttonNextType = $$new_props.buttonNextType);
    if ("buttonNextLabel" in $$new_props)
      $$invalidate(11, buttonNextLabel = $$new_props.buttonNextLabel);
    if ("buttonComplete" in $$new_props)
      $$invalidate(12, buttonComplete = $$new_props.buttonComplete);
    if ("buttonCompleteType" in $$new_props)
      $$invalidate(13, buttonCompleteType = $$new_props.buttonCompleteType);
    if ("buttonCompleteLabel" in $$new_props)
      $$invalidate(14, buttonCompleteLabel = $$new_props.buttonCompleteLabel);
    if ("transitions" in $$new_props)
      $$invalidate(15, transitions = $$new_props.transitions);
    if ("transitionIn" in $$new_props)
      $$invalidate(16, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$new_props)
      $$invalidate(17, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$new_props)
      $$invalidate(18, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$new_props)
      $$invalidate(19, transitionOutParams = $$new_props.transitionOutParams);
    if ("$$scope" in $$new_props)
      $$invalidate(32, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    onDestroy,
    dynamicTransition,
    locked,
    regionHeader,
    regionContent,
    regionNavigation,
    state,
    stepTerm,
    gap,
    justify,
    onNext,
    onBack,
    onComplete,
    buttonBack,
    buttonBackType,
    buttonBackLabel,
    buttonNext,
    buttonNextType,
    buttonNextLabel,
    buttonComplete,
    buttonCompleteType,
    buttonCompleteLabel,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    stepIndex,
    cBase: cBase19,
    cHeader: cHeader2,
    cContent: cContent2,
    cNavigation,
    classesNavigation,
    classesContent,
    classesHeader,
    classesBase,
    $state
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(37, $$props = assign(assign({}, $$props), $$new_props));
    if ("locked" in $$props)
      $$invalidate(0, locked = $$new_props.locked);
    if ("regionHeader" in $$props)
      $$invalidate(27, regionHeader = $$new_props.regionHeader);
    if ("regionContent" in $$props)
      $$invalidate(28, regionContent = $$new_props.regionContent);
    if ("regionNavigation" in $$props)
      $$invalidate(29, regionNavigation = $$new_props.regionNavigation);
    if ("state" in $$props)
      $$subscribe_state($$invalidate(1, state = $$new_props.state));
    if ("stepTerm" in $$props)
      $$invalidate(2, stepTerm = $$new_props.stepTerm);
    if ("gap" in $$props)
      $$invalidate(30, gap = $$new_props.gap);
    if ("justify" in $$props)
      $$invalidate(31, justify = $$new_props.justify);
    if ("onNext" in $$props)
      $$invalidate(3, onNext = $$new_props.onNext);
    if ("onBack" in $$props)
      $$invalidate(4, onBack = $$new_props.onBack);
    if ("onComplete" in $$props)
      $$invalidate(5, onComplete = $$new_props.onComplete);
    if ("buttonBack" in $$props)
      $$invalidate(6, buttonBack = $$new_props.buttonBack);
    if ("buttonBackType" in $$props)
      $$invalidate(7, buttonBackType = $$new_props.buttonBackType);
    if ("buttonBackLabel" in $$props)
      $$invalidate(8, buttonBackLabel = $$new_props.buttonBackLabel);
    if ("buttonNext" in $$props)
      $$invalidate(9, buttonNext = $$new_props.buttonNext);
    if ("buttonNextType" in $$props)
      $$invalidate(10, buttonNextType = $$new_props.buttonNextType);
    if ("buttonNextLabel" in $$props)
      $$invalidate(11, buttonNextLabel = $$new_props.buttonNextLabel);
    if ("buttonComplete" in $$props)
      $$invalidate(12, buttonComplete = $$new_props.buttonComplete);
    if ("buttonCompleteType" in $$props)
      $$invalidate(13, buttonCompleteType = $$new_props.buttonCompleteType);
    if ("buttonCompleteLabel" in $$props)
      $$invalidate(14, buttonCompleteLabel = $$new_props.buttonCompleteLabel);
    if ("transitions" in $$props)
      $$invalidate(15, transitions = $$new_props.transitions);
    if ("transitionIn" in $$props)
      $$invalidate(16, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$props)
      $$invalidate(17, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$props)
      $$invalidate(18, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$props)
      $$invalidate(19, transitionOutParams = $$new_props.transitionOutParams);
    if ("classesNavigation" in $$props)
      $$invalidate(20, classesNavigation = $$new_props.classesNavigation);
    if ("classesContent" in $$props)
      $$invalidate(21, classesContent = $$new_props.classesContent);
    if ("classesHeader" in $$props)
      $$invalidate(22, classesHeader = $$new_props.classesHeader);
    if ("classesBase" in $$props)
      $$invalidate(23, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(23, classesBase = `${cBase19} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*regionHeader*/
    134217728) {
      $:
        $$invalidate(22, classesHeader = `${cHeader2} ${regionHeader}`);
    }
    if ($$self.$$.dirty[0] & /*regionContent*/
    268435456) {
      $:
        $$invalidate(21, classesContent = `${cContent2} ${regionContent}`);
    }
    if ($$self.$$.dirty[0] & /*gap, regionNavigation*/
    1610612736 | $$self.$$.dirty[1] & /*justify*/
    1) {
      $:
        $$invalidate(20, classesNavigation = `${cNavigation} ${justify} ${gap} ${regionNavigation}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    locked,
    state,
    stepTerm,
    onNext,
    onBack,
    onComplete,
    buttonBack,
    buttonBackType,
    buttonBackLabel,
    buttonNext,
    buttonNextType,
    buttonNextLabel,
    buttonComplete,
    buttonCompleteType,
    buttonCompleteLabel,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    classesNavigation,
    classesContent,
    classesHeader,
    classesBase,
    $state,
    stepIndex,
    $$slots,
    regionHeader,
    regionContent,
    regionNavigation,
    gap,
    justify,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
var Step = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance25,
      create_fragment25,
      safe_not_equal,
      {
        locked: 0,
        regionHeader: 27,
        regionContent: 28,
        regionNavigation: 29,
        state: 1,
        stepTerm: 2,
        gap: 30,
        justify: 31,
        onNext: 3,
        onBack: 4,
        onComplete: 5,
        buttonBack: 6,
        buttonBackType: 7,
        buttonBackLabel: 8,
        buttonNext: 9,
        buttonNextType: 10,
        buttonNextLabel: 11,
        buttonComplete: 12,
        buttonCompleteType: 13,
        buttonCompleteLabel: 14,
        transitions: 15,
        transitionIn: 16,
        transitionInParams: 17,
        transitionOut: 18,
        transitionOutParams: 19
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Step",
      options,
      id: create_fragment25.name
    });
  }
  get locked() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locked(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHeader() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHeader(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionContent() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionContent(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionNavigation() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionNavigation(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get state() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set state(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stepTerm() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stepTerm(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gap() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gap(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get justify() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onNext() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onNext(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBack() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBack(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onComplete() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onComplete(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBack() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBack(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBackType() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBackType(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonBackLabel() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonBackLabel(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNext() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNext(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNextType() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNextType(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNextLabel() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNextLabel(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonComplete() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonComplete(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonCompleteType() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonCompleteType(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonCompleteLabel() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonCompleteLabel(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitions() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitions(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionIn() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionIn(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionInParams() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionInParams(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOut() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOut(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOutParams() {
    throw new Error("<Step>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOutParams(value) {
    throw new Error("<Step>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Step_default = Step;

// node_modules/@skeletonlabs/skeleton/dist/components/Table/actions.js
function tableA11y(node) {
  const keyWhitelist = ["ArrowRight", "ArrowUp", "ArrowLeft", "ArrowDown", "Home", "End"];
  const onKeyDown2 = (event) => {
    if (keyWhitelist.includes(event.code)) {
      event.preventDefault();
      switch (event.code) {
        case "ArrowUp":
          a11ySetActiveCell(node, 0, -1);
          break;
        case "ArrowDown":
          a11ySetActiveCell(node, 0, 1);
          break;
        case "ArrowLeft":
          a11ySetActiveCell(node, -1, 0);
          break;
        case "ArrowRight":
          a11ySetActiveCell(node, 1, 0);
          break;
        case "Home":
          a11yJumpToOuterColumn(node, "first");
          break;
        case "End":
          a11yJumpToOuterColumn(node, "last");
          break;
        default:
          break;
      }
    }
  };
  node.addEventListener("keydown", onKeyDown2);
  return {
    destroy() {
      node.removeEventListener("keydown", onKeyDown2);
    }
  };
}
function a11ySetActiveCell(node, x, y) {
  const focusedElem = document.activeElement;
  if (!focusedElem || !focusedElem.parentElement || !focusedElem.parentElement.ariaRowIndex || !focusedElem.ariaColIndex)
    return;
  const focusedElemRowIndex = parseInt(focusedElem.parentElement.ariaRowIndex);
  const focusedElemColIndex = parseInt(focusedElem.ariaColIndex);
  const targetRowElement = node.querySelector(`[aria-rowindex="${focusedElemRowIndex + y}"]`);
  if (targetRowElement !== null) {
    const targetColElement = targetRowElement.querySelector(`[aria-colindex="${focusedElemColIndex + x}"]`);
    if (targetColElement !== null)
      targetColElement.focus();
  }
}
function a11yGetTargetElem(node) {
  const focusedElem = document.activeElement;
  if (!focusedElem || !focusedElem.parentElement || !focusedElem.parentElement.ariaRowIndex)
    return null;
  const focusedElemRowIndex = parseInt(focusedElem.parentElement.ariaRowIndex);
  return node.querySelector(`[aria-rowindex="${focusedElemRowIndex}"]`);
}
function a11yJumpToOuterColumn(node, type = "first") {
  const targetRowElement = a11yGetTargetElem(node);
  if (targetRowElement === null)
    return;
  const lastIndex = targetRowElement.children.length;
  const selected = type === "first" ? 1 : lastIndex;
  const targetColElement = targetRowElement.querySelector(`[aria-colindex="${selected}"]`);
  if (targetColElement === null)
    return;
  targetColElement.focus();
}

// node_modules/@skeletonlabs/skeleton/dist/components/Table/Table.svelte
var file26 = "node_modules/@skeletonlabs/skeleton/dist/components/Table/Table.svelte";
function get_each_context8(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  child_ctx[24] = i;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  child_ctx[26] = i;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  return child_ctx;
}
function create_each_block_3(ctx) {
  let th;
  let html_tag;
  let raw_value = (
    /*heading*/
    ctx[27] + ""
  );
  const block = {
    c: function create() {
      th = element("th");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true, role: true });
      var th_nodes = children(th);
      html_tag = claim_html_tag(th_nodes, false);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(
        th,
        "class",
        /*regionHeadCell*/
        ctx[3]
      );
      attr_dev(th, "role", "columnheader");
      add_location(th, file26, 46, 5, 1303);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      html_tag.m(raw_value, th);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*source*/
      1 && raw_value !== (raw_value = /*heading*/
      ctx2[27] + ""))
        html_tag.p(raw_value);
      if (dirty & /*regionHeadCell*/
      8) {
        attr_dev(
          th,
          "class",
          /*regionHeadCell*/
          ctx2[3]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(46:4) {#each source.head as heading }",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let td;
  let html_tag;
  let raw_value = (Number(
    /*cell*/
    ctx[19]
  ) === 0 ? (
    /*cell*/
    ctx[19]
  ) : (
    /*cell*/
    ctx[19] ? (
      /*cell*/
      ctx[19]
    ) : "-"
  )) + "";
  let td_aria_colindex_value;
  let td_tabindex_value;
  const block = {
    c: function create() {
      td = element("td");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", {
        class: true,
        role: true,
        "aria-colindex": true,
        tabindex: true
      });
      var td_nodes = children(td);
      html_tag = claim_html_tag(td_nodes, false);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(
        td,
        "class",
        /*regionCell*/
        ctx[5]
      );
      attr_dev(td, "role", "gridcell");
      attr_dev(td, "aria-colindex", td_aria_colindex_value = /*cellIndex*/
      ctx[26] + 1);
      attr_dev(td, "tabindex", td_tabindex_value = /*cellIndex*/
      ctx[26] === 0 && /*interactive*/
      ctx[1] ? 0 : -1);
      add_location(td, file26, 62, 6, 1767);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      html_tag.m(raw_value, td);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*source*/
      1 && raw_value !== (raw_value = (Number(
        /*cell*/
        ctx2[19]
      ) === 0 ? (
        /*cell*/
        ctx2[19]
      ) : (
        /*cell*/
        ctx2[19] ? (
          /*cell*/
          ctx2[19]
        ) : "-"
      )) + ""))
        html_tag.p(raw_value);
      if (dirty & /*regionCell*/
      32) {
        attr_dev(
          td,
          "class",
          /*regionCell*/
          ctx2[5]
        );
      }
      if (dirty & /*interactive*/
      2 && td_tabindex_value !== (td_tabindex_value = /*cellIndex*/
      ctx2[26] === 0 && /*interactive*/
      ctx2[1] ? 0 : -1)) {
        attr_dev(td, "tabindex", td_tabindex_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(61:5) {#each row as cell, cellIndex}",
    ctx
  });
  return block;
}
function create_each_block_13(ctx) {
  let tr;
  let t;
  let tr_aria_rowindex_value;
  let mounted;
  let dispose;
  let each_value_2 = ensure_array_like_dev(
    /*row*/
    ctx[22]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[15](
        /*rowIndex*/
        ctx[24],
        ...args
      )
    );
  }
  function keydown_handler(...args) {
    return (
      /*keydown_handler*/
      ctx[16](
        /*rowIndex*/
        ctx[24],
        ...args
      )
    );
  }
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { "aria-rowindex": true });
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(tr, "aria-rowindex", tr_aria_rowindex_value = /*rowIndex*/
      ctx[24] + 1);
      add_location(tr, file26, 55, 4, 1553);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append_hydration_dev(tr, t);
      if (!mounted) {
        dispose = [
          listen_dev(tr, "click", click_handler, false, false, false, false),
          listen_dev(tr, "keydown", keydown_handler, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*regionCell, interactive, Number, source*/
      35) {
        each_value_2 = ensure_array_like_dev(
          /*row*/
          ctx[22]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_13.name,
    type: "each",
    source: "(53:3) {#each source.body as row, rowIndex}",
    ctx
  });
  return block;
}
function create_if_block19(ctx) {
  let tfoot;
  let tr;
  let tfoot_class_value;
  let each_value = ensure_array_like_dev(
    /*source*/
    ctx[0].foot
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block8(get_each_context8(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      tfoot = element("tfoot");
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      tfoot = claim_element(nodes, "TFOOT", { class: true });
      var tfoot_nodes = children(tfoot);
      tr = claim_element(tfoot_nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach_dev);
      tfoot_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file26, 77, 4, 2128);
      attr_dev(tfoot, "class", tfoot_class_value = "table-foot " + /*regionFoot*/
      ctx[6]);
      add_location(tfoot, file26, 76, 3, 2084);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tfoot, anchor);
      append_hydration_dev(tfoot, tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*regionFootCell, source*/
      129) {
        each_value = ensure_array_like_dev(
          /*source*/
          ctx2[0].foot
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context8(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block8(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*regionFoot*/
      64 && tfoot_class_value !== (tfoot_class_value = "table-foot " + /*regionFoot*/
      ctx2[6])) {
        attr_dev(tfoot, "class", tfoot_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tfoot);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block19.name,
    type: "if",
    source: "(76:2) {#if source.foot}",
    ctx
  });
  return block;
}
function create_each_block8(ctx) {
  let td;
  let html_tag;
  let raw_value = (
    /*cell*/
    ctx[19] + ""
  );
  const block = {
    c: function create() {
      td = element("td");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      html_tag = claim_html_tag(td_nodes, false);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(
        td,
        "class",
        /*regionFootCell*/
        ctx[7]
      );
      add_location(td, file26, 79, 6, 2173);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      html_tag.m(raw_value, td);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*source*/
      1 && raw_value !== (raw_value = /*cell*/
      ctx2[19] + ""))
        html_tag.p(raw_value);
      if (dirty & /*regionFootCell*/
      128) {
        attr_dev(
          td,
          "class",
          /*regionFootCell*/
          ctx2[7]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block8.name,
    type: "each",
    source: "(79:5) {#each source.foot as cell }",
    ctx
  });
  return block;
}
function create_fragment26(ctx) {
  let div;
  let table;
  let thead;
  let tr;
  let thead_class_value;
  let t0;
  let tbody;
  let tbody_class_value;
  let t1;
  let table_role_value;
  let tableA11y_action;
  let div_class_value;
  let mounted;
  let dispose;
  let each_value_3 = ensure_array_like_dev(
    /*source*/
    ctx[0].head
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let each_value_1 = ensure_array_like_dev(
    /*source*/
    ctx[0].body
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  let if_block = (
    /*source*/
    ctx[0].foot && create_if_block19(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t0 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      table = claim_element(div_nodes, "TABLE", { class: true, role: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", { class: true });
      var thead_nodes = children(thead);
      tr = claim_element(thead_nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(tr_nodes);
      }
      tr_nodes.forEach(detach_dev);
      thead_nodes.forEach(detach_dev);
      t0 = claim_space(table_nodes);
      tbody = claim_element(table_nodes, "TBODY", { class: true });
      var tbody_nodes = children(tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tbody_nodes);
      }
      tbody_nodes.forEach(detach_dev);
      t1 = claim_space(table_nodes);
      if (if_block)
        if_block.l(table_nodes);
      table_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file26, 44, 3, 1257);
      attr_dev(thead, "class", thead_class_value = "table-head " + /*regionHead*/
      ctx[2]);
      add_location(thead, file26, 43, 2, 1214);
      attr_dev(tbody, "class", tbody_class_value = "table-body " + /*regionBody*/
      ctx[4]);
      add_location(tbody, file26, 51, 2, 1423);
      attr_dev(
        table,
        "class",
        /*classesTable*/
        ctx[8]
      );
      attr_dev(table, "role", table_role_value = /*interactive*/
      ctx[1] ? "grid" : "table");
      toggle_class(
        table,
        "table-interactive",
        /*interactive*/
        ctx[1]
      );
      add_location(table, file26, 35, 1, 1005);
      attr_dev(div, "class", div_class_value = "table-container " + /*classesBase*/
      ctx[9]);
      add_location(div, file26, 32, 0, 918);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, table);
      append_hydration_dev(table, thead);
      append_hydration_dev(thead, tr);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(tr, null);
        }
      }
      append_hydration_dev(table, t0);
      append_hydration_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tbody, null);
        }
      }
      append_hydration_dev(table, t1);
      if (if_block)
        if_block.m(table, null);
      if (!mounted) {
        dispose = action_destroyer(tableA11y_action = tableA11y.call(null, table));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*regionHeadCell, source*/
      9) {
        each_value_3 = ensure_array_like_dev(
          /*source*/
          ctx2[0].head
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_3(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(tr, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_3.length;
      }
      if (dirty & /*regionHead*/
      4 && thead_class_value !== (thead_class_value = "table-head " + /*regionHead*/
      ctx2[2])) {
        attr_dev(thead, "class", thead_class_value);
      }
      if (dirty & /*onRowClick, onRowKeydown, source, regionCell, interactive, Number*/
      3107) {
        each_value_1 = ensure_array_like_dev(
          /*source*/
          ctx2[0].body
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_13(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tbody, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*regionBody*/
      16 && tbody_class_value !== (tbody_class_value = "table-body " + /*regionBody*/
      ctx2[4])) {
        attr_dev(tbody, "class", tbody_class_value);
      }
      if (
        /*source*/
        ctx2[0].foot
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block19(ctx2);
          if_block.c();
          if_block.m(table, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*classesTable*/
      256) {
        attr_dev(
          table,
          "class",
          /*classesTable*/
          ctx2[8]
        );
      }
      if (dirty & /*interactive*/
      2 && table_role_value !== (table_role_value = /*interactive*/
      ctx2[1] ? "grid" : "table")) {
        attr_dev(table, "role", table_role_value);
      }
      if (dirty & /*classesTable, interactive*/
      258) {
        toggle_class(
          table,
          "table-interactive",
          /*interactive*/
          ctx2[1]
        );
      }
      if (dirty & /*classesBase*/
      512 && div_class_value !== (div_class_value = "table-container " + /*classesBase*/
      ctx2[9])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let classesBase;
  let classesTable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, []);
  const dispatch = createEventDispatcher();
  let { source } = $$props;
  let { interactive = false } = $$props;
  let { element: element2 = "table" } = $$props;
  let { text: text2 = "" } = $$props;
  let { color = "" } = $$props;
  let { regionHead = "" } = $$props;
  let { regionHeadCell = "" } = $$props;
  let { regionBody = "" } = $$props;
  let { regionCell = "" } = $$props;
  let { regionFoot = "" } = $$props;
  let { regionFootCell = "" } = $$props;
  function onRowClick(event, rowIndex) {
    if (!interactive)
      return;
    event.preventDefault();
    event.stopPropagation();
    const rowMetaData = source.meta ? source.meta[rowIndex] : source.body[rowIndex];
    dispatch("selected", rowMetaData);
  }
  function onRowKeydown(event, rowIndex) {
    if (["Enter", "Space"].includes(event.code))
      onRowClick(event, rowIndex);
  }
  $$self.$$.on_mount.push(function() {
    if (source === void 0 && !("source" in $$props || $$self.$$.bound[$$self.$$.props["source"]])) {
      console.warn("<Table> was created without expected prop 'source'");
    }
  });
  const click_handler = (rowIndex, e) => {
    onRowClick(e, rowIndex);
  };
  const keydown_handler = (rowIndex, e) => {
    onRowKeydown(e, rowIndex);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("source" in $$new_props)
      $$invalidate(0, source = $$new_props.source);
    if ("interactive" in $$new_props)
      $$invalidate(1, interactive = $$new_props.interactive);
    if ("element" in $$new_props)
      $$invalidate(12, element2 = $$new_props.element);
    if ("text" in $$new_props)
      $$invalidate(13, text2 = $$new_props.text);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("regionHead" in $$new_props)
      $$invalidate(2, regionHead = $$new_props.regionHead);
    if ("regionHeadCell" in $$new_props)
      $$invalidate(3, regionHeadCell = $$new_props.regionHeadCell);
    if ("regionBody" in $$new_props)
      $$invalidate(4, regionBody = $$new_props.regionBody);
    if ("regionCell" in $$new_props)
      $$invalidate(5, regionCell = $$new_props.regionCell);
    if ("regionFoot" in $$new_props)
      $$invalidate(6, regionFoot = $$new_props.regionFoot);
    if ("regionFootCell" in $$new_props)
      $$invalidate(7, regionFootCell = $$new_props.regionFootCell);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    tableA11y,
    dispatch,
    source,
    interactive,
    element: element2,
    text: text2,
    color,
    regionHead,
    regionHeadCell,
    regionBody,
    regionCell,
    regionFoot,
    regionFootCell,
    onRowClick,
    onRowKeydown,
    classesTable,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("source" in $$props)
      $$invalidate(0, source = $$new_props.source);
    if ("interactive" in $$props)
      $$invalidate(1, interactive = $$new_props.interactive);
    if ("element" in $$props)
      $$invalidate(12, element2 = $$new_props.element);
    if ("text" in $$props)
      $$invalidate(13, text2 = $$new_props.text);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("regionHead" in $$props)
      $$invalidate(2, regionHead = $$new_props.regionHead);
    if ("regionHeadCell" in $$props)
      $$invalidate(3, regionHeadCell = $$new_props.regionHeadCell);
    if ("regionBody" in $$props)
      $$invalidate(4, regionBody = $$new_props.regionBody);
    if ("regionCell" in $$props)
      $$invalidate(5, regionCell = $$new_props.regionCell);
    if ("regionFoot" in $$props)
      $$invalidate(6, regionFoot = $$new_props.regionFoot);
    if ("regionFootCell" in $$props)
      $$invalidate(7, regionFootCell = $$new_props.regionFootCell);
    if ("classesTable" in $$props)
      $$invalidate(8, classesTable = $$new_props.classesTable);
    if ("classesBase" in $$props)
      $$invalidate(9, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(9, classesBase = `${$$props.class || ""}`);
    if ($$self.$$.dirty & /*element, text, color*/
    28672) {
      $:
        $$invalidate(8, classesTable = `${element2} ${text2} ${color}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    source,
    interactive,
    regionHead,
    regionHeadCell,
    regionBody,
    regionCell,
    regionFoot,
    regionFootCell,
    classesTable,
    classesBase,
    onRowClick,
    onRowKeydown,
    element2,
    text2,
    color,
    click_handler,
    keydown_handler
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, {
      source: 0,
      interactive: 1,
      element: 12,
      text: 13,
      color: 14,
      regionHead: 2,
      regionHeadCell: 3,
      regionBody: 4,
      regionCell: 5,
      regionFoot: 6,
      regionFootCell: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment26.name
    });
  }
  get source() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set source(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get interactive() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set interactive(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get element() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set element(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHead() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHead(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHeadCell() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHeadCell(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBody() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBody(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionCell() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionCell(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionFoot() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionFoot(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionFootCell() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionFootCell(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/@skeletonlabs/skeleton/dist/components/Tab/TabGroup.svelte
var file27 = "node_modules/@skeletonlabs/skeleton/dist/components/Tab/TabGroup.svelte";
var get_panel_slot_changes = (dirty) => ({});
var get_panel_slot_context = (ctx) => ({});
function create_if_block20(ctx) {
  let div;
  let div_class_value;
  let current;
  const panel_slot_template = (
    /*#slots*/
    ctx[17].panel
  );
  const panel_slot = create_slot(
    panel_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    get_panel_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (panel_slot)
        panel_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-labelledby": true,
        tabindex: true
      });
      var div_nodes = children(div);
      if (panel_slot)
        panel_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "tab-panel " + /*classesPanel*/
      ctx[2]);
      attr_dev(div, "role", "tabpanel");
      attr_dev(
        div,
        "aria-labelledby",
        /*panel*/
        ctx[1]
      );
      attr_dev(div, "tabindex", "0");
      add_location(div, file27, 39, 2, 1353);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (panel_slot) {
        panel_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (panel_slot) {
        if (panel_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            panel_slot,
            panel_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              panel_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              get_panel_slot_changes
            ),
            get_panel_slot_context
          );
        }
      }
      if (!current || dirty & /*classesPanel*/
      4 && div_class_value !== (div_class_value = "tab-panel " + /*classesPanel*/
      ctx2[2])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*panel*/
      2) {
        attr_dev(
          div,
          "aria-labelledby",
          /*panel*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(panel_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(panel_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (panel_slot)
        panel_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block20.name,
    type: "if",
    source: "(39:1) {#if $$slots.panel}",
    ctx
  });
  return block;
}
function create_fragment27(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let t;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[16],
    null
  );
  let if_block = (
    /*$$slots*/
    ctx[5].panel && create_if_block20(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        role: true,
        "aria-labelledby": true
      });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "tab-list " + /*classesList*/
      ctx[3]);
      attr_dev(div0, "role", "tablist");
      attr_dev(
        div0,
        "aria-labelledby",
        /*labelledby*/
        ctx[0]
      );
      add_location(div0, file27, 34, 1, 1210);
      attr_dev(div1, "class", div1_class_value = "tab-group " + /*classesBase*/
      ctx[4]);
      attr_dev(div1, "data-testid", "tab-group");
      add_location(div1, file27, 32, 0, 1087);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration_dev(div1, t);
      if (if_block)
        if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keypress",
            /*keypress_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*keydown_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keyup",
            /*keyup_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[16],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[16]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[16],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesList*/
      8 && div0_class_value !== (div0_class_value = "tab-list " + /*classesList*/
      ctx2[3])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*labelledby*/
      1) {
        attr_dev(
          div0,
          "aria-labelledby",
          /*labelledby*/
          ctx2[0]
        );
      }
      if (
        /*$$slots*/
        ctx2[5].panel
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block20(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      16 && div1_class_value !== (div1_class_value = "tab-group " + /*classesBase*/
      ctx2[4])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase20 = "space-y-4";
var cList = "flex overflow-x-auto hide-scrollbar";
var cPanel2 = "";
function instance27($$self, $$props, $$invalidate) {
  let classesBase;
  let classesList;
  let classesPanel;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabGroup", slots, ["default", "panel"]);
  const $$slots = compute_slots(slots);
  let { justify = "justify-start" } = $$props;
  let { border = "border-b border-surface-400-500-token" } = $$props;
  let { active = "border-b-2 border-surface-900-50-token" } = $$props;
  let { hover = "hover:variant-soft" } = $$props;
  let { flex = "flex-none" } = $$props;
  let { padding = "px-4 py-2" } = $$props;
  let { rounded = "rounded-tl-container-token rounded-tr-container-token" } = $$props;
  let { spacing = "space-y-1" } = $$props;
  let { regionList = "" } = $$props;
  let { regionPanel = "" } = $$props;
  let { labelledby = "" } = $$props;
  let { panel = "" } = $$props;
  setContext("active", active);
  setContext("hover", hover);
  setContext("flex", flex);
  setContext("padding", padding);
  setContext("rounded", rounded);
  setContext("spacing", spacing);
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("justify" in $$new_props)
      $$invalidate(6, justify = $$new_props.justify);
    if ("border" in $$new_props)
      $$invalidate(7, border = $$new_props.border);
    if ("active" in $$new_props)
      $$invalidate(8, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("flex" in $$new_props)
      $$invalidate(10, flex = $$new_props.flex);
    if ("padding" in $$new_props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("spacing" in $$new_props)
      $$invalidate(13, spacing = $$new_props.spacing);
    if ("regionList" in $$new_props)
      $$invalidate(14, regionList = $$new_props.regionList);
    if ("regionPanel" in $$new_props)
      $$invalidate(15, regionPanel = $$new_props.regionPanel);
    if ("labelledby" in $$new_props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("panel" in $$new_props)
      $$invalidate(1, panel = $$new_props.panel);
    if ("$$scope" in $$new_props)
      $$invalidate(16, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    justify,
    border,
    active,
    hover,
    flex,
    padding,
    rounded,
    spacing,
    regionList,
    regionPanel,
    labelledby,
    panel,
    cBase: cBase20,
    cList,
    cPanel: cPanel2,
    classesPanel,
    classesList,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
    if ("justify" in $$props)
      $$invalidate(6, justify = $$new_props.justify);
    if ("border" in $$props)
      $$invalidate(7, border = $$new_props.border);
    if ("active" in $$props)
      $$invalidate(8, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(9, hover = $$new_props.hover);
    if ("flex" in $$props)
      $$invalidate(10, flex = $$new_props.flex);
    if ("padding" in $$props)
      $$invalidate(11, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("spacing" in $$props)
      $$invalidate(13, spacing = $$new_props.spacing);
    if ("regionList" in $$props)
      $$invalidate(14, regionList = $$new_props.regionList);
    if ("regionPanel" in $$props)
      $$invalidate(15, regionPanel = $$new_props.regionPanel);
    if ("labelledby" in $$props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("panel" in $$props)
      $$invalidate(1, panel = $$new_props.panel);
    if ("classesPanel" in $$props)
      $$invalidate(2, classesPanel = $$new_props.classesPanel);
    if ("classesList" in $$props)
      $$invalidate(3, classesList = $$new_props.classesList);
    if ("classesBase" in $$props)
      $$invalidate(4, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, classesBase = `${cBase20} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*justify, border, regionList*/
    16576) {
      $:
        $$invalidate(3, classesList = `${cList} ${justify} ${border} ${regionList}`);
    }
    if ($$self.$$.dirty & /*regionPanel*/
    32768) {
      $:
        $$invalidate(2, classesPanel = `${cPanel2} ${regionPanel}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    labelledby,
    panel,
    classesPanel,
    classesList,
    classesBase,
    $$slots,
    justify,
    border,
    active,
    hover,
    flex,
    padding,
    rounded,
    spacing,
    regionList,
    regionPanel,
    $$scope,
    slots,
    click_handler,
    keypress_handler,
    keydown_handler,
    keyup_handler
  ];
}
var TabGroup = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, {
      justify: 6,
      border: 7,
      active: 8,
      hover: 9,
      flex: 10,
      padding: 11,
      rounded: 12,
      spacing: 13,
      regionList: 14,
      regionPanel: 15,
      labelledby: 0,
      panel: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabGroup",
      options,
      id: create_fragment27.name
    });
  }
  get justify() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set justify(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flex() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flex(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionList() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionList(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionPanel() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionPanel(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get panel() {
    throw new Error("<TabGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set panel(value) {
    throw new Error("<TabGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabGroup_default = TabGroup;

// node_modules/@skeletonlabs/skeleton/dist/components/Tab/Tab.svelte
var file28 = "node_modules/@skeletonlabs/skeleton/dist/components/Tab/Tab.svelte";
var get_lead_slot_changes8 = (dirty) => ({});
var get_lead_slot_context8 = (ctx) => ({});
function create_if_block21(ctx) {
  let div;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[22].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_lead_slot_context8
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "tab-lead");
      add_location(div, file28, 90, 21, 2836);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty[0] & /*$$scope*/
        2097152)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_lead_slot_changes8
            ),
            get_lead_slot_context8
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block21.name,
    type: "if",
    source: "(91:3) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_fragment28(ctx) {
  let label;
  let div3;
  let div0;
  let input;
  let t0;
  let div2;
  let t1;
  let div1;
  let div2_class_value;
  let div3_class_value;
  let div3_tabindex_value;
  let current;
  let binding_group;
  let mounted;
  let dispose;
  let input_levels = [
    { type: "radio" },
    { name: (
      /*name*/
      ctx[1]
    ) },
    { __value: (
      /*value*/
      ctx[2]
    ) },
    /*prunedRestProps*/
    ctx[11](),
    { tabindex: "-1" }
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  let if_block = (
    /*$$slots*/
    ctx[12].lead && create_if_block21(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[30][0]
  );
  const block = {
    c: function create() {
      label = element("label");
      div3 = element("div");
      div0 = element("div");
      input = element("input");
      t0 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true, title: true });
      var label_nodes = children(label);
      div3 = claim_element(label_nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-controls": true,
        "aria-selected": true,
        tabindex: true
      });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", { type: true, name: true, tabindex: true });
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block)
        if_block.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file28, 86, 3, 2609);
      attr_dev(div0, "class", "h-0 w-0 overflow-hidden");
      add_location(div0, file28, 85, 2, 2568);
      attr_dev(div1, "class", "tab-label");
      add_location(div1, file28, 91, 3, 2893);
      attr_dev(div2, "class", div2_class_value = "tab-interface " + /*classesInterface*/
      ctx[8]);
      add_location(div2, file28, 89, 2, 2768);
      attr_dev(div3, "class", div3_class_value = "tab " + /*classesTab*/
      ctx[7]);
      attr_dev(div3, "data-testid", "tab");
      attr_dev(div3, "role", "tab");
      attr_dev(
        div3,
        "aria-controls",
        /*controls*/
        ctx[4]
      );
      attr_dev(
        div3,
        "aria-selected",
        /*selected*/
        ctx[5]
      );
      attr_dev(div3, "tabindex", div3_tabindex_value = /*selected*/
      ctx[5] ? 0 : -1);
      add_location(div3, file28, 72, 1, 2273);
      attr_dev(
        label,
        "class",
        /*classesBase*/
        ctx[9]
      );
      attr_dev(
        label,
        "title",
        /*title*/
        ctx[3]
      );
      add_location(label, file28, 70, 0, 2183);
      binding_group.p(input);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      append_hydration_dev(label, div3);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, input);
      if (input.autofocus)
        input.focus();
      ctx[28](input);
      input.checked = input.__value === /*group*/
      ctx[0];
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div2);
      if (if_block)
        if_block.m(div2, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[29]
          ),
          listen_dev(
            input,
            "click",
            /*click_handler*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*change_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            /*onKeyDown*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keydown",
            /*keydown_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keyup",
            /*keyup_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "keypress",
            /*keypress_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "radio" },
        (!current || dirty[0] & /*name*/
        2) && { name: (
          /*name*/
          ctx2[1]
        ) },
        (!current || dirty[0] & /*value*/
        4) && { __value: (
          /*value*/
          ctx2[2]
        ) },
        /*prunedRestProps*/
        ctx2[11](),
        { tabindex: "-1" }
      ]));
      if (dirty[0] & /*group*/
      1) {
        input.checked = input.__value === /*group*/
        ctx2[0];
      }
      if (
        /*$$slots*/
        ctx2[12].lead
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          4096) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block21(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classesInterface*/
      256 && div2_class_value !== (div2_class_value = "tab-interface " + /*classesInterface*/
      ctx2[8])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*classesTab*/
      128 && div3_class_value !== (div3_class_value = "tab " + /*classesTab*/
      ctx2[7])) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*controls*/
      16) {
        attr_dev(
          div3,
          "aria-controls",
          /*controls*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*selected*/
      32) {
        attr_dev(
          div3,
          "aria-selected",
          /*selected*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*selected*/
      32 && div3_tabindex_value !== (div3_tabindex_value = /*selected*/
      ctx2[5] ? 0 : -1)) {
        attr_dev(div3, "tabindex", div3_tabindex_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      512) {
        attr_dev(
          label,
          "class",
          /*classesBase*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*title*/
      8) {
        attr_dev(
          label,
          "title",
          /*title*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      ctx[28](null);
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase21 = "text-center cursor-pointer transition-colors duration-100";
var cInterface3 = "";
function instance28($$self, $$props, $$invalidate) {
  let selected;
  let classesActive;
  let classesBase;
  let classesInterface;
  let classesTab;
  const omit_props_names = [
    "group",
    "name",
    "value",
    "title",
    "controls",
    "regionTab",
    "active",
    "hover",
    "flex",
    "padding",
    "rounded",
    "spacing"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["lead", "default"]);
  const $$slots = compute_slots(slots);
  let { group } = $$props;
  let { name } = $$props;
  let { value } = $$props;
  let { title = "" } = $$props;
  let { controls = "" } = $$props;
  let { regionTab = "" } = $$props;
  let { active = getContext("active") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { flex = getContext("flex") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { spacing = getContext("spacing") } = $$props;
  let elemInput;
  function onKeyDown2(event) {
    if (["Enter", "Space"].includes(event.code)) {
      event.preventDefault();
      elemInput.click();
    } else if (event.code === "ArrowRight") {
      const tabList = elemInput.closest(".tab-list");
      if (!tabList)
        return;
      const tabs = Array.from(tabList.querySelectorAll(".tab"));
      const currTab = elemInput.closest(".tab");
      if (!currTab)
        return;
      const currIndex = tabs.indexOf(currTab);
      const nextIndex = currIndex + 1 >= tabs.length ? 0 : currIndex + 1;
      const nextTab = tabs[nextIndex];
      const nextTabInput = nextTab == null ? void 0 : nextTab.querySelector("input");
      if (nextTab && nextTabInput) {
        nextTabInput.click();
        nextTab.focus();
      }
    } else if (event.code === "ArrowLeft") {
      const tabList = elemInput.closest(".tab-list");
      if (!tabList)
        return;
      const tabs = Array.from(tabList.querySelectorAll(".tab"));
      const currTab = elemInput.closest(".tab");
      if (!currTab)
        return;
      const currIndex = tabs.indexOf(currTab);
      const nextIndex = currIndex - 1 < 0 ? tabs.length - 1 : currIndex - 1;
      const nextTab = tabs[nextIndex];
      const nextTabInput = nextTab == null ? void 0 : nextTab.querySelector("input");
      if (nextTab && nextTabInput) {
        nextTabInput.click();
        nextTab.focus();
      }
    }
  }
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  $$self.$$.on_mount.push(function() {
    if (group === void 0 && !("group" in $$props || $$self.$$.bound[$$self.$$.props["group"]])) {
      console.warn("<Tab> was created without expected prop 'group'");
    }
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<Tab> was created without expected prop 'name'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Tab> was created without expected prop 'value'");
    }
  });
  const $$binding_groups = [[]];
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemInput = $$value;
      $$invalidate(6, elemInput);
    });
  }
  function input_change_handler() {
    group = this.__value;
    $$invalidate(0, group);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(31, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("group" in $$new_props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("title" in $$new_props)
      $$invalidate(3, title = $$new_props.title);
    if ("controls" in $$new_props)
      $$invalidate(4, controls = $$new_props.controls);
    if ("regionTab" in $$new_props)
      $$invalidate(13, regionTab = $$new_props.regionTab);
    if ("active" in $$new_props)
      $$invalidate(14, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(15, hover = $$new_props.hover);
    if ("flex" in $$new_props)
      $$invalidate(16, flex = $$new_props.flex);
    if ("padding" in $$new_props)
      $$invalidate(17, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(18, rounded = $$new_props.rounded);
    if ("spacing" in $$new_props)
      $$invalidate(19, spacing = $$new_props.spacing);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    group,
    name,
    value,
    title,
    controls,
    regionTab,
    active,
    hover,
    flex,
    padding,
    rounded,
    spacing,
    cBase: cBase21,
    cInterface: cInterface3,
    elemInput,
    onKeyDown: onKeyDown2,
    prunedRestProps,
    classesTab,
    classesInterface,
    classesActive,
    classesBase,
    selected
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
    if ("group" in $$props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(2, value = $$new_props.value);
    if ("title" in $$props)
      $$invalidate(3, title = $$new_props.title);
    if ("controls" in $$props)
      $$invalidate(4, controls = $$new_props.controls);
    if ("regionTab" in $$props)
      $$invalidate(13, regionTab = $$new_props.regionTab);
    if ("active" in $$props)
      $$invalidate(14, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(15, hover = $$new_props.hover);
    if ("flex" in $$props)
      $$invalidate(16, flex = $$new_props.flex);
    if ("padding" in $$props)
      $$invalidate(17, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(18, rounded = $$new_props.rounded);
    if ("spacing" in $$props)
      $$invalidate(19, spacing = $$new_props.spacing);
    if ("elemInput" in $$props)
      $$invalidate(6, elemInput = $$new_props.elemInput);
    if ("classesTab" in $$props)
      $$invalidate(7, classesTab = $$new_props.classesTab);
    if ("classesInterface" in $$props)
      $$invalidate(8, classesInterface = $$new_props.classesInterface);
    if ("classesActive" in $$props)
      $$invalidate(20, classesActive = $$new_props.classesActive);
    if ("classesBase" in $$props)
      $$invalidate(9, classesBase = $$new_props.classesBase);
    if ("selected" in $$props)
      $$invalidate(5, selected = $$new_props.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value, group*/
    5) {
      $:
        $$invalidate(5, selected = value === group);
    }
    if ($$self.$$.dirty[0] & /*selected, active, hover*/
    49184) {
      $:
        $$invalidate(20, classesActive = selected ? active : hover);
    }
    $:
      $$invalidate(9, classesBase = `${cBase21} ${flex} ${padding} ${rounded} ${classesActive} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*spacing*/
    524288) {
      $:
        $$invalidate(8, classesInterface = `${cInterface3} ${spacing}`);
    }
    if ($$self.$$.dirty[0] & /*regionTab*/
    8192) {
      $:
        $$invalidate(7, classesTab = `${regionTab}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    group,
    name,
    value,
    title,
    controls,
    selected,
    elemInput,
    classesTab,
    classesInterface,
    classesBase,
    onKeyDown2,
    prunedRestProps,
    $$slots,
    regionTab,
    active,
    hover,
    flex,
    padding,
    rounded,
    spacing,
    classesActive,
    $$scope,
    slots,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    click_handler,
    change_handler,
    input_binding,
    input_change_handler,
    $$binding_groups
  ];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance28,
      create_fragment28,
      safe_not_equal,
      {
        group: 0,
        name: 1,
        value: 2,
        title: 3,
        controls: 4,
        regionTab: 13,
        active: 14,
        hover: 15,
        flex: 16,
        padding: 17,
        rounded: 18,
        spacing: 19
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment28.name
    });
  }
  get group() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controls() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controls(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionTab() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionTab(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flex() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flex(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tab_default = Tab;

// node_modules/@skeletonlabs/skeleton/dist/components/Tab/TabAnchor.svelte
var file29 = "node_modules/@skeletonlabs/skeleton/dist/components/Tab/TabAnchor.svelte";
var get_lead_slot_changes9 = (dirty) => ({});
var get_lead_slot_context9 = (ctx) => ({});
function create_if_block22(ctx) {
  let div;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[15].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_lead_slot_context9
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "tab-lead");
      add_location(div, file29, 40, 20, 1060);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_lead_slot_changes9
            ),
            get_lead_slot_context9
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block22.name,
    type: "if",
    source: "(41:2) {#if $$slots.lead}",
    ctx
  });
  return block;
}
function create_fragment29(ctx) {
  let a;
  let div1;
  let t;
  let div0;
  let div1_class_value;
  let a_class_value;
  let a_href_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    ctx[5].lead && create_if_block22(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let a_levels = [
    {
      class: a_class_value = "tab-anchor " + /*classesBase*/
      ctx[2]
    },
    {
      href: a_href_value = /*$$props*/
      ctx[4].href
    },
    /*prunedRestProps*/
    ctx[3](),
    { "aria-controls": (
      /*controls*/
      ctx[0]
    ) },
    { "data-testid": "tab-anchor" }
  ];
  let a_data = {};
  for (let i = 0; i < a_levels.length; i += 1) {
    a_data = assign(a_data, a_levels[i]);
  }
  const block = {
    c: function create() {
      a = element("a");
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      a = claim_element(nodes, "A", {
        class: true,
        href: true,
        "aria-controls": true,
        "data-testid": true
      });
      var a_nodes = children(a);
      div1 = claim_element(a_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block)
        if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "tab-label");
      add_location(div0, file29, 41, 2, 1116);
      attr_dev(div1, "class", div1_class_value = "tab-interface " + /*classesInterface*/
      ctx[1]);
      add_location(div1, file29, 39, 1, 993);
      set_attributes(a, a_data);
      add_location(a, file29, 23, 0, 743);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, div1);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            a,
            "click",
            /*click_handler*/
            ctx[16],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keydown",
            /*keydown_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keyup",
            /*keyup_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "keypress",
            /*keypress_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseover",
            /*mouseover_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "mouseleave",
            /*mouseleave_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "focus",
            /*focus_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            a,
            "blur",
            /*blur_handler*/
            ctx[23],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[5].lead
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block22(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesInterface*/
      2 && div1_class_value !== (div1_class_value = "tab-interface " + /*classesInterface*/
      ctx2[1])) {
        attr_dev(div1, "class", div1_class_value);
      }
      set_attributes(a, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*classesBase*/
        4 && a_class_value !== (a_class_value = "tab-anchor " + /*classesBase*/
        ctx2[2])) && { class: a_class_value },
        (!current || dirty & /*$$props*/
        16 && a_href_value !== (a_href_value = /*$$props*/
        ctx2[4].href)) && { href: a_href_value },
        /*prunedRestProps*/
        ctx2[3](),
        (!current || dirty & /*controls*/
        1) && { "aria-controls": (
          /*controls*/
          ctx2[0]
        ) },
        { "data-testid": "tab-anchor" }
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(a);
      }
      if (if_block)
        if_block.d();
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase22 = "text-center cursor-pointer transition-colors duration-100";
var cInterface4 = "";
function instance29($$self, $$props, $$invalidate) {
  let classesActive;
  let classesBase;
  let classesInterface;
  const omit_props_names = ["selected", "controls", "active", "hover", "flex", "padding", "rounded", "spacing"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabAnchor", slots, ["lead", "default"]);
  const $$slots = compute_slots(slots);
  let { selected = false } = $$props;
  let { controls = "" } = $$props;
  let { active = getContext("active") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { flex = getContext("flex") } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { spacing = getContext("spacing") } = $$props;
  function prunedRestProps() {
    delete $$restProps.class;
    return $$restProps;
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseover_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mouseleave_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    $$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("selected" in $$new_props)
      $$invalidate(6, selected = $$new_props.selected);
    if ("controls" in $$new_props)
      $$invalidate(0, controls = $$new_props.controls);
    if ("active" in $$new_props)
      $$invalidate(7, active = $$new_props.active);
    if ("hover" in $$new_props)
      $$invalidate(8, hover = $$new_props.hover);
    if ("flex" in $$new_props)
      $$invalidate(9, flex = $$new_props.flex);
    if ("padding" in $$new_props)
      $$invalidate(10, padding = $$new_props.padding);
    if ("rounded" in $$new_props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("spacing" in $$new_props)
      $$invalidate(12, spacing = $$new_props.spacing);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    selected,
    controls,
    active,
    hover,
    flex,
    padding,
    rounded,
    spacing,
    cBase: cBase22,
    cInterface: cInterface4,
    prunedRestProps,
    classesInterface,
    classesActive,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("selected" in $$props)
      $$invalidate(6, selected = $$new_props.selected);
    if ("controls" in $$props)
      $$invalidate(0, controls = $$new_props.controls);
    if ("active" in $$props)
      $$invalidate(7, active = $$new_props.active);
    if ("hover" in $$props)
      $$invalidate(8, hover = $$new_props.hover);
    if ("flex" in $$props)
      $$invalidate(9, flex = $$new_props.flex);
    if ("padding" in $$props)
      $$invalidate(10, padding = $$new_props.padding);
    if ("rounded" in $$props)
      $$invalidate(11, rounded = $$new_props.rounded);
    if ("spacing" in $$props)
      $$invalidate(12, spacing = $$new_props.spacing);
    if ("classesInterface" in $$props)
      $$invalidate(1, classesInterface = $$new_props.classesInterface);
    if ("classesActive" in $$props)
      $$invalidate(13, classesActive = $$new_props.classesActive);
    if ("classesBase" in $$props)
      $$invalidate(2, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*selected, active, hover*/
    448) {
      $:
        $$invalidate(13, classesActive = selected ? active : hover);
    }
    $:
      $$invalidate(2, classesBase = `${cBase22} ${flex} ${padding} ${rounded} ${classesActive} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*spacing*/
    4096) {
      $:
        $$invalidate(1, classesInterface = `${cInterface4} ${spacing}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    controls,
    classesInterface,
    classesBase,
    prunedRestProps,
    $$props,
    $$slots,
    selected,
    active,
    hover,
    flex,
    padding,
    rounded,
    spacing,
    classesActive,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler,
    mouseover_handler,
    mouseleave_handler,
    focus_handler,
    blur_handler
  ];
}
var TabAnchor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {
      selected: 6,
      controls: 0,
      active: 7,
      hover: 8,
      flex: 9,
      padding: 10,
      rounded: 11,
      spacing: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabAnchor",
      options,
      id: create_fragment29.name
    });
  }
  get selected() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get controls() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set controls(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flex() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flex(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<TabAnchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<TabAnchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabAnchor_default = TabAnchor;

// node_modules/@skeletonlabs/skeleton/dist/components/TreeView/TreeView.svelte
var file30 = "node_modules/@skeletonlabs/skeleton/dist/components/TreeView/TreeView.svelte";
function create_fragment30(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-multiselectable": true,
        "aria-label": true,
        "aria-disabled": true
      });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "tree " + /*classesBase*/
      ctx[4]);
      attr_dev(div, "data-testid", "tree");
      attr_dev(div, "role", "tree");
      attr_dev(
        div,
        "aria-multiselectable",
        /*multiple*/
        ctx[0]
      );
      attr_dev(
        div,
        "aria-label",
        /*labelledby*/
        ctx[2]
      );
      attr_dev(
        div,
        "aria-disabled",
        /*disabled*/
        ctx[1]
      );
      add_location(div, file30, 57, 0, 1787);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[23](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*classesBase*/
      16 && div_class_value !== (div_class_value = "tree " + /*classesBase*/
      ctx2[4])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*multiple*/
      1) {
        attr_dev(
          div,
          "aria-multiselectable",
          /*multiple*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*labelledby*/
      4) {
        attr_dev(
          div,
          "aria-label",
          /*labelledby*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*disabled*/
      2) {
        attr_dev(
          div,
          "aria-disabled",
          /*disabled*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[23](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeView", slots, ["default"]);
  let { selection = false } = $$props;
  let { multiple = false } = $$props;
  let { width = "w-full" } = $$props;
  let { spacing = "space-y-1" } = $$props;
  let { open = false } = $$props;
  let { disabled = false } = $$props;
  let { padding = "py-4 px-4" } = $$props;
  let { indent = "ml-4" } = $$props;
  let { hover = "hover:variant-soft" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { caretOpen = "rotate-180" } = $$props;
  let { caretClosed = "" } = $$props;
  let { hyphenOpacity = "opacity-10" } = $$props;
  let { regionSummary = "" } = $$props;
  let { regionSymbol = "" } = $$props;
  let { regionChildren = "" } = $$props;
  let { labelledby = "" } = $$props;
  function expandAll() {
    const detailsElements = tree.querySelectorAll("details.tree-item");
    detailsElements.forEach((details) => {
      if (!details.open) {
        const summary = details.querySelector("summary.tree-item-summary");
        if (summary)
          summary.click();
      }
    });
  }
  function collapseAll() {
    const detailsElements = tree.querySelectorAll("details.tree-item");
    detailsElements.forEach((details) => {
      if (details.open) {
        const summary = details.querySelector("summary.tree-item-summary");
        if (summary)
          summary.click();
      }
    });
  }
  setContext("open", open);
  setContext("selection", selection);
  setContext("multiple", multiple);
  setContext("disabled", disabled);
  setContext("padding", padding);
  setContext("indent", indent);
  setContext("hover", hover);
  setContext("rounded", rounded);
  setContext("caretOpen", caretOpen);
  setContext("caretClosed", caretClosed);
  setContext("hyphenOpacity", hyphenOpacity);
  setContext("regionSummary", regionSummary);
  setContext("regionSymbol", regionSymbol);
  setContext("regionChildren", regionChildren);
  let tree;
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tree = $$value;
      $$invalidate(3, tree);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("selection" in $$new_props)
      $$invalidate(5, selection = $$new_props.selection);
    if ("multiple" in $$new_props)
      $$invalidate(0, multiple = $$new_props.multiple);
    if ("width" in $$new_props)
      $$invalidate(6, width = $$new_props.width);
    if ("spacing" in $$new_props)
      $$invalidate(7, spacing = $$new_props.spacing);
    if ("open" in $$new_props)
      $$invalidate(8, open = $$new_props.open);
    if ("disabled" in $$new_props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("padding" in $$new_props)
      $$invalidate(9, padding = $$new_props.padding);
    if ("indent" in $$new_props)
      $$invalidate(10, indent = $$new_props.indent);
    if ("hover" in $$new_props)
      $$invalidate(11, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("caretOpen" in $$new_props)
      $$invalidate(13, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$new_props)
      $$invalidate(14, caretClosed = $$new_props.caretClosed);
    if ("hyphenOpacity" in $$new_props)
      $$invalidate(15, hyphenOpacity = $$new_props.hyphenOpacity);
    if ("regionSummary" in $$new_props)
      $$invalidate(16, regionSummary = $$new_props.regionSummary);
    if ("regionSymbol" in $$new_props)
      $$invalidate(17, regionSymbol = $$new_props.regionSymbol);
    if ("regionChildren" in $$new_props)
      $$invalidate(18, regionChildren = $$new_props.regionChildren);
    if ("labelledby" in $$new_props)
      $$invalidate(2, labelledby = $$new_props.labelledby);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    selection,
    multiple,
    width,
    spacing,
    open,
    disabled,
    padding,
    indent,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    hyphenOpacity,
    regionSummary,
    regionSymbol,
    regionChildren,
    labelledby,
    expandAll,
    collapseAll,
    tree,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    if ("selection" in $$props)
      $$invalidate(5, selection = $$new_props.selection);
    if ("multiple" in $$props)
      $$invalidate(0, multiple = $$new_props.multiple);
    if ("width" in $$props)
      $$invalidate(6, width = $$new_props.width);
    if ("spacing" in $$props)
      $$invalidate(7, spacing = $$new_props.spacing);
    if ("open" in $$props)
      $$invalidate(8, open = $$new_props.open);
    if ("disabled" in $$props)
      $$invalidate(1, disabled = $$new_props.disabled);
    if ("padding" in $$props)
      $$invalidate(9, padding = $$new_props.padding);
    if ("indent" in $$props)
      $$invalidate(10, indent = $$new_props.indent);
    if ("hover" in $$props)
      $$invalidate(11, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(12, rounded = $$new_props.rounded);
    if ("caretOpen" in $$props)
      $$invalidate(13, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$props)
      $$invalidate(14, caretClosed = $$new_props.caretClosed);
    if ("hyphenOpacity" in $$props)
      $$invalidate(15, hyphenOpacity = $$new_props.hyphenOpacity);
    if ("regionSummary" in $$props)
      $$invalidate(16, regionSummary = $$new_props.regionSummary);
    if ("regionSymbol" in $$props)
      $$invalidate(17, regionSymbol = $$new_props.regionSymbol);
    if ("regionChildren" in $$props)
      $$invalidate(18, regionChildren = $$new_props.regionChildren);
    if ("labelledby" in $$props)
      $$invalidate(2, labelledby = $$new_props.labelledby);
    if ("tree" in $$props)
      $$invalidate(3, tree = $$new_props.tree);
    if ("classesBase" in $$props)
      $$invalidate(4, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(4, classesBase = `${width} ${spacing} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    multiple,
    disabled,
    labelledby,
    tree,
    classesBase,
    selection,
    width,
    spacing,
    open,
    padding,
    indent,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    hyphenOpacity,
    regionSummary,
    regionSymbol,
    regionChildren,
    expandAll,
    collapseAll,
    $$scope,
    slots,
    div_binding
  ];
}
var TreeView = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, {
      selection: 5,
      multiple: 0,
      width: 6,
      spacing: 7,
      open: 8,
      disabled: 1,
      padding: 9,
      indent: 10,
      hover: 11,
      rounded: 12,
      caretOpen: 13,
      caretClosed: 14,
      hyphenOpacity: 15,
      regionSummary: 16,
      regionSymbol: 17,
      regionChildren: 18,
      labelledby: 2,
      expandAll: 19,
      collapseAll: 20
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeView",
      options,
      id: create_fragment30.name
    });
  }
  get selection() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indent() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indent(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretOpen() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretOpen(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretClosed() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretClosed(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hyphenOpacity() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hyphenOpacity(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionSummary() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionSummary(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionSymbol() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionSymbol(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionChildren() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionChildren(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<TreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandAll() {
    return this.$$.ctx[19];
  }
  set expandAll(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapseAll() {
    return this.$$.ctx[20];
  }
  set collapseAll(value) {
    throw new Error("<TreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TreeView_default = TreeView;

// node_modules/@skeletonlabs/skeleton/dist/components/TreeView/TreeViewItem.svelte
var file31 = "node_modules/@skeletonlabs/skeleton/dist/components/TreeView/TreeViewItem.svelte";
var get_children_slot_changes = (dirty) => ({});
var get_children_slot_context = (ctx) => ({});
var get_lead_slot_changes10 = (dirty) => ({});
var get_lead_slot_context10 = (ctx) => ({});
function create_else_block_14(ctx) {
  let svg;
  let path;
  let svg_class_value;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true, class: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M432 256c0 17.7-14.3 32-32 32L48 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l352 0c17.7 0 32 14.3 32 32z");
      add_location(path, file31, 282, 5, 8476);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 448 512");
      attr_dev(svg, "class", svg_class_value = "w-3 " + /*classesHyphen*/
      ctx[15]);
      add_location(svg, file31, 281, 4, 8380);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*classesHyphen*/
      32768 && svg_class_value !== (svg_class_value = "w-3 " + /*classesHyphen*/
      ctx2[15])) {
        attr_dev(svg, "class", svg_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_14.name,
    type: "else",
    source: "(281:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_36(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M201.4 374.6c12.5 12.5 32.8 12.5 45.3 0l160-160c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 306.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160z");
      add_location(path, file31, 276, 5, 8161);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 448 512");
      add_location(svg, file31, 275, 4, 8093);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_36.name,
    type: "if",
    source: "(274:3) {#if $$slots.children && !hideChildren}",
    ctx
  });
  return block;
}
function create_if_block_111(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*multiple*/
      ctx2[7]
    )
      return create_if_block_210;
    return create_else_block8;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_111.name,
    type: "if",
    source: "(289:2) {#if selection && name && group !== undefined}",
    ctx
  });
  return block;
}
function create_else_block8(ctx) {
  let input;
  let value_has_changed = false;
  let binding_group;
  let mounted;
  let dispose;
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[44][0]
  );
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { class: true, type: true, name: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "radio tree-item-radio");
      attr_dev(input, "type", "radio");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[4]
      );
      input.__value = /*value*/
      ctx[5];
      set_input_value(input, input.__value);
      add_location(input, file31, 300, 4, 8902);
      binding_group.p(input);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      input.checked = input.__value === /*group*/
      ctx[0];
      if (!mounted) {
        dispose = listen_dev(
          input,
          "change",
          /*input_change_handler_1*/
          ctx[43]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*name*/
      16) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*value*/
      32) {
        prop_dev(
          input,
          "__value",
          /*value*/
          ctx2[5]
        );
        set_input_value(input, input.__value);
        value_has_changed = true;
      }
      if (value_has_changed || dirty[0] & /*group*/
      1) {
        input.checked = input.__value === /*group*/
        ctx2[0];
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      binding_group.r();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block8.name,
    type: "else",
    source: "(300:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_210(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { class: true, type: true, name: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "class", "checkbox tree-item-checkbox");
      attr_dev(input, "type", "checkbox");
      attr_dev(
        input,
        "name",
        /*name*/
        ctx[4]
      );
      input.__value = /*value*/
      ctx[5];
      set_input_value(input, input.__value);
      if (
        /*checked*/
        ctx[1] === void 0 || /*indeterminate*/
        ctx[3] === void 0
      )
        add_render_callback(() => (
          /*input_change_handler*/
          ctx[42].call(input)
        ));
      add_location(input, file31, 290, 4, 8712);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      input.checked = /*checked*/
      ctx[1];
      input.indeterminate = /*indeterminate*/
      ctx[3];
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_handler*/
            ctx[42]
          ),
          listen_dev(
            input,
            "change",
            /*onParentChange*/
            ctx[11],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*name*/
      16) {
        attr_dev(
          input,
          "name",
          /*name*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*value*/
      32) {
        prop_dev(
          input,
          "__value",
          /*value*/
          ctx2[5]
        );
        set_input_value(input, input.__value);
      }
      if (dirty[0] & /*checked*/
      2) {
        input.checked = /*checked*/
        ctx2[1];
      }
      if (dirty[0] & /*indeterminate*/
      8) {
        input.indeterminate = /*indeterminate*/
        ctx2[3];
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_210.name,
    type: "if",
    source: "(290:3) {#if multiple}",
    ctx
  });
  return block;
}
function create_if_block23(ctx) {
  let div;
  let current;
  const lead_slot_template = (
    /*#slots*/
    ctx[38].lead
  );
  const lead_slot = create_slot(
    lead_slot_template,
    ctx,
    /*$$scope*/
    ctx[37],
    get_lead_slot_context10
  );
  const block = {
    c: function create() {
      div = element("div");
      if (lead_slot)
        lead_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (lead_slot)
        lead_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "tree-item-lead");
      add_location(div, file31, 306, 3, 9058);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (lead_slot) {
        lead_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (lead_slot) {
        if (lead_slot.p && (!current || dirty[1] & /*$$scope*/
        64)) {
          update_slot_base(
            lead_slot,
            lead_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[37],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[37]
            ) : get_slot_changes(
              lead_slot_template,
              /*$$scope*/
              ctx2[37],
              dirty,
              get_lead_slot_changes10
            ),
            get_lead_slot_context10
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lead_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lead_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (lead_slot)
        lead_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block23.name,
    type: "if",
    source: "(306:2) {#if $$slots.lead && !hideLead}",
    ctx
  });
  return block;
}
function create_fragment31(ctx) {
  let details;
  let summary;
  let div0;
  let div0_class_value;
  let t0;
  let t1;
  let t2;
  let div1;
  let summary_class_value;
  let summary_aria_selected_value;
  let summary_aria_expanded_value;
  let t3;
  let div2;
  let div2_class_value;
  let details_class_value;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[21].children && !/*hideChildren*/
      ctx2[10]
    )
      return create_if_block_36;
    return create_else_block_14;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*selection*/
    ctx[6] && /*name*/
    ctx[4] && /*group*/
    ctx[0] !== void 0 && create_if_block_111(ctx)
  );
  let if_block2 = (
    /*$$slots*/
    ctx[21].lead && !/*hideLead*/
    ctx[9] && create_if_block23(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[38].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[37],
    null
  );
  const children_slot_template = (
    /*#slots*/
    ctx[38].children
  );
  const children_slot = create_slot(
    children_slot_template,
    ctx,
    /*$$scope*/
    ctx[37],
    get_children_slot_context
  );
  const block = {
    c: function create() {
      details = element("details");
      summary = element("summary");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t3 = space();
      div2 = element("div");
      if (children_slot)
        children_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      details = claim_element(nodes, "DETAILS", {
        class: true,
        "data-testid": true,
        "aria-disabled": true
      });
      var details_nodes = children(details);
      summary = claim_element(details_nodes, "SUMMARY", {
        class: true,
        role: true,
        "aria-selected": true,
        "aria-expanded": true
      });
      var summary_nodes = children(summary);
      div0 = claim_element(summary_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block0.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(summary_nodes);
      if (if_block1)
        if_block1.l(summary_nodes);
      t1 = claim_space(summary_nodes);
      if (if_block2)
        if_block2.l(summary_nodes);
      t2 = claim_space(summary_nodes);
      div1 = claim_element(summary_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      summary_nodes.forEach(detach_dev);
      t3 = claim_space(details_nodes);
      div2 = claim_element(details_nodes, "DIV", { class: true, role: true });
      var div2_nodes = children(div2);
      if (children_slot)
        children_slot.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      details_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "tree-summary-symbol " + /*classesSymbol*/
      ctx[16]);
      add_location(div0, file31, 272, 2, 7973);
      attr_dev(div1, "class", "tree-item-content");
      add_location(div1, file31, 311, 2, 9157);
      attr_dev(summary, "class", summary_class_value = "tree-item-summary " + /*classesSummary*/
      ctx[17]);
      attr_dev(summary, "role", "treeitem");
      attr_dev(summary, "aria-selected", summary_aria_selected_value = /*selection*/
      ctx[6] ? (
        /*checked*/
        ctx[1]
      ) : void 0);
      attr_dev(summary, "aria-expanded", summary_aria_expanded_value = /*$$slots*/
      ctx[21].children ? (
        /*open*/
        ctx[2]
      ) : void 0);
      add_location(summary, file31, 260, 1, 7686);
      attr_dev(div2, "class", div2_class_value = "tree-item-children " + /*classesChildren*/
      ctx[14]);
      attr_dev(div2, "role", "group");
      add_location(div2, file31, 315, 1, 9223);
      attr_dev(details, "class", details_class_value = "tree-item " + /*classesBase*/
      ctx[18]);
      attr_dev(details, "data-testid", "tree-item");
      attr_dev(
        details,
        "aria-disabled",
        /*disabled*/
        ctx[8]
      );
      add_location(details, file31, 259, 0, 7563);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, details, anchor);
      append_hydration_dev(details, summary);
      append_hydration_dev(summary, div0);
      if_block0.m(div0, null);
      append_hydration_dev(summary, t0);
      if (if_block1)
        if_block1.m(summary, null);
      append_hydration_dev(summary, t1);
      if (if_block2)
        if_block2.m(summary, null);
      append_hydration_dev(summary, t2);
      append_hydration_dev(summary, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(details, t3);
      append_hydration_dev(details, div2);
      if (children_slot) {
        children_slot.m(div2, null);
      }
      ctx[45](div2);
      ctx[46](details);
      details.open = /*open*/
      ctx[2];
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            summary,
            "click",
            /*onSummaryClick*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            summary,
            "click",
            /*click_handler*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            summary,
            "keydown",
            /*onKeyDown*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            summary,
            "keydown",
            /*keydown_handler*/
            ctx[40],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            summary,
            "keyup",
            /*keyup_handler*/
            ctx[41],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            details,
            "toggle",
            /*details_toggle_handler*/
            ctx[47]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if (!current || dirty[0] & /*classesSymbol*/
      65536 && div0_class_value !== (div0_class_value = "tree-summary-symbol " + /*classesSymbol*/
      ctx2[16])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*selection*/
        ctx2[6] && /*name*/
        ctx2[4] && /*group*/
        ctx2[0] !== void 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_111(ctx2);
          if_block1.c();
          if_block1.m(summary, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$$slots*/
        ctx2[21].lead && !/*hideLead*/
        ctx2[9]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*$$slots, hideLead*/
          2097664) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block23(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(summary, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[37],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[37]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[37],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classesSummary*/
      131072 && summary_class_value !== (summary_class_value = "tree-item-summary " + /*classesSummary*/
      ctx2[17])) {
        attr_dev(summary, "class", summary_class_value);
      }
      if (!current || dirty[0] & /*selection, checked*/
      66 && summary_aria_selected_value !== (summary_aria_selected_value = /*selection*/
      ctx2[6] ? (
        /*checked*/
        ctx2[1]
      ) : void 0)) {
        attr_dev(summary, "aria-selected", summary_aria_selected_value);
      }
      if (!current || dirty[0] & /*$$slots, open*/
      2097156 && summary_aria_expanded_value !== (summary_aria_expanded_value = /*$$slots*/
      ctx2[21].children ? (
        /*open*/
        ctx2[2]
      ) : void 0)) {
        attr_dev(summary, "aria-expanded", summary_aria_expanded_value);
      }
      if (children_slot) {
        if (children_slot.p && (!current || dirty[1] & /*$$scope*/
        64)) {
          update_slot_base(
            children_slot,
            children_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[37],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[37]
            ) : get_slot_changes(
              children_slot_template,
              /*$$scope*/
              ctx2[37],
              dirty,
              get_children_slot_changes
            ),
            get_children_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*classesChildren*/
      16384 && div2_class_value !== (div2_class_value = "tree-item-children " + /*classesChildren*/
      ctx2[14])) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*classesBase*/
      262144 && details_class_value !== (details_class_value = "tree-item " + /*classesBase*/
      ctx2[18])) {
        attr_dev(details, "class", details_class_value);
      }
      if (!current || dirty[0] & /*disabled*/
      256) {
        attr_dev(
          details,
          "aria-disabled",
          /*disabled*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*open*/
      4) {
        details.open = /*open*/
        ctx2[2];
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block2);
      transition_in(default_slot, local);
      transition_in(children_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block2);
      transition_out(default_slot, local);
      transition_out(children_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(details);
      }
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (default_slot)
        default_slot.d(detaching);
      if (children_slot)
        children_slot.d(detaching);
      ctx[45](null);
      ctx[46](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase23 = "";
var cSummary = "list-none [&::-webkit-details-marker]:hidden flex items-center cursor-pointer";
var cSymbol = "fill-current w-3 text-center transition-transform duration-[200ms]";
var cChildren = "";
var cDisabled2 = "opacity-50 !cursor-not-allowed";
function instance31($$self, $$props, $$invalidate) {
  let classesCaretState;
  let classesDisabled;
  let classesBase;
  let classesSummary;
  let classesSymbol;
  let classesCaret;
  let classesHyphen;
  let classesChildren;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TreeViewItem", slots, ["lead", "default", "children"]);
  const $$slots = compute_slots(slots);
  let { group = void 0 } = $$props;
  let { name = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { checked = false } = $$props;
  let { children: children2 = [] } = $$props;
  let { spacing = "space-x-4" } = $$props;
  let { open = getContext("open") } = $$props;
  let { selection = getContext("selection") } = $$props;
  let { multiple = getContext("multiple") } = $$props;
  let { disabled = getContext("disabled") } = $$props;
  let { indeterminate = false } = $$props;
  let { padding = getContext("padding") } = $$props;
  let { indent = getContext("indent") } = $$props;
  let { hover = getContext("hover") } = $$props;
  let { rounded = getContext("rounded") } = $$props;
  let { caretOpen = getContext("caretOpen") } = $$props;
  let { caretClosed = getContext("caretClosed") } = $$props;
  let { hyphenOpacity = getContext("hyphenOpacity") } = $$props;
  let { regionSummary = getContext("regionSummary") } = $$props;
  let { regionSymbol = getContext("regionSymbol") } = $$props;
  let { regionChildren = getContext("regionChildren") } = $$props;
  let { hideLead = false } = $$props;
  let { hideChildren = false } = $$props;
  let treeItem;
  let childrenDiv;
  function onSummaryClick(event) {
    if (disabled)
      event.preventDefault();
  }
  function updateCheckbox(group2, indeterminate2) {
    if (!Array.isArray(group2))
      return;
    $$invalidate(1, checked = group2.indexOf(value) >= 0);
    dispatch("groupChange", { checked, indeterminate: indeterminate2 });
    dispatch("childChange");
  }
  function updateGroup(checked2, indeterminate2) {
    if (!Array.isArray(group))
      return;
    const index = group.indexOf(value);
    if (checked2) {
      if (index < 0) {
        group.push(value);
        $$invalidate(0, group);
      }
    } else {
      if (index >= 0) {
        group.splice(index, 1);
        $$invalidate(0, group);
      }
    }
    if (!indeterminate2) {
      onParentChange();
    }
  }
  function updateRadio(group2) {
    $$invalidate(1, checked = group2 === value);
    dispatch("groupChange", { checked, indeterminate: false });
    if (group2)
      dispatch("childChange");
  }
  function updateRadioGroup(checked2) {
    if (checked2 && group !== value)
      $$invalidate(0, group = value);
    else if (!checked2 && group === value)
      $$invalidate(0, group = "");
  }
  function onChildValueChange() {
    if (multiple) {
      if (!Array.isArray(group))
        return;
      const childrenValues = children2.map((c) => c.value);
      const childrenGroup = children2[0].group;
      const index = group.indexOf(value);
      if (children2.some((c) => c.indeterminate)) {
        $$invalidate(3, indeterminate = true);
        if (index >= 0) {
          group.splice(index, 1);
          $$invalidate(0, group);
        }
      } else if (childrenValues.every((c) => Array.isArray(childrenGroup) && childrenGroup.includes(c))) {
        $$invalidate(3, indeterminate = false);
        if (index < 0) {
          group.push(value);
          $$invalidate(0, group);
        }
      } else if (childrenValues.some((c) => Array.isArray(childrenGroup) && childrenGroup.includes(c))) {
        $$invalidate(3, indeterminate = true);
        if (index >= 0) {
          group.splice(index, 1);
          $$invalidate(0, group);
        }
      } else {
        $$invalidate(3, indeterminate = false);
        if (index >= 0) {
          group.splice(index, 1);
          $$invalidate(0, group);
        }
      }
    } else {
      if (group !== value && children2.some((c) => c.checked)) {
        $$invalidate(0, group = value);
      } else if (group === value && !children2.some((c) => c.checked)) {
        $$invalidate(0, group = "");
      }
    }
    dispatch("childChange");
  }
  function onParentChange() {
    if (!multiple || !children2 || children2.length === 0)
      return;
    if (!Array.isArray(group))
      return;
    const index = group.indexOf(value);
    const checkChild = (child) => {
      if (!child || !Array.isArray(child.group))
        return;
      child.indeterminate = false;
      if (child.group.indexOf(child.value) < 0) {
        child.group.push(child.value);
        child.group = child.group;
      }
    };
    const uncheckChild = (child) => {
      if (!child || !Array.isArray(child.group))
        return;
      child.indeterminate = false;
      const childIndex = child.group.indexOf(child.value);
      if (childIndex >= 0) {
        child.group.splice(childIndex, 1);
        child.group = child.group;
      }
    };
    children2.forEach((child) => {
      if (!child)
        return;
      index >= 0 ? checkChild(child) : uncheckChild(child);
      child.onParentChange();
    });
  }
  const dispatch = createEventDispatcher();
  function onKeyDown2(event) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    function getRootTree() {
      let currentElement = treeItem;
      while (currentElement !== null) {
        if (currentElement.classList.contains("tree"))
          return currentElement;
        currentElement = currentElement.parentElement;
      }
      return void 0;
    }
    let rootTree = void 0;
    let lastVisibleElement = null;
    switch (event.code) {
      case "ArrowRight":
        if (!open)
          $$invalidate(2, open = true);
        else if ($$slots.children && !hideChildren) {
          const child = childrenDiv.querySelector("details>summary");
          if (child)
            child.focus();
        }
        break;
      case "ArrowLeft":
        if (open)
          $$invalidate(2, open = false);
        else {
          const parent = (_a = treeItem.parentElement) == null ? void 0 : _a.parentElement;
          if (parent && parent.tagName === "DETAILS")
            (_b = parent.querySelector("summary")) == null ? void 0 : _b.focus();
        }
        break;
      case "Home":
        event.preventDefault();
        rootTree = getRootTree();
        if (rootTree)
          (_c = rootTree == null ? void 0 : rootTree.querySelector("summary")) == null ? void 0 : _c.focus();
        break;
      case "End":
        event.preventDefault();
        rootTree = getRootTree();
        if (rootTree) {
          const detailsElements = rootTree == null ? void 0 : rootTree.querySelectorAll("details");
          if (!detailsElements)
            return;
          for (let i = detailsElements.length - 1; i >= 0; i--) {
            const details = detailsElements[i];
            if (((_e = (_d = details.parentElement) == null ? void 0 : _d.classList) == null ? void 0 : _e.contains("tree")) || ((_g = (_f = details.parentElement) == null ? void 0 : _f.parentElement) == null ? void 0 : _g.getAttribute("open")) !== null) {
              lastVisibleElement = details;
              break;
            } else if (((_i = (_h = details.parentElement) == null ? void 0 : _h.parentElement) == null ? void 0 : _i.tagName) !== "details") {
              lastVisibleElement = details.parentElement.parentElement;
              break;
            }
          }
          if (lastVisibleElement) {
            const summary = lastVisibleElement.querySelector("summary");
            if (summary)
              summary.focus();
          }
        }
        break;
    }
  }
  const $$binding_groups = [[]];
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    checked = this.checked;
    indeterminate = this.indeterminate;
    $$invalidate(1, checked);
    $$invalidate(3, indeterminate);
  }
  function input_change_handler_1() {
    group = this.__value;
    $$invalidate(0, group);
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      childrenDiv = $$value;
      $$invalidate(13, childrenDiv);
    });
  }
  function details_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      treeItem = $$value;
      $$invalidate(12, treeItem);
    });
  }
  function details_toggle_handler() {
    open = this.open;
    $$invalidate(2, open);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(54, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("group" in $$new_props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$new_props)
      $$invalidate(4, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(5, value = $$new_props.value);
    if ("checked" in $$new_props)
      $$invalidate(1, checked = $$new_props.checked);
    if ("children" in $$new_props)
      $$invalidate(22, children2 = $$new_props.children);
    if ("spacing" in $$new_props)
      $$invalidate(23, spacing = $$new_props.spacing);
    if ("open" in $$new_props)
      $$invalidate(2, open = $$new_props.open);
    if ("selection" in $$new_props)
      $$invalidate(6, selection = $$new_props.selection);
    if ("multiple" in $$new_props)
      $$invalidate(7, multiple = $$new_props.multiple);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("indeterminate" in $$new_props)
      $$invalidate(3, indeterminate = $$new_props.indeterminate);
    if ("padding" in $$new_props)
      $$invalidate(24, padding = $$new_props.padding);
    if ("indent" in $$new_props)
      $$invalidate(25, indent = $$new_props.indent);
    if ("hover" in $$new_props)
      $$invalidate(26, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(27, rounded = $$new_props.rounded);
    if ("caretOpen" in $$new_props)
      $$invalidate(28, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$new_props)
      $$invalidate(29, caretClosed = $$new_props.caretClosed);
    if ("hyphenOpacity" in $$new_props)
      $$invalidate(30, hyphenOpacity = $$new_props.hyphenOpacity);
    if ("regionSummary" in $$new_props)
      $$invalidate(31, regionSummary = $$new_props.regionSummary);
    if ("regionSymbol" in $$new_props)
      $$invalidate(32, regionSymbol = $$new_props.regionSymbol);
    if ("regionChildren" in $$new_props)
      $$invalidate(33, regionChildren = $$new_props.regionChildren);
    if ("hideLead" in $$new_props)
      $$invalidate(9, hideLead = $$new_props.hideLead);
    if ("hideChildren" in $$new_props)
      $$invalidate(10, hideChildren = $$new_props.hideChildren);
    if ("$$scope" in $$new_props)
      $$invalidate(37, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    createEventDispatcher,
    onMount,
    group,
    name,
    value,
    checked,
    children: children2,
    spacing,
    open,
    selection,
    multiple,
    disabled,
    indeterminate,
    padding,
    indent,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    hyphenOpacity,
    regionSummary,
    regionSymbol,
    regionChildren,
    hideLead,
    hideChildren,
    treeItem,
    childrenDiv,
    onSummaryClick,
    updateCheckbox,
    updateGroup,
    updateRadio,
    updateRadioGroup,
    onChildValueChange,
    onParentChange,
    dispatch,
    onKeyDown: onKeyDown2,
    cBase: cBase23,
    cSummary,
    cSymbol,
    cChildren,
    cDisabled: cDisabled2,
    classesChildren,
    classesHyphen,
    classesCaretState,
    classesCaret,
    classesSymbol,
    classesDisabled,
    classesSummary,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(54, $$props = assign(assign({}, $$props), $$new_props));
    if ("group" in $$props)
      $$invalidate(0, group = $$new_props.group);
    if ("name" in $$props)
      $$invalidate(4, name = $$new_props.name);
    if ("value" in $$props)
      $$invalidate(5, value = $$new_props.value);
    if ("checked" in $$props)
      $$invalidate(1, checked = $$new_props.checked);
    if ("children" in $$props)
      $$invalidate(22, children2 = $$new_props.children);
    if ("spacing" in $$props)
      $$invalidate(23, spacing = $$new_props.spacing);
    if ("open" in $$props)
      $$invalidate(2, open = $$new_props.open);
    if ("selection" in $$props)
      $$invalidate(6, selection = $$new_props.selection);
    if ("multiple" in $$props)
      $$invalidate(7, multiple = $$new_props.multiple);
    if ("disabled" in $$props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("indeterminate" in $$props)
      $$invalidate(3, indeterminate = $$new_props.indeterminate);
    if ("padding" in $$props)
      $$invalidate(24, padding = $$new_props.padding);
    if ("indent" in $$props)
      $$invalidate(25, indent = $$new_props.indent);
    if ("hover" in $$props)
      $$invalidate(26, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(27, rounded = $$new_props.rounded);
    if ("caretOpen" in $$props)
      $$invalidate(28, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$props)
      $$invalidate(29, caretClosed = $$new_props.caretClosed);
    if ("hyphenOpacity" in $$props)
      $$invalidate(30, hyphenOpacity = $$new_props.hyphenOpacity);
    if ("regionSummary" in $$props)
      $$invalidate(31, regionSummary = $$new_props.regionSummary);
    if ("regionSymbol" in $$props)
      $$invalidate(32, regionSymbol = $$new_props.regionSymbol);
    if ("regionChildren" in $$props)
      $$invalidate(33, regionChildren = $$new_props.regionChildren);
    if ("hideLead" in $$props)
      $$invalidate(9, hideLead = $$new_props.hideLead);
    if ("hideChildren" in $$props)
      $$invalidate(10, hideChildren = $$new_props.hideChildren);
    if ("treeItem" in $$props)
      $$invalidate(12, treeItem = $$new_props.treeItem);
    if ("childrenDiv" in $$props)
      $$invalidate(13, childrenDiv = $$new_props.childrenDiv);
    if ("classesChildren" in $$props)
      $$invalidate(14, classesChildren = $$new_props.classesChildren);
    if ("classesHyphen" in $$props)
      $$invalidate(15, classesHyphen = $$new_props.classesHyphen);
    if ("classesCaretState" in $$props)
      $$invalidate(34, classesCaretState = $$new_props.classesCaretState);
    if ("classesCaret" in $$props)
      $$invalidate(35, classesCaret = $$new_props.classesCaret);
    if ("classesSymbol" in $$props)
      $$invalidate(16, classesSymbol = $$new_props.classesSymbol);
    if ("classesDisabled" in $$props)
      $$invalidate(36, classesDisabled = $$new_props.classesDisabled);
    if ("classesSummary" in $$props)
      $$invalidate(17, classesSummary = $$new_props.classesSummary);
    if ("classesBase" in $$props)
      $$invalidate(18, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*multiple, group, indeterminate*/
    137) {
      $:
        if (multiple)
          updateCheckbox(group, indeterminate);
    }
    if ($$self.$$.dirty[0] & /*multiple, checked, indeterminate*/
    138) {
      $:
        if (multiple)
          updateGroup(checked, indeterminate);
    }
    if ($$self.$$.dirty[0] & /*multiple, group*/
    129) {
      $:
        if (!multiple)
          updateRadio(group);
    }
    if ($$self.$$.dirty[0] & /*multiple, checked*/
    130) {
      $:
        if (!multiple)
          updateRadioGroup(checked);
    }
    if ($$self.$$.dirty[0] & /*multiple, group, value, children*/
    4194465) {
      $:
        if (!multiple && group !== void 0) {
          if (group !== value) {
            children2.forEach((child) => {
              if (child)
                child.group = "";
            });
          }
        }
    }
    if ($$self.$$.dirty[0] & /*open*/
    4) {
      $:
        dispatch("toggle", { open });
    }
    if ($$self.$$.dirty[0] & /*children*/
    4194304) {
      $:
        children2.forEach((child) => {
          if (child)
            child.$on("childChange", onChildValueChange);
        });
    }
    if ($$self.$$.dirty[0] & /*open, hideChildren, caretOpen, caretClosed*/
    805307396) {
      $:
        $$invalidate(34, classesCaretState = open && $$slots.children && !hideChildren ? caretOpen : caretClosed);
    }
    if ($$self.$$.dirty[0] & /*disabled*/
    256) {
      $:
        $$invalidate(36, classesDisabled = disabled ? cDisabled2 : "");
    }
    $:
      $$invalidate(18, classesBase = `${cBase23} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*spacing, rounded, padding, hover*/
    226492416 | $$self.$$.dirty[1] & /*classesDisabled, regionSummary*/
    33) {
      $:
        $$invalidate(17, classesSummary = `${cSummary} ${classesDisabled} ${spacing} ${rounded} ${padding} ${hover} ${regionSummary}`);
    }
    if ($$self.$$.dirty[1] & /*classesCaretState*/
    8) {
      $:
        $$invalidate(35, classesCaret = `${classesCaretState}`);
    }
    if ($$self.$$.dirty[1] & /*classesCaret, regionSymbol*/
    18) {
      $:
        $$invalidate(16, classesSymbol = `${cSymbol} ${classesCaret} ${regionSymbol}`);
    }
    if ($$self.$$.dirty[0] & /*hyphenOpacity*/
    1073741824) {
      $:
        $$invalidate(15, classesHyphen = `${hyphenOpacity}`);
    }
    if ($$self.$$.dirty[0] & /*indent*/
    33554432 | $$self.$$.dirty[1] & /*regionChildren*/
    4) {
      $:
        $$invalidate(14, classesChildren = `${cChildren} ${indent} ${regionChildren}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    group,
    checked,
    open,
    indeterminate,
    name,
    value,
    selection,
    multiple,
    disabled,
    hideLead,
    hideChildren,
    onParentChange,
    treeItem,
    childrenDiv,
    classesChildren,
    classesHyphen,
    classesSymbol,
    classesSummary,
    classesBase,
    onSummaryClick,
    onKeyDown2,
    $$slots,
    children2,
    spacing,
    padding,
    indent,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    hyphenOpacity,
    regionSummary,
    regionSymbol,
    regionChildren,
    classesCaretState,
    classesCaret,
    classesDisabled,
    $$scope,
    slots,
    click_handler,
    keydown_handler,
    keyup_handler,
    input_change_handler,
    input_change_handler_1,
    $$binding_groups,
    div2_binding,
    details_binding,
    details_toggle_handler
  ];
}
var TreeViewItem = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance31,
      create_fragment31,
      safe_not_equal,
      {
        group: 0,
        name: 4,
        value: 5,
        checked: 1,
        children: 22,
        spacing: 23,
        open: 2,
        selection: 6,
        multiple: 7,
        disabled: 8,
        indeterminate: 3,
        padding: 24,
        indent: 25,
        hover: 26,
        rounded: 27,
        caretOpen: 28,
        caretClosed: 29,
        hyphenOpacity: 30,
        regionSummary: 31,
        regionSymbol: 32,
        regionChildren: 33,
        hideLead: 9,
        hideChildren: 10,
        onParentChange: 11
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TreeViewItem",
      options,
      id: create_fragment31.name
    });
  }
  get group() {
    return this.$$.ctx[0];
  }
  set group(group) {
    this.$$set({ group });
    flush();
  }
  get name() {
    return this.$$.ctx[4];
  }
  set name(name) {
    this.$$set({ name });
    flush();
  }
  get value() {
    return this.$$.ctx[5];
  }
  set value(value) {
    this.$$set({ value });
    flush();
  }
  get checked() {
    return this.$$.ctx[1];
  }
  set checked(checked) {
    this.$$set({ checked });
    flush();
  }
  get children() {
    return this.$$.ctx[22];
  }
  set children(children2) {
    this.$$set({ children: children2 });
    flush();
  }
  get spacing() {
    return this.$$.ctx[23];
  }
  set spacing(spacing) {
    this.$$set({ spacing });
    flush();
  }
  get open() {
    return this.$$.ctx[2];
  }
  set open(open) {
    this.$$set({ open });
    flush();
  }
  get selection() {
    return this.$$.ctx[6];
  }
  set selection(selection) {
    this.$$set({ selection });
    flush();
  }
  get multiple() {
    return this.$$.ctx[7];
  }
  set multiple(multiple) {
    this.$$set({ multiple });
    flush();
  }
  get disabled() {
    return this.$$.ctx[8];
  }
  set disabled(disabled) {
    this.$$set({ disabled });
    flush();
  }
  get indeterminate() {
    return this.$$.ctx[3];
  }
  set indeterminate(indeterminate) {
    this.$$set({ indeterminate });
    flush();
  }
  get padding() {
    return this.$$.ctx[24];
  }
  set padding(padding) {
    this.$$set({ padding });
    flush();
  }
  get indent() {
    return this.$$.ctx[25];
  }
  set indent(indent) {
    this.$$set({ indent });
    flush();
  }
  get hover() {
    return this.$$.ctx[26];
  }
  set hover(hover) {
    this.$$set({ hover });
    flush();
  }
  get rounded() {
    return this.$$.ctx[27];
  }
  set rounded(rounded) {
    this.$$set({ rounded });
    flush();
  }
  get caretOpen() {
    return this.$$.ctx[28];
  }
  set caretOpen(caretOpen) {
    this.$$set({ caretOpen });
    flush();
  }
  get caretClosed() {
    return this.$$.ctx[29];
  }
  set caretClosed(caretClosed) {
    this.$$set({ caretClosed });
    flush();
  }
  get hyphenOpacity() {
    return this.$$.ctx[30];
  }
  set hyphenOpacity(hyphenOpacity) {
    this.$$set({ hyphenOpacity });
    flush();
  }
  get regionSummary() {
    return this.$$.ctx[31];
  }
  set regionSummary(regionSummary) {
    this.$$set({ regionSummary });
    flush();
  }
  get regionSymbol() {
    return this.$$.ctx[32];
  }
  set regionSymbol(regionSymbol) {
    this.$$set({ regionSymbol });
    flush();
  }
  get regionChildren() {
    return this.$$.ctx[33];
  }
  set regionChildren(regionChildren) {
    this.$$set({ regionChildren });
    flush();
  }
  get hideLead() {
    return this.$$.ctx[9];
  }
  set hideLead(hideLead) {
    this.$$set({ hideLead });
    flush();
  }
  get hideChildren() {
    return this.$$.ctx[10];
  }
  set hideChildren(hideChildren) {
    this.$$set({ hideChildren });
    flush();
  }
  get onParentChange() {
    return this.$$.ctx[11];
  }
  set onParentChange(value) {
    throw new Error("<TreeViewItem>: Cannot set read-only property 'onParentChange'");
  }
};
var TreeViewItem_default = TreeViewItem;

// node_modules/@skeletonlabs/skeleton/dist/components/TreeView/RecursiveTreeViewItem.svelte
function get_each_context9(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  child_ctx[32] = list;
  child_ctx[33] = i;
  return child_ctx;
}
function create_if_block24(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*nodes*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block9(get_each_context9(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*nodes, expandedNodes, disabledNodes, checkedNodes, indeterminateNodes, treeItems, children, group, name, toggleNode, checkNode, dispatch*/
      4095) {
        each_value = ensure_array_like_dev(
          /*nodes*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context9(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block9(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block24.name,
    type: "if",
    source: "(83:0) {#if nodes && nodes.length > 0}",
    ctx
  });
  return block;
}
function create_else_block_15(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*node*/
    ctx[31].contentProps
  ];
  var switch_value = (
    /*node*/
    ctx[31].content
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty[0] & /*nodes*/
    1) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*node*/
        ctx2[31].contentProps
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*nodes*/
      1 && switch_value !== (switch_value = /*node*/
      ctx2[31].content)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*nodes*/
        1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*node*/
          ctx2[31].contentProps
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_15.name,
    type: "else",
    source: "(111:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_211(ctx) {
  let html_tag;
  let raw_value = (
    /*node*/
    ctx[31].content + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*nodes*/
      1 && raw_value !== (raw_value = /*node*/
      ctx2[31].content + ""))
        html_tag.p(raw_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_211.name,
    type: "if",
    source: "(109:3) {#if typeof node.content === 'string'}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block_211, create_else_block_15];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (typeof /*node*/
    ctx2[31].content === "string")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      t = space();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t.parentNode, t);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(85:2) <TreeViewItem    bind:this={treeItems[i]}    bind:children={children[i]}    bind:group    bind:name    bind:value={node.id}    hideLead={!node.lead}    hideChildren={!node.children || node.children.length === 0}    open={expandedNodes.includes(node.id)}    disabled={disabledNodes.includes(node.id)}    checked={checkedNodes.includes(node.id)}    indeterminate={indeterminateNodes.includes(node.id)}    on:toggle={(e) => toggleNode(node, e.detail.open)}    on:groupChange={(e) => checkNode(node, e.detail.checked, e.detail.indeterminate)}    on:click={() =>     dispatch('click', {      id: node.id     })}    on:toggle={() => {     dispatch('toggle', {      id: node.id     });    }}   >",
    ctx
  });
  return block;
}
function create_else_block9(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*node*/
    ctx[31].leadProps
  ];
  var switch_value = (
    /*node*/
    ctx[31].lead
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty[0] & /*nodes*/
    1) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*node*/
        ctx2[31].leadProps
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*nodes*/
      1 && switch_value !== (switch_value = /*node*/
      ctx2[31].lead)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*nodes*/
        1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*node*/
          ctx2[31].leadProps
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block9.name,
    type: "else",
    source: "(117:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_112(ctx) {
  let html_tag;
  let raw_value = (
    /*node*/
    ctx[31].lead + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*nodes*/
      1 && raw_value !== (raw_value = /*node*/
      ctx2[31].lead + ""))
        html_tag.p(raw_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_112.name,
    type: "if",
    source: "(115:4) {#if typeof node.lead === 'string'}",
    ctx
  });
  return block;
}
function create_lead_slot(ctx) {
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block_112, create_else_block9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*node*/
    ctx2[31].lead === "string")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      t = space();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(t.parentNode, t);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_lead_slot.name,
    type: "slot",
    source: '(114:3) <svelte:fragment slot=\\"lead\\">',
    ctx
  });
  return block;
}
function create_children_slot(ctx) {
  let recursivetreeviewitem;
  let updating_expandedNodes;
  let updating_disabledNodes;
  let updating_checkedNodes;
  let updating_indeterminateNodes;
  let updating_treeItems;
  let t;
  let current;
  function recursivetreeviewitem_expandedNodes_binding(value) {
    ctx[12](value);
  }
  function recursivetreeviewitem_disabledNodes_binding(value) {
    ctx[13](value);
  }
  function recursivetreeviewitem_checkedNodes_binding(value) {
    ctx[14](value);
  }
  function recursivetreeviewitem_indeterminateNodes_binding(value) {
    ctx[15](value);
  }
  function recursivetreeviewitem_treeItems_binding(value) {
    ctx[16](
      value,
      /*i*/
      ctx[33]
    );
  }
  let recursivetreeviewitem_props = { nodes: (
    /*node*/
    ctx[31].children
  ) };
  if (
    /*expandedNodes*/
    ctx[1] !== void 0
  ) {
    recursivetreeviewitem_props.expandedNodes = /*expandedNodes*/
    ctx[1];
  }
  if (
    /*disabledNodes*/
    ctx[2] !== void 0
  ) {
    recursivetreeviewitem_props.disabledNodes = /*disabledNodes*/
    ctx[2];
  }
  if (
    /*checkedNodes*/
    ctx[3] !== void 0
  ) {
    recursivetreeviewitem_props.checkedNodes = /*checkedNodes*/
    ctx[3];
  }
  if (
    /*indeterminateNodes*/
    ctx[4] !== void 0
  ) {
    recursivetreeviewitem_props.indeterminateNodes = /*indeterminateNodes*/
    ctx[4];
  }
  if (
    /*children*/
    ctx[8][
      /*i*/
      ctx[33]
    ] !== void 0
  ) {
    recursivetreeviewitem_props.treeItems = /*children*/
    ctx[8][
      /*i*/
      ctx[33]
    ];
  }
  recursivetreeviewitem = new RecursiveTreeViewItem_default({
    props: recursivetreeviewitem_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(recursivetreeviewitem, "expandedNodes", recursivetreeviewitem_expandedNodes_binding));
  binding_callbacks.push(() => bind(recursivetreeviewitem, "disabledNodes", recursivetreeviewitem_disabledNodes_binding));
  binding_callbacks.push(() => bind(recursivetreeviewitem, "checkedNodes", recursivetreeviewitem_checkedNodes_binding));
  binding_callbacks.push(() => bind(recursivetreeviewitem, "indeterminateNodes", recursivetreeviewitem_indeterminateNodes_binding));
  binding_callbacks.push(() => bind(recursivetreeviewitem, "treeItems", recursivetreeviewitem_treeItems_binding));
  recursivetreeviewitem.$on(
    "click",
    /*click_handler*/
    ctx[17]
  );
  recursivetreeviewitem.$on(
    "toggle",
    /*toggle_handler*/
    ctx[18]
  );
  const block = {
    c: function create() {
      create_component(recursivetreeviewitem.$$.fragment);
      t = space();
    },
    l: function claim(nodes) {
      claim_component(recursivetreeviewitem.$$.fragment, nodes);
      t = claim_space(nodes);
    },
    m: function mount(target, anchor) {
      mount_component(recursivetreeviewitem, target, anchor);
      insert_hydration_dev(target, t, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const recursivetreeviewitem_changes = {};
      if (dirty[0] & /*nodes*/
      1)
        recursivetreeviewitem_changes.nodes = /*node*/
        ctx[31].children;
      if (!updating_expandedNodes && dirty[0] & /*expandedNodes*/
      2) {
        updating_expandedNodes = true;
        recursivetreeviewitem_changes.expandedNodes = /*expandedNodes*/
        ctx[1];
        add_flush_callback(() => updating_expandedNodes = false);
      }
      if (!updating_disabledNodes && dirty[0] & /*disabledNodes*/
      4) {
        updating_disabledNodes = true;
        recursivetreeviewitem_changes.disabledNodes = /*disabledNodes*/
        ctx[2];
        add_flush_callback(() => updating_disabledNodes = false);
      }
      if (!updating_checkedNodes && dirty[0] & /*checkedNodes*/
      8) {
        updating_checkedNodes = true;
        recursivetreeviewitem_changes.checkedNodes = /*checkedNodes*/
        ctx[3];
        add_flush_callback(() => updating_checkedNodes = false);
      }
      if (!updating_indeterminateNodes && dirty[0] & /*indeterminateNodes*/
      16) {
        updating_indeterminateNodes = true;
        recursivetreeviewitem_changes.indeterminateNodes = /*indeterminateNodes*/
        ctx[4];
        add_flush_callback(() => updating_indeterminateNodes = false);
      }
      if (!updating_treeItems && dirty[0] & /*children*/
      256) {
        updating_treeItems = true;
        recursivetreeviewitem_changes.treeItems = /*children*/
        ctx[8][
          /*i*/
          ctx[33]
        ];
        add_flush_callback(() => updating_treeItems = false);
      }
      recursivetreeviewitem.$set(recursivetreeviewitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(recursivetreeviewitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(recursivetreeviewitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      destroy_component(recursivetreeviewitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_children_slot.name,
    type: "slot",
    source: '(121:3) <svelte:fragment slot=\\"children\\">',
    ctx
  });
  return block;
}
function create_each_block9(ctx) {
  let treeviewitem;
  let i = (
    /*i*/
    ctx[33]
  );
  let updating_children;
  let updating_group;
  let updating_name;
  let updating_value;
  let current;
  const assign_treeviewitem = () => (
    /*treeviewitem_binding*/
    ctx[19](treeviewitem, i)
  );
  const unassign_treeviewitem = () => (
    /*treeviewitem_binding*/
    ctx[19](null, i)
  );
  function treeviewitem_children_binding(value) {
    ctx[20](
      value,
      /*i*/
      ctx[33]
    );
  }
  function treeviewitem_group_binding(value) {
    ctx[21](value);
  }
  function treeviewitem_name_binding(value) {
    ctx[22](value);
  }
  function treeviewitem_value_binding(value) {
    ctx[23](
      value,
      /*node*/
      ctx[31]
    );
  }
  function toggle_handler_1(...args) {
    return (
      /*toggle_handler_1*/
      ctx[24](
        /*node*/
        ctx[31],
        ...args
      )
    );
  }
  function groupChange_handler(...args) {
    return (
      /*groupChange_handler*/
      ctx[25](
        /*node*/
        ctx[31],
        ...args
      )
    );
  }
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[26](
        /*node*/
        ctx[31]
      )
    );
  }
  function toggle_handler_2() {
    return (
      /*toggle_handler_2*/
      ctx[27](
        /*node*/
        ctx[31]
      )
    );
  }
  let treeviewitem_props = {
    hideLead: !/*node*/
    ctx[31].lead,
    hideChildren: !/*node*/
    ctx[31].children || /*node*/
    ctx[31].children.length === 0,
    open: (
      /*expandedNodes*/
      ctx[1].includes(
        /*node*/
        ctx[31].id
      )
    ),
    disabled: (
      /*disabledNodes*/
      ctx[2].includes(
        /*node*/
        ctx[31].id
      )
    ),
    checked: (
      /*checkedNodes*/
      ctx[3].includes(
        /*node*/
        ctx[31].id
      )
    ),
    indeterminate: (
      /*indeterminateNodes*/
      ctx[4].includes(
        /*node*/
        ctx[31].id
      )
    ),
    $$slots: {
      children: [create_children_slot],
      lead: [create_lead_slot],
      default: [create_default_slot]
    },
    $$scope: { ctx }
  };
  if (
    /*children*/
    ctx[8][
      /*i*/
      ctx[33]
    ] !== void 0
  ) {
    treeviewitem_props.children = /*children*/
    ctx[8][
      /*i*/
      ctx[33]
    ];
  }
  if (
    /*group*/
    ctx[6] !== void 0
  ) {
    treeviewitem_props.group = /*group*/
    ctx[6];
  }
  if (
    /*name*/
    ctx[7] !== void 0
  ) {
    treeviewitem_props.name = /*name*/
    ctx[7];
  }
  if (
    /*node*/
    ctx[31].id !== void 0
  ) {
    treeviewitem_props.value = /*node*/
    ctx[31].id;
  }
  treeviewitem = new TreeViewItem_default({
    props: treeviewitem_props,
    $$inline: true
  });
  assign_treeviewitem();
  binding_callbacks.push(() => bind(treeviewitem, "children", treeviewitem_children_binding));
  binding_callbacks.push(() => bind(treeviewitem, "group", treeviewitem_group_binding));
  binding_callbacks.push(() => bind(treeviewitem, "name", treeviewitem_name_binding));
  binding_callbacks.push(() => bind(treeviewitem, "value", treeviewitem_value_binding));
  treeviewitem.$on("toggle", toggle_handler_1);
  treeviewitem.$on("groupChange", groupChange_handler);
  treeviewitem.$on("click", click_handler_1);
  treeviewitem.$on("toggle", toggle_handler_2);
  const block = {
    c: function create() {
      create_component(treeviewitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(treeviewitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(treeviewitem, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (i !== /*i*/
      ctx[33]) {
        unassign_treeviewitem();
        i = /*i*/
        ctx[33];
        assign_treeviewitem();
      }
      const treeviewitem_changes = {};
      if (dirty[0] & /*nodes*/
      1)
        treeviewitem_changes.hideLead = !/*node*/
        ctx[31].lead;
      if (dirty[0] & /*nodes*/
      1)
        treeviewitem_changes.hideChildren = !/*node*/
        ctx[31].children || /*node*/
        ctx[31].children.length === 0;
      if (dirty[0] & /*expandedNodes, nodes*/
      3)
        treeviewitem_changes.open = /*expandedNodes*/
        ctx[1].includes(
          /*node*/
          ctx[31].id
        );
      if (dirty[0] & /*disabledNodes, nodes*/
      5)
        treeviewitem_changes.disabled = /*disabledNodes*/
        ctx[2].includes(
          /*node*/
          ctx[31].id
        );
      if (dirty[0] & /*checkedNodes, nodes*/
      9)
        treeviewitem_changes.checked = /*checkedNodes*/
        ctx[3].includes(
          /*node*/
          ctx[31].id
        );
      if (dirty[0] & /*indeterminateNodes, nodes*/
      17)
        treeviewitem_changes.indeterminate = /*indeterminateNodes*/
        ctx[4].includes(
          /*node*/
          ctx[31].id
        );
      if (dirty[0] & /*nodes, expandedNodes, disabledNodes, checkedNodes, indeterminateNodes, children*/
      287 | dirty[1] & /*$$scope*/
      8) {
        treeviewitem_changes.$$scope = { dirty, ctx };
      }
      if (!updating_children && dirty[0] & /*children*/
      256) {
        updating_children = true;
        treeviewitem_changes.children = /*children*/
        ctx[8][
          /*i*/
          ctx[33]
        ];
        add_flush_callback(() => updating_children = false);
      }
      if (!updating_group && dirty[0] & /*group*/
      64) {
        updating_group = true;
        treeviewitem_changes.group = /*group*/
        ctx[6];
        add_flush_callback(() => updating_group = false);
      }
      if (!updating_name && dirty[0] & /*name*/
      128) {
        updating_name = true;
        treeviewitem_changes.name = /*name*/
        ctx[7];
        add_flush_callback(() => updating_name = false);
      }
      if (!updating_value && dirty[0] & /*nodes*/
      1) {
        updating_value = true;
        treeviewitem_changes.value = /*node*/
        ctx[31].id;
        add_flush_callback(() => updating_value = false);
      }
      treeviewitem.$set(treeviewitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(treeviewitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(treeviewitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      unassign_treeviewitem();
      destroy_component(treeviewitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block9.name,
    type: "each",
    source: "(84:1) {#each nodes as node, i}",
    ctx
  });
  return block;
}
function create_fragment32(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*nodes*/
    ctx[0] && /*nodes*/
    ctx[0].length > 0 && create_if_block24(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*nodes*/
        ctx2[0] && /*nodes*/
        ctx2[0].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*nodes*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block24(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RecursiveTreeViewItem", slots, []);
  let { nodes = [] } = $$props;
  let { expandedNodes = [] } = $$props;
  let { disabledNodes = [] } = $$props;
  let { checkedNodes = [] } = $$props;
  let { indeterminateNodes = [] } = $$props;
  let selection = getContext("selection");
  let multiple = getContext("multiple");
  let relational = getContext("relational");
  let group = multiple ? [] : "";
  let name = "";
  const dispatch = createEventDispatcher();
  function toggleNode(node, open) {
    var _a;
    if (!((_a = node.children) == null ? void 0 : _a.length))
      return;
    if (open) {
      if (!expandedNodes.includes(node.id)) {
        expandedNodes.push(node.id);
        $$invalidate(1, expandedNodes);
      }
    } else {
      if (expandedNodes.includes(node.id)) {
        expandedNodes.splice(expandedNodes.indexOf(node.id), 1);
        $$invalidate(1, expandedNodes);
      }
    }
  }
  function checkNode(node, checked, indeterminate) {
    if (checked) {
      if (!checkedNodes.includes(node.id)) {
        checkedNodes.push(node.id);
        $$invalidate(3, checkedNodes);
      }
      if (!indeterminate && indeterminateNodes.includes(node.id)) {
        indeterminateNodes.splice(indeterminateNodes.indexOf(node.id), 1);
        $$invalidate(4, indeterminateNodes);
      }
    } else {
      if (checkedNodes.includes(node.id)) {
        checkedNodes.splice(checkedNodes.indexOf(node.id), 1);
        $$invalidate(3, checkedNodes);
      }
      if (indeterminate && !indeterminateNodes.includes(node.id)) {
        indeterminateNodes.push(node.id);
        $$invalidate(4, indeterminateNodes);
      } else if (!indeterminate && indeterminateNodes.includes(node.id)) {
        indeterminateNodes.splice(indeterminateNodes.indexOf(node.id), 1);
        $$invalidate(4, indeterminateNodes);
      }
    }
  }
  if (selection) {
    if (multiple) {
      nodes.forEach((node) => {
        if (!Array.isArray(group))
          return;
        if (checkedNodes.includes(node.id) && !group.includes(node.id)) {
          group.push(node.id);
        }
      });
      group = group;
    } else {
      nodes.forEach((node) => {
        if (checkedNodes.includes(node.id) && group !== node.id) {
          $$invalidate(6, group = node.id);
        }
      });
    }
  }
  onMount(async () => {
    if (selection) {
      $$invalidate(7, name = String(Math.random()));
      if (!relational)
        $$invalidate(5, treeItems = []);
    }
  });
  let { treeItems = [] } = $$props;
  let children2 = [];
  const writable_props = [
    "nodes",
    "expandedNodes",
    "disabledNodes",
    "checkedNodes",
    "indeterminateNodes",
    "treeItems"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RecursiveTreeViewItem> was created with unknown prop '${key}'`);
  });
  function recursivetreeviewitem_expandedNodes_binding(value) {
    expandedNodes = value;
    $$invalidate(1, expandedNodes);
  }
  function recursivetreeviewitem_disabledNodes_binding(value) {
    disabledNodes = value;
    $$invalidate(2, disabledNodes);
  }
  function recursivetreeviewitem_checkedNodes_binding(value) {
    checkedNodes = value;
    $$invalidate(3, checkedNodes);
  }
  function recursivetreeviewitem_indeterminateNodes_binding(value) {
    indeterminateNodes = value;
    $$invalidate(4, indeterminateNodes);
  }
  function recursivetreeviewitem_treeItems_binding(value, i) {
    if ($$self.$$.not_equal(children2[i], value)) {
      children2[i] = value;
      $$invalidate(8, children2);
    }
  }
  const click_handler = (e) => dispatch("click", { id: e.detail.id });
  const toggle_handler = (e) => dispatch("toggle", { id: e.detail.id });
  function treeviewitem_binding($$value, i) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      treeItems[i] = $$value;
      $$invalidate(5, treeItems);
    });
  }
  function treeviewitem_children_binding(value, i) {
    if ($$self.$$.not_equal(children2[i], value)) {
      children2[i] = value;
      $$invalidate(8, children2);
    }
  }
  function treeviewitem_group_binding(value) {
    group = value;
    $$invalidate(6, group);
  }
  function treeviewitem_name_binding(value) {
    name = value;
    $$invalidate(7, name);
  }
  function treeviewitem_value_binding(value, node) {
    if ($$self.$$.not_equal(node.id, value)) {
      node.id = value;
      $$invalidate(0, nodes);
    }
  }
  const toggle_handler_1 = (node, e) => toggleNode(node, e.detail.open);
  const groupChange_handler = (node, e) => checkNode(node, e.detail.checked, e.detail.indeterminate);
  const click_handler_1 = (node) => dispatch("click", { id: node.id });
  const toggle_handler_2 = (node) => {
    dispatch("toggle", { id: node.id });
  };
  $$self.$$set = ($$props2) => {
    if ("nodes" in $$props2)
      $$invalidate(0, nodes = $$props2.nodes);
    if ("expandedNodes" in $$props2)
      $$invalidate(1, expandedNodes = $$props2.expandedNodes);
    if ("disabledNodes" in $$props2)
      $$invalidate(2, disabledNodes = $$props2.disabledNodes);
    if ("checkedNodes" in $$props2)
      $$invalidate(3, checkedNodes = $$props2.checkedNodes);
    if ("indeterminateNodes" in $$props2)
      $$invalidate(4, indeterminateNodes = $$props2.indeterminateNodes);
    if ("treeItems" in $$props2)
      $$invalidate(5, treeItems = $$props2.treeItems);
  };
  $$self.$capture_state = () => ({
    TreeViewItem: TreeViewItem_default,
    RecursiveTreeViewItem: RecursiveTreeViewItem_default,
    createEventDispatcher,
    getContext,
    onMount,
    nodes,
    expandedNodes,
    disabledNodes,
    checkedNodes,
    indeterminateNodes,
    selection,
    multiple,
    relational,
    group,
    name,
    dispatch,
    toggleNode,
    checkNode,
    treeItems,
    children: children2
  });
  $$self.$inject_state = ($$props2) => {
    if ("nodes" in $$props2)
      $$invalidate(0, nodes = $$props2.nodes);
    if ("expandedNodes" in $$props2)
      $$invalidate(1, expandedNodes = $$props2.expandedNodes);
    if ("disabledNodes" in $$props2)
      $$invalidate(2, disabledNodes = $$props2.disabledNodes);
    if ("checkedNodes" in $$props2)
      $$invalidate(3, checkedNodes = $$props2.checkedNodes);
    if ("indeterminateNodes" in $$props2)
      $$invalidate(4, indeterminateNodes = $$props2.indeterminateNodes);
    if ("selection" in $$props2)
      selection = $$props2.selection;
    if ("multiple" in $$props2)
      multiple = $$props2.multiple;
    if ("relational" in $$props2)
      relational = $$props2.relational;
    if ("group" in $$props2)
      $$invalidate(6, group = $$props2.group);
    if ("name" in $$props2)
      $$invalidate(7, name = $$props2.name);
    if ("treeItems" in $$props2)
      $$invalidate(5, treeItems = $$props2.treeItems);
    if ("children" in $$props2)
      $$invalidate(8, children2 = $$props2.children);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    nodes,
    expandedNodes,
    disabledNodes,
    checkedNodes,
    indeterminateNodes,
    treeItems,
    group,
    name,
    children2,
    dispatch,
    toggleNode,
    checkNode,
    recursivetreeviewitem_expandedNodes_binding,
    recursivetreeviewitem_disabledNodes_binding,
    recursivetreeviewitem_checkedNodes_binding,
    recursivetreeviewitem_indeterminateNodes_binding,
    recursivetreeviewitem_treeItems_binding,
    click_handler,
    toggle_handler,
    treeviewitem_binding,
    treeviewitem_children_binding,
    treeviewitem_group_binding,
    treeviewitem_name_binding,
    treeviewitem_value_binding,
    toggle_handler_1,
    groupChange_handler,
    click_handler_1,
    toggle_handler_2
  ];
}
var RecursiveTreeViewItem_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance32,
      create_fragment32,
      safe_not_equal,
      {
        nodes: 0,
        expandedNodes: 1,
        disabledNodes: 2,
        checkedNodes: 3,
        indeterminateNodes: 4,
        treeItems: 5
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RecursiveTreeViewItem_1",
      options,
      id: create_fragment32.name
    });
  }
  get nodes() {
    throw new Error("<RecursiveTreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodes(value) {
    throw new Error("<RecursiveTreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandedNodes() {
    throw new Error("<RecursiveTreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandedNodes(value) {
    throw new Error("<RecursiveTreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabledNodes() {
    throw new Error("<RecursiveTreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabledNodes(value) {
    throw new Error("<RecursiveTreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checkedNodes() {
    throw new Error("<RecursiveTreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checkedNodes(value) {
    throw new Error("<RecursiveTreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminateNodes() {
    throw new Error("<RecursiveTreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminateNodes(value) {
    throw new Error("<RecursiveTreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get treeItems() {
    throw new Error("<RecursiveTreeViewItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set treeItems(value) {
    throw new Error("<RecursiveTreeViewItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RecursiveTreeViewItem_default = RecursiveTreeViewItem_1;

// node_modules/@skeletonlabs/skeleton/dist/components/TreeView/RecursiveTreeView.svelte
var file32 = "node_modules/@skeletonlabs/skeleton/dist/components/TreeView/RecursiveTreeView.svelte";
function create_if_block25(ctx) {
  let recursivetreeviewitem;
  let updating_expandedNodes;
  let updating_disabledNodes;
  let updating_checkedNodes;
  let updating_indeterminateNodes;
  let current;
  function recursivetreeviewitem_expandedNodes_binding(value) {
    ctx[24](value);
  }
  function recursivetreeviewitem_disabledNodes_binding(value) {
    ctx[25](value);
  }
  function recursivetreeviewitem_checkedNodes_binding(value) {
    ctx[26](value);
  }
  function recursivetreeviewitem_indeterminateNodes_binding(value) {
    ctx[27](value);
  }
  let recursivetreeviewitem_props = { nodes: (
    /*nodes*/
    ctx[5]
  ) };
  if (
    /*expandedNodes*/
    ctx[0] !== void 0
  ) {
    recursivetreeviewitem_props.expandedNodes = /*expandedNodes*/
    ctx[0];
  }
  if (
    /*disabledNodes*/
    ctx[1] !== void 0
  ) {
    recursivetreeviewitem_props.disabledNodes = /*disabledNodes*/
    ctx[1];
  }
  if (
    /*checkedNodes*/
    ctx[2] !== void 0
  ) {
    recursivetreeviewitem_props.checkedNodes = /*checkedNodes*/
    ctx[2];
  }
  if (
    /*indeterminateNodes*/
    ctx[3] !== void 0
  ) {
    recursivetreeviewitem_props.indeterminateNodes = /*indeterminateNodes*/
    ctx[3];
  }
  recursivetreeviewitem = new RecursiveTreeViewItem_default({
    props: recursivetreeviewitem_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(recursivetreeviewitem, "expandedNodes", recursivetreeviewitem_expandedNodes_binding));
  binding_callbacks.push(() => bind(recursivetreeviewitem, "disabledNodes", recursivetreeviewitem_disabledNodes_binding));
  binding_callbacks.push(() => bind(recursivetreeviewitem, "checkedNodes", recursivetreeviewitem_checkedNodes_binding));
  binding_callbacks.push(() => bind(recursivetreeviewitem, "indeterminateNodes", recursivetreeviewitem_indeterminateNodes_binding));
  recursivetreeviewitem.$on(
    "click",
    /*onClick*/
    ctx[8]
  );
  recursivetreeviewitem.$on(
    "toggle",
    /*onToggle*/
    ctx[9]
  );
  const block = {
    c: function create() {
      create_component(recursivetreeviewitem.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(recursivetreeviewitem.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(recursivetreeviewitem, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const recursivetreeviewitem_changes = {};
      if (dirty & /*nodes*/
      32)
        recursivetreeviewitem_changes.nodes = /*nodes*/
        ctx2[5];
      if (!updating_expandedNodes && dirty & /*expandedNodes*/
      1) {
        updating_expandedNodes = true;
        recursivetreeviewitem_changes.expandedNodes = /*expandedNodes*/
        ctx2[0];
        add_flush_callback(() => updating_expandedNodes = false);
      }
      if (!updating_disabledNodes && dirty & /*disabledNodes*/
      2) {
        updating_disabledNodes = true;
        recursivetreeviewitem_changes.disabledNodes = /*disabledNodes*/
        ctx2[1];
        add_flush_callback(() => updating_disabledNodes = false);
      }
      if (!updating_checkedNodes && dirty & /*checkedNodes*/
      4) {
        updating_checkedNodes = true;
        recursivetreeviewitem_changes.checkedNodes = /*checkedNodes*/
        ctx2[2];
        add_flush_callback(() => updating_checkedNodes = false);
      }
      if (!updating_indeterminateNodes && dirty & /*indeterminateNodes*/
      8) {
        updating_indeterminateNodes = true;
        recursivetreeviewitem_changes.indeterminateNodes = /*indeterminateNodes*/
        ctx2[3];
        add_flush_callback(() => updating_indeterminateNodes = false);
      }
      recursivetreeviewitem.$set(recursivetreeviewitem_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(recursivetreeviewitem.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(recursivetreeviewitem.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(recursivetreeviewitem, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block25.name,
    type: "if",
    source: "(53:1) {#if nodes && nodes.length > 0}",
    ctx
  });
  return block;
}
function create_fragment33(ctx) {
  let div;
  let div_class_value;
  let current;
  let if_block = (
    /*nodes*/
    ctx[5] && /*nodes*/
    ctx[5].length > 0 && create_if_block25(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-multiselectable": true,
        "aria-label": true
      });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "tree " + /*classesBase*/
      ctx[7]);
      attr_dev(div, "data-testid", "tree");
      attr_dev(div, "role", "tree");
      attr_dev(
        div,
        "aria-multiselectable",
        /*multiple*/
        ctx[4]
      );
      attr_dev(
        div,
        "aria-label",
        /*labelledby*/
        ctx[6]
      );
      add_location(div, file32, 51, 0, 1581);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*nodes*/
        ctx2[5] && /*nodes*/
        ctx2[5].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*nodes*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block25(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*classesBase*/
      128 && div_class_value !== (div_class_value = "tree " + /*classesBase*/
      ctx2[7])) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty & /*multiple*/
      16) {
        attr_dev(
          div,
          "aria-multiselectable",
          /*multiple*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*labelledby*/
      64) {
        attr_dev(
          div,
          "aria-label",
          /*labelledby*/
          ctx2[6]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let classesBase;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RecursiveTreeView", slots, []);
  let { selection = false } = $$props;
  let { multiple = false } = $$props;
  let { relational = false } = $$props;
  let { nodes = [] } = $$props;
  let { expandedNodes = [] } = $$props;
  let { disabledNodes = [] } = $$props;
  let { checkedNodes = [] } = $$props;
  let { indeterminateNodes = [] } = $$props;
  let { width = "w-full" } = $$props;
  let { spacing = "space-y-1" } = $$props;
  let { padding = "py-4 px-4" } = $$props;
  let { indent = "ml-4" } = $$props;
  let { hover = "hover:variant-soft" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { caretOpen = "rotate-180" } = $$props;
  let { caretClosed = "" } = $$props;
  let { hyphenOpacity = "opacity-10" } = $$props;
  let { regionSummary = "" } = $$props;
  let { regionSymbol = "" } = $$props;
  let { regionChildren = "" } = $$props;
  let { labelledby = "" } = $$props;
  setContext("selection", selection);
  setContext("multiple", multiple);
  setContext("relational", relational);
  setContext("padding", padding);
  setContext("indent", indent);
  setContext("hover", hover);
  setContext("rounded", rounded);
  setContext("caretOpen", caretOpen);
  setContext("caretClosed", caretClosed);
  setContext("hyphenOpacity", hyphenOpacity);
  setContext("regionSummary", regionSummary);
  setContext("regionSymbol", regionSymbol);
  setContext("regionChildren", regionChildren);
  const dispatch = createEventDispatcher();
  function onClick(event) {
    dispatch("click", { id: event.detail.id });
  }
  function onToggle(event) {
    dispatch("toggle", { id: event.detail.id });
  }
  function recursivetreeviewitem_expandedNodes_binding(value) {
    expandedNodes = value;
    $$invalidate(0, expandedNodes);
  }
  function recursivetreeviewitem_disabledNodes_binding(value) {
    disabledNodes = value;
    $$invalidate(1, disabledNodes);
  }
  function recursivetreeviewitem_checkedNodes_binding(value) {
    checkedNodes = value;
    $$invalidate(2, checkedNodes);
  }
  function recursivetreeviewitem_indeterminateNodes_binding(value) {
    indeterminateNodes = value;
    $$invalidate(3, indeterminateNodes);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("selection" in $$new_props)
      $$invalidate(10, selection = $$new_props.selection);
    if ("multiple" in $$new_props)
      $$invalidate(4, multiple = $$new_props.multiple);
    if ("relational" in $$new_props)
      $$invalidate(11, relational = $$new_props.relational);
    if ("nodes" in $$new_props)
      $$invalidate(5, nodes = $$new_props.nodes);
    if ("expandedNodes" in $$new_props)
      $$invalidate(0, expandedNodes = $$new_props.expandedNodes);
    if ("disabledNodes" in $$new_props)
      $$invalidate(1, disabledNodes = $$new_props.disabledNodes);
    if ("checkedNodes" in $$new_props)
      $$invalidate(2, checkedNodes = $$new_props.checkedNodes);
    if ("indeterminateNodes" in $$new_props)
      $$invalidate(3, indeterminateNodes = $$new_props.indeterminateNodes);
    if ("width" in $$new_props)
      $$invalidate(12, width = $$new_props.width);
    if ("spacing" in $$new_props)
      $$invalidate(13, spacing = $$new_props.spacing);
    if ("padding" in $$new_props)
      $$invalidate(14, padding = $$new_props.padding);
    if ("indent" in $$new_props)
      $$invalidate(15, indent = $$new_props.indent);
    if ("hover" in $$new_props)
      $$invalidate(16, hover = $$new_props.hover);
    if ("rounded" in $$new_props)
      $$invalidate(17, rounded = $$new_props.rounded);
    if ("caretOpen" in $$new_props)
      $$invalidate(18, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$new_props)
      $$invalidate(19, caretClosed = $$new_props.caretClosed);
    if ("hyphenOpacity" in $$new_props)
      $$invalidate(20, hyphenOpacity = $$new_props.hyphenOpacity);
    if ("regionSummary" in $$new_props)
      $$invalidate(21, regionSummary = $$new_props.regionSummary);
    if ("regionSymbol" in $$new_props)
      $$invalidate(22, regionSymbol = $$new_props.regionSymbol);
    if ("regionChildren" in $$new_props)
      $$invalidate(23, regionChildren = $$new_props.regionChildren);
    if ("labelledby" in $$new_props)
      $$invalidate(6, labelledby = $$new_props.labelledby);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    setContext,
    RecursiveTreeViewItem: RecursiveTreeViewItem_default,
    selection,
    multiple,
    relational,
    nodes,
    expandedNodes,
    disabledNodes,
    checkedNodes,
    indeterminateNodes,
    width,
    spacing,
    padding,
    indent,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    hyphenOpacity,
    regionSummary,
    regionSymbol,
    regionChildren,
    labelledby,
    dispatch,
    onClick,
    onToggle,
    classesBase
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(29, $$props = assign(assign({}, $$props), $$new_props));
    if ("selection" in $$props)
      $$invalidate(10, selection = $$new_props.selection);
    if ("multiple" in $$props)
      $$invalidate(4, multiple = $$new_props.multiple);
    if ("relational" in $$props)
      $$invalidate(11, relational = $$new_props.relational);
    if ("nodes" in $$props)
      $$invalidate(5, nodes = $$new_props.nodes);
    if ("expandedNodes" in $$props)
      $$invalidate(0, expandedNodes = $$new_props.expandedNodes);
    if ("disabledNodes" in $$props)
      $$invalidate(1, disabledNodes = $$new_props.disabledNodes);
    if ("checkedNodes" in $$props)
      $$invalidate(2, checkedNodes = $$new_props.checkedNodes);
    if ("indeterminateNodes" in $$props)
      $$invalidate(3, indeterminateNodes = $$new_props.indeterminateNodes);
    if ("width" in $$props)
      $$invalidate(12, width = $$new_props.width);
    if ("spacing" in $$props)
      $$invalidate(13, spacing = $$new_props.spacing);
    if ("padding" in $$props)
      $$invalidate(14, padding = $$new_props.padding);
    if ("indent" in $$props)
      $$invalidate(15, indent = $$new_props.indent);
    if ("hover" in $$props)
      $$invalidate(16, hover = $$new_props.hover);
    if ("rounded" in $$props)
      $$invalidate(17, rounded = $$new_props.rounded);
    if ("caretOpen" in $$props)
      $$invalidate(18, caretOpen = $$new_props.caretOpen);
    if ("caretClosed" in $$props)
      $$invalidate(19, caretClosed = $$new_props.caretClosed);
    if ("hyphenOpacity" in $$props)
      $$invalidate(20, hyphenOpacity = $$new_props.hyphenOpacity);
    if ("regionSummary" in $$props)
      $$invalidate(21, regionSummary = $$new_props.regionSummary);
    if ("regionSymbol" in $$props)
      $$invalidate(22, regionSymbol = $$new_props.regionSymbol);
    if ("regionChildren" in $$props)
      $$invalidate(23, regionChildren = $$new_props.regionChildren);
    if ("labelledby" in $$props)
      $$invalidate(6, labelledby = $$new_props.labelledby);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(7, classesBase = `${width} ${spacing} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    expandedNodes,
    disabledNodes,
    checkedNodes,
    indeterminateNodes,
    multiple,
    nodes,
    labelledby,
    classesBase,
    onClick,
    onToggle,
    selection,
    relational,
    width,
    spacing,
    padding,
    indent,
    hover,
    rounded,
    caretOpen,
    caretClosed,
    hyphenOpacity,
    regionSummary,
    regionSymbol,
    regionChildren,
    recursivetreeviewitem_expandedNodes_binding,
    recursivetreeviewitem_disabledNodes_binding,
    recursivetreeviewitem_checkedNodes_binding,
    recursivetreeviewitem_indeterminateNodes_binding
  ];
}
var RecursiveTreeView = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, {
      selection: 10,
      multiple: 4,
      relational: 11,
      nodes: 5,
      expandedNodes: 0,
      disabledNodes: 1,
      checkedNodes: 2,
      indeterminateNodes: 3,
      width: 12,
      spacing: 13,
      padding: 14,
      indent: 15,
      hover: 16,
      rounded: 17,
      caretOpen: 18,
      caretClosed: 19,
      hyphenOpacity: 20,
      regionSummary: 21,
      regionSymbol: 22,
      regionChildren: 23,
      labelledby: 6
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RecursiveTreeView",
      options,
      id: create_fragment33.name
    });
  }
  get selection() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get relational() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set relational(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodes() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodes(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandedNodes() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandedNodes(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabledNodes() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabledNodes(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checkedNodes() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checkedNodes(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminateNodes() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminateNodes(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indent() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indent(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hover() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hover(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretOpen() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretOpen(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get caretClosed() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set caretClosed(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hyphenOpacity() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hyphenOpacity(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionSummary() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionSummary(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionSymbol() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionSymbol(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionChildren() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionChildren(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<RecursiveTreeView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<RecursiveTreeView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RecursiveTreeView_default = RecursiveTreeView;

// node_modules/@skeletonlabs/skeleton/dist/utilities/CodeBlock/CodeBlock.svelte
var file33 = "node_modules/@skeletonlabs/skeleton/dist/utilities/CodeBlock/CodeBlock.svelte";
function create_if_block26(ctx) {
  let div;
  let header;
  let span;
  let t0_value = languageFormatter(
    /*language*/
    ctx[0]
  ) + "";
  let t0;
  let t1;
  let button_1;
  let t2_value = (!/*copyState*/
  ctx[7] ? (
    /*buttonLabel*/
    ctx[3]
  ) : (
    /*buttonCopied*/
    ctx[4]
  )) + "";
  let t2;
  let button_1_class_value;
  let clipboard_action;
  let header_class_value;
  let t3;
  let pre;
  let code_1;
  let code_1_class_value;
  let pre_class_value;
  let div_class_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*formatted*/
      ctx2[6]
    )
      return create_if_block_113;
    return create_else_block10;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      header = element("header");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      button_1 = element("button");
      t2 = text(t2_value);
      t3 = space();
      pre = element("pre");
      code_1 = element("code");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div_nodes = children(div);
      header = claim_element(div_nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      span = claim_element(header_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(header_nodes);
      button_1 = claim_element(header_nodes, "BUTTON", { type: true, class: true });
      var button_1_nodes = children(button_1);
      t2 = claim_text(button_1_nodes, t2_value);
      button_1_nodes.forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      t3 = claim_space(div_nodes);
      pre = claim_element(div_nodes, "PRE", { class: true });
      var pre_nodes = children(pre);
      code_1 = claim_element(pre_nodes, "CODE", { class: true });
      var code_1_nodes = children(code_1);
      if_block.l(code_1_nodes);
      code_1_nodes.forEach(detach_dev);
      pre_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "codeblock-language");
      add_location(span, file33, 60, 2, 1832);
      attr_dev(button_1, "type", "button");
      attr_dev(button_1, "class", button_1_class_value = "codeblock-btn " + /*button*/
      ctx[2]);
      add_location(button_1, file33, 62, 2, 1927);
      attr_dev(header, "class", header_class_value = "codeblock-header " + cHeader3);
      add_location(header, file33, 58, 1, 1766);
      attr_dev(code_1, "class", code_1_class_value = "codeblock-code language-" + /*language*/
      ctx[0] + " lineNumbers");
      add_location(code_1, file33, 67, 35, 2147);
      attr_dev(pre, "class", pre_class_value = "codeblock-pre " + cPre);
      add_location(pre, file33, 67, 1, 2113);
      attr_dev(div, "class", div_class_value = "codeblock " + /*classesBase*/
      ctx[8]);
      attr_dev(div, "data-testid", "codeblock");
      add_location(div, file33, 56, 0, 1686);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, header);
      append_hydration_dev(header, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(header, t1);
      append_hydration_dev(header, button_1);
      append_hydration_dev(button_1, t2);
      append_hydration_dev(div, t3);
      append_hydration_dev(div, pre);
      append_hydration_dev(pre, code_1);
      if_block.m(code_1, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            button_1,
            "click",
            /*onCopyClick*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          action_destroyer(clipboard_action = clipboard.call(
            null,
            button_1,
            /*code*/
            ctx[1]
          ))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*language*/
      1 && t0_value !== (t0_value = languageFormatter(
        /*language*/
        ctx2[0]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*copyState, buttonLabel, buttonCopied*/
      152 && t2_value !== (t2_value = (!/*copyState*/
      ctx2[7] ? (
        /*buttonLabel*/
        ctx2[3]
      ) : (
        /*buttonCopied*/
        ctx2[4]
      )) + ""))
        set_data_dev(t2, t2_value);
      if (dirty & /*button*/
      4 && button_1_class_value !== (button_1_class_value = "codeblock-btn " + /*button*/
      ctx2[2])) {
        attr_dev(button_1, "class", button_1_class_value);
      }
      if (clipboard_action && is_function(clipboard_action.update) && dirty & /*code*/
      2)
        clipboard_action.update.call(
          null,
          /*code*/
          ctx2[1]
        );
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(code_1, null);
        }
      }
      if (dirty & /*language*/
      1 && code_1_class_value !== (code_1_class_value = "codeblock-code language-" + /*language*/
      ctx2[0] + " lineNumbers")) {
        attr_dev(code_1, "class", code_1_class_value);
      }
      if (dirty & /*classesBase*/
      256 && div_class_value !== (div_class_value = "codeblock " + /*classesBase*/
      ctx2[8])) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block26.name,
    type: "if",
    source: "(56:0) {#if language && code}",
    ctx
  });
  return block;
}
function create_else_block10(ctx) {
  let t_value = (
    /*code*/
    ctx[1].trim() + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*code*/
      2 && t_value !== (t_value = /*code*/
      ctx2[1].trim() + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block10.name,
    type: "else",
    source: "(68:130) {:else}",
    ctx
  });
  return block;
}
function create_if_block_113(ctx) {
  let html_tag;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(
        /*displayCode*/
        ctx[5],
        target,
        anchor
      );
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*displayCode*/
      32)
        html_tag.p(
          /*displayCode*/
          ctx2[5]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_113.name,
    type: "if",
    source: "(68:96) {#if formatted}",
    ctx
  });
  return block;
}
function create_fragment34(ctx) {
  let if_block_anchor;
  let if_block = (
    /*language*/
    ctx[0] && /*code*/
    ctx[1] && create_if_block26(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*language*/
        ctx2[0] && /*code*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block26(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase24 = "overflow-hidden shadow";
var cHeader3 = "text-xs text-white/50 uppercase flex justify-between items-center p-2 pl-4";
var cPre = "whitespace-pre-wrap break-all p-4 pt-1";
function languageFormatter(lang) {
  if (lang === "js")
    return "javascript";
  if (lang === "ts")
    return "typescript";
  if (lang === "shell")
    return "terminal";
  return lang;
}
function instance34($$self, $$props, $$invalidate) {
  let classesBase;
  let $storeHighlightJs;
  validate_store(storeHighlightJs, "storeHighlightJs");
  component_subscribe($$self, storeHighlightJs, ($$value) => $$invalidate(17, $storeHighlightJs = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeBlock", slots, []);
  const dispatch = createEventDispatcher();
  let { language = "plaintext" } = $$props;
  let { code = "" } = $$props;
  let { lineNumbers = false } = $$props;
  let { background = "bg-neutral-900/90" } = $$props;
  let { blur = "" } = $$props;
  let { text: text2 = "text-sm" } = $$props;
  let { color = "text-white" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { shadow = "shadow" } = $$props;
  let { button = "btn btn-sm variant-soft !text-white" } = $$props;
  let { buttonLabel = "Copy" } = $$props;
  let { buttonCopied = "" } = $$props;
  let formatted = false;
  let displayCode = code;
  let copyState = false;
  function onCopyClick() {
    $$invalidate(7, copyState = true);
    setTimeout(
      () => {
        $$invalidate(7, copyState = false);
      },
      2e3
    );
    dispatch("copy");
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("language" in $$new_props)
      $$invalidate(0, language = $$new_props.language);
    if ("code" in $$new_props)
      $$invalidate(1, code = $$new_props.code);
    if ("lineNumbers" in $$new_props)
      $$invalidate(10, lineNumbers = $$new_props.lineNumbers);
    if ("background" in $$new_props)
      $$invalidate(11, background = $$new_props.background);
    if ("blur" in $$new_props)
      $$invalidate(12, blur = $$new_props.blur);
    if ("text" in $$new_props)
      $$invalidate(13, text2 = $$new_props.text);
    if ("color" in $$new_props)
      $$invalidate(14, color = $$new_props.color);
    if ("rounded" in $$new_props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(16, shadow = $$new_props.shadow);
    if ("button" in $$new_props)
      $$invalidate(2, button = $$new_props.button);
    if ("buttonLabel" in $$new_props)
      $$invalidate(3, buttonLabel = $$new_props.buttonLabel);
    if ("buttonCopied" in $$new_props)
      $$invalidate(4, buttonCopied = $$new_props.buttonCopied);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    storeHighlightJs,
    clipboard,
    language,
    code,
    lineNumbers,
    background,
    blur,
    text: text2,
    color,
    rounded,
    shadow,
    button,
    buttonLabel,
    buttonCopied,
    cBase: cBase24,
    cHeader: cHeader3,
    cPre,
    formatted,
    displayCode,
    copyState,
    languageFormatter,
    onCopyClick,
    classesBase,
    $storeHighlightJs
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(19, $$props = assign(assign({}, $$props), $$new_props));
    if ("language" in $$props)
      $$invalidate(0, language = $$new_props.language);
    if ("code" in $$props)
      $$invalidate(1, code = $$new_props.code);
    if ("lineNumbers" in $$props)
      $$invalidate(10, lineNumbers = $$new_props.lineNumbers);
    if ("background" in $$props)
      $$invalidate(11, background = $$new_props.background);
    if ("blur" in $$props)
      $$invalidate(12, blur = $$new_props.blur);
    if ("text" in $$props)
      $$invalidate(13, text2 = $$new_props.text);
    if ("color" in $$props)
      $$invalidate(14, color = $$new_props.color);
    if ("rounded" in $$props)
      $$invalidate(15, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(16, shadow = $$new_props.shadow);
    if ("button" in $$props)
      $$invalidate(2, button = $$new_props.button);
    if ("buttonLabel" in $$props)
      $$invalidate(3, buttonLabel = $$new_props.buttonLabel);
    if ("buttonCopied" in $$props)
      $$invalidate(4, buttonCopied = $$new_props.buttonCopied);
    if ("formatted" in $$props)
      $$invalidate(6, formatted = $$new_props.formatted);
    if ("displayCode" in $$props)
      $$invalidate(5, displayCode = $$new_props.displayCode);
    if ("copyState" in $$props)
      $$invalidate(7, copyState = $$new_props.copyState);
    if ("classesBase" in $$props)
      $$invalidate(8, classesBase = $$new_props.classesBase);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$storeHighlightJs, code, language*/
    131075) {
      $:
        if ($storeHighlightJs !== void 0) {
          $$invalidate(5, displayCode = $storeHighlightJs.highlight(code, { language }).value.trim());
          $$invalidate(6, formatted = true);
        }
    }
    if ($$self.$$.dirty & /*lineNumbers, displayCode*/
    1056) {
      $:
        if (lineNumbers) {
          $$invalidate(5, displayCode = displayCode.replace(/^/gm, () => {
            return '<span class="line"></span>	';
          }));
          $$invalidate(6, formatted = true);
        }
    }
    $:
      $$invalidate(8, classesBase = `${cBase24} ${background} ${blur} ${text2} ${color} ${rounded} ${shadow} ${$$props.class ?? ""}`);
  };
  $$props = exclude_internal_props($$props);
  return [
    language,
    code,
    button,
    buttonLabel,
    buttonCopied,
    displayCode,
    formatted,
    copyState,
    classesBase,
    onCopyClick,
    lineNumbers,
    background,
    blur,
    text2,
    color,
    rounded,
    shadow,
    $storeHighlightJs
  ];
}
var CodeBlock = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, {
      language: 0,
      code: 1,
      lineNumbers: 10,
      background: 11,
      blur: 12,
      text: 13,
      color: 14,
      rounded: 15,
      shadow: 16,
      button: 2,
      buttonLabel: 3,
      buttonCopied: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeBlock",
      options,
      id: create_fragment34.name
    });
  }
  get language() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set language(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get code() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineNumbers() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineNumbers(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blur(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get button() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set button(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonLabel() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonLabel(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonCopied() {
    throw new Error("<CodeBlock>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonCopied(value) {
    throw new Error("<CodeBlock>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeBlock_default = CodeBlock;

// node_modules/@skeletonlabs/skeleton/dist/utilities/Modal/Modal.svelte
var file34 = "node_modules/@skeletonlabs/skeleton/dist/utilities/Modal/Modal.svelte";
function create_if_block27(ctx) {
  let previous_key = (
    /*$modalStore*/
    ctx[14]
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  const block = {
    c: function create() {
      key_block.c();
      key_block_anchor = empty();
    },
    l: function claim(nodes) {
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration_dev(target, key_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$modalStore*/
      16384 && safe_not_equal(previous_key, previous_key = /*$modalStore*/
      ctx2[14])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(key_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(key_block_anchor);
      }
      key_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block27.name,
    type: "if",
    source: "(158:0) {#if $modalStore.length > 0}",
    ctx
  });
  return block;
}
function create_else_block11(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let div_aria_label_value;
  let current;
  const if_block_creators = [create_if_block_8, create_else_block_16];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    var _a;
    if (
      /*currentComponent*/
      (_a = ctx2[16]) == null ? void 0 : _a.slot
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-modal": true,
        "aria-label": true
      });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(div, "class", div_class_value = "modal contents " + /*$modalStore*/
      (((_a = ctx[14][0]) == null ? void 0 : _a.modalClasses) ?? ""));
      attr_dev(div, "data-testid", "modal-component");
      attr_dev(div, "role", "dialog");
      attr_dev(div, "aria-modal", "true");
      attr_dev(div, "aria-label", div_aria_label_value = /*$modalStore*/
      ctx[14][0].title ?? "");
      add_location(div, file34, 226, 5, 8287);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[47](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty[0] & /*$modalStore*/
      16384 && div_class_value !== (div_class_value = "modal contents " + /*$modalStore*/
      (((_a = ctx2[14][0]) == null ? void 0 : _a.modalClasses) ?? ""))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*$modalStore*/
      16384 && div_aria_label_value !== (div_aria_label_value = /*$modalStore*/
      ctx2[14][0].title ?? "")) {
        attr_dev(div, "aria-label", div_aria_label_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
      ctx[47](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block11.name,
    type: "else",
    source: "(224:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_114(ctx) {
  var _a, _b, _c, _d;
  let div;
  let t0;
  let t1;
  let t2;
  let div_class_value;
  let div_aria_label_value;
  let if_block0 = (
    /*$modalStore*/
    ((_a = ctx[14][0]) == null ? void 0 : _a.title) && create_if_block_7(ctx)
  );
  let if_block1 = (
    /*$modalStore*/
    ((_b = ctx[14][0]) == null ? void 0 : _b.body) && create_if_block_6(ctx)
  );
  let if_block2 = (
    /*$modalStore*/
    ((_c = ctx[14][0]) == null ? void 0 : _c.image) && typeof /*$modalStore*/
    ((_d = ctx[14][0]) == null ? void 0 : _d.image) === "string" && create_if_block_53(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$modalStore*/
      ctx2[14][0].type === "alert"
    )
      return create_if_block_212;
    if (
      /*$modalStore*/
      ctx2[14][0].type === "confirm"
    )
      return create_if_block_37;
    if (
      /*$modalStore*/
      ctx2[14][0].type === "prompt"
    )
      return create_if_block_45;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block3 = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-modal": true,
        "aria-label": true
      });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block3)
        if_block3.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "modal " + /*classesModal*/
      ctx[20]);
      attr_dev(div, "data-testid", "modal");
      attr_dev(div, "role", "dialog");
      attr_dev(div, "aria-modal", "true");
      attr_dev(div, "aria-label", div_aria_label_value = /*$modalStore*/
      ctx[14][0].title ?? "");
      add_location(div, file34, 180, 5, 6247);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_hydration_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append_hydration_dev(div, t2);
      if (if_block3)
        if_block3.m(div, null);
      ctx[46](div);
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2, _c2, _d2;
      if (
        /*$modalStore*/
        (_a2 = ctx2[14][0]) == null ? void 0 : _a2.title
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_7(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$modalStore*/
        (_b2 = ctx2[14][0]) == null ? void 0 : _b2.body
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_6(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*$modalStore*/
        ((_c2 = ctx2[14][0]) == null ? void 0 : _c2.image) && typeof /*$modalStore*/
        ((_d2 = ctx2[14][0]) == null ? void 0 : _d2.image) === "string"
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_53(ctx2);
          if_block2.c();
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block3) {
        if_block3.p(ctx2, dirty);
      } else {
        if (if_block3)
          if_block3.d(1);
        if_block3 = current_block_type && current_block_type(ctx2);
        if (if_block3) {
          if_block3.c();
          if_block3.m(div, null);
        }
      }
      if (dirty[0] & /*classesModal*/
      1048576 && div_class_value !== (div_class_value = "modal " + /*classesModal*/
      ctx2[20])) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty[0] & /*$modalStore*/
      16384 && div_aria_label_value !== (div_aria_label_value = /*$modalStore*/
      ctx2[14][0].title ?? "")) {
        attr_dev(div, "aria-label", div_aria_label_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3) {
        if_block3.d();
      }
      ctx[46](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_114.name,
    type: "if",
    source: "(179:4) {#if $modalStore[0].type !== 'component'}",
    ctx
  });
  return block;
}
function create_else_block_16(ctx) {
  var _a, _b;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*currentComponent*/
    (_a = ctx[16]) == null ? void 0 : _a.props,
    { parent: (
      /*parent*/
      ctx[19]
    ) }
  ];
  var switch_value = (
    /*currentComponent*/
    (_b = ctx[16]) == null ? void 0 : _b.ref
  );
  function switch_props(ctx2, dirty) {
    var _a2;
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty[0] & /*currentComponent, parent*/
    589824) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*currentComponent*/
        65536 && get_spread_object(
          /*currentComponent*/
          (_a2 = ctx2[16]) == null ? void 0 : _a2.props
        ),
        dirty[0] & /*parent*/
        524288 && { parent: (
          /*parent*/
          ctx2[19]
        ) }
      ]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty[0] & /*currentComponent*/
      65536 && switch_value !== (switch_value = /*currentComponent*/
      (_a2 = ctx2[16]) == null ? void 0 : _a2.ref)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*currentComponent, parent*/
        589824 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*currentComponent*/
          65536 && get_spread_object(
            /*currentComponent*/
            (_b2 = ctx2[16]) == null ? void 0 : _b2.props
          ),
          dirty[0] & /*parent*/
          524288 && { parent: (
            /*parent*/
            ctx2[19]
          ) }
        ]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_16.name,
    type: "else",
    source: "(239:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  var _a, _b;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*currentComponent*/
    (_a = ctx[16]) == null ? void 0 : _a.props,
    { parent: (
      /*parent*/
      ctx[19]
    ) }
  ];
  var switch_value = (
    /*currentComponent*/
    (_b = ctx[16]) == null ? void 0 : _b.ref
  );
  function switch_props(ctx2, dirty) {
    var _a2;
    let switch_instance_props = {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty[0] & /*currentComponent, parent*/
    589824) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*currentComponent*/
        65536 && get_spread_object(
          /*currentComponent*/
          (_a2 = ctx2[16]) == null ? void 0 : _a2.props
        ),
        dirty[0] & /*parent*/
        524288 && { parent: (
          /*parent*/
          ctx2[19]
        ) }
      ]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2, _b2;
      if (dirty[0] & /*currentComponent*/
      65536 && switch_value !== (switch_value = /*currentComponent*/
      (_a2 = ctx2[16]) == null ? void 0 : _a2.ref)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*currentComponent, parent*/
        589824 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*currentComponent*/
          65536 && get_spread_object(
            /*currentComponent*/
            (_b2 = ctx2[16]) == null ? void 0 : _b2.props
          ),
          dirty[0] & /*parent*/
          524288 && { parent: (
            /*parent*/
            ctx2[19]
          ) }
        ]) : {};
        if (dirty[0] & /*currentComponent*/
        65536 | dirty[1] & /*$$scope*/
        16777216) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(235:6) {#if currentComponent?.slot}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  var _a;
  let html_tag;
  let raw_value = (
    /*currentComponent*/
    ((_a = ctx[16]) == null ? void 0 : _a.slot) + ""
  );
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (dirty[0] & /*currentComponent*/
      65536 && raw_value !== (raw_value = /*currentComponent*/
      ((_a2 = ctx2[16]) == null ? void 0 : _a2.slot) + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(236:7) <svelte:component this={currentComponent?.ref} {...currentComponent?.props} {parent}>",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let header;
  let html_tag;
  let raw_value = (
    /*$modalStore*/
    ctx[14][0].title + ""
  );
  let header_class_value;
  const block = {
    c: function create() {
      header = element("header");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      html_tag = claim_html_tag(header_nodes, false);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(header, "class", header_class_value = "modal-header " + /*regionHeader*/
      ctx[5]);
      add_location(header, file34, 190, 7, 6504);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      html_tag.m(raw_value, header);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$modalStore*/
      16384 && raw_value !== (raw_value = /*$modalStore*/
      ctx2[14][0].title + ""))
        html_tag.p(raw_value);
      if (dirty[0] & /*regionHeader*/
      32 && header_class_value !== (header_class_value = "modal-header " + /*regionHeader*/
      ctx2[5])) {
        attr_dev(header, "class", header_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(header);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(190:6) {#if $modalStore[0]?.title}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let article;
  let html_tag;
  let raw_value = (
    /*$modalStore*/
    ctx[14][0].body + ""
  );
  let article_class_value;
  const block = {
    c: function create() {
      article = element("article");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      article = claim_element(nodes, "ARTICLE", { class: true });
      var article_nodes = children(article);
      html_tag = claim_html_tag(article_nodes, false);
      article_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(article, "class", article_class_value = "modal-body " + /*regionBody*/
      ctx[6]);
      add_location(article, file34, 194, 7, 6658);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, article, anchor);
      html_tag.m(raw_value, article);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$modalStore*/
      16384 && raw_value !== (raw_value = /*$modalStore*/
      ctx2[14][0].body + ""))
        html_tag.p(raw_value);
      if (dirty[0] & /*regionBody*/
      64 && article_class_value !== (article_class_value = "modal-body " + /*regionBody*/
      ctx2[6])) {
        attr_dev(article, "class", article_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(article);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(194:6) {#if $modalStore[0]?.body}",
    ctx
  });
  return block;
}
function create_if_block_53(ctx) {
  let img;
  let img_class_value;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
      this.h();
    },
    h: function hydrate() {
      var _a;
      attr_dev(img, "class", img_class_value = "modal-image " + cModalImage);
      if (!src_url_equal(img.src, img_src_value = /*$modalStore*/
      (_a = ctx[14][0]) == null ? void 0 : _a.image))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Modal");
      add_location(img, file34, 198, 7, 6856);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      var _a;
      if (dirty[0] & /*$modalStore*/
      16384 && !src_url_equal(img.src, img_src_value = /*$modalStore*/
      (_a = ctx2[14][0]) == null ? void 0 : _a.image)) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(img);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_53.name,
    type: "if",
    source: "(198:6) {#if $modalStore[0]?.image && typeof $modalStore[0]?.image === 'string'}",
    ctx
  });
  return block;
}
function create_if_block_45(ctx) {
  let form;
  let input;
  let t0;
  let footer;
  let button0;
  let t1;
  let button0_class_value;
  let t2;
  let button1;
  let t3;
  let button1_class_value;
  let footer_class_value;
  let mounted;
  let dispose;
  let input_levels = [
    { class: "modal-prompt-input input" },
    { name: "prompt" },
    { type: "text" },
    /*$modalStore*/
    ctx[14][0].valueAttr
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      form = element("form");
      input = element("input");
      t0 = space();
      footer = element("footer");
      button0 = element("button");
      t1 = text(
        /*buttonTextCancel*/
        ctx[0]
      );
      t2 = space();
      button1 = element("button");
      t3 = text(
        /*buttonTextSubmit*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      form = claim_element(nodes, "FORM", { class: true });
      var form_nodes = children(form);
      input = claim_element(form_nodes, "INPUT", { class: true, name: true, type: true });
      t0 = claim_space(form_nodes);
      footer = claim_element(form_nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button0 = claim_element(footer_nodes, "BUTTON", { type: true, class: true });
      var button0_nodes = children(button0);
      t1 = claim_text(
        button0_nodes,
        /*buttonTextCancel*/
        ctx[0]
      );
      button0_nodes.forEach(detach_dev);
      t2 = claim_space(footer_nodes);
      button1 = claim_element(footer_nodes, "BUTTON", { type: true, class: true });
      var button1_nodes = children(button1);
      t3 = claim_text(
        button1_nodes,
        /*buttonTextSubmit*/
        ctx[2]
      );
      button1_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      form_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file34, 215, 8, 7738);
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", button0_class_value = "btn " + /*buttonNeutral*/
      ctx[3]);
      add_location(button0, file34, 217, 9, 7924);
      attr_dev(button1, "type", "submit");
      attr_dev(button1, "class", button1_class_value = "btn " + /*buttonPositive*/
      ctx[4]);
      add_location(button1, file34, 218, 9, 8030);
      attr_dev(footer, "class", footer_class_value = "modal-footer " + /*regionFooter*/
      ctx[7]);
      add_location(footer, file34, 216, 8, 7870);
      attr_dev(form, "class", "space-y-4");
      add_location(form, file34, 214, 7, 7678);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, form, anchor);
      append_hydration_dev(form, input);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*promptValue*/
        ctx[15]
      );
      append_hydration_dev(form, t0);
      append_hydration_dev(form, footer);
      append_hydration_dev(footer, button0);
      append_hydration_dev(button0, t1);
      append_hydration_dev(footer, t2);
      append_hydration_dev(footer, button1);
      append_hydration_dev(button1, t3);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[45]
          ),
          listen_dev(
            button0,
            "click",
            /*onClose*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            form,
            "submit",
            /*onPromptSubmit*/
            ctx[28],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { class: "modal-prompt-input input" },
        { name: "prompt" },
        { type: "text" },
        dirty[0] & /*$modalStore*/
        16384 && /*$modalStore*/
        ctx2[14][0].valueAttr
      ]));
      if (dirty[0] & /*promptValue*/
      32768 && input.value !== /*promptValue*/
      ctx2[15]) {
        set_input_value(
          input,
          /*promptValue*/
          ctx2[15]
        );
      }
      if (dirty[0] & /*buttonTextCancel*/
      1)
        set_data_dev(
          t1,
          /*buttonTextCancel*/
          ctx2[0]
        );
      if (dirty[0] & /*buttonNeutral*/
      8 && button0_class_value !== (button0_class_value = "btn " + /*buttonNeutral*/
      ctx2[3])) {
        attr_dev(button0, "class", button0_class_value);
      }
      if (dirty[0] & /*buttonTextSubmit*/
      4)
        set_data_dev(
          t3,
          /*buttonTextSubmit*/
          ctx2[2]
        );
      if (dirty[0] & /*buttonPositive*/
      16 && button1_class_value !== (button1_class_value = "btn " + /*buttonPositive*/
      ctx2[4])) {
        attr_dev(button1, "class", button1_class_value);
      }
      if (dirty[0] & /*regionFooter*/
      128 && footer_class_value !== (footer_class_value = "modal-footer " + /*regionFooter*/
      ctx2[7])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(form);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_45.name,
    type: "if",
    source: "(213:49) ",
    ctx
  });
  return block;
}
function create_if_block_37(ctx) {
  let footer;
  let button0;
  let t0;
  let button0_class_value;
  let t1;
  let button1;
  let t2;
  let button1_class_value;
  let footer_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      footer = element("footer");
      button0 = element("button");
      t0 = text(
        /*buttonTextCancel*/
        ctx[0]
      );
      t1 = space();
      button1 = element("button");
      t2 = text(
        /*buttonTextConfirm*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button0 = claim_element(footer_nodes, "BUTTON", { type: true, class: true });
      var button0_nodes = children(button0);
      t0 = claim_text(
        button0_nodes,
        /*buttonTextCancel*/
        ctx[0]
      );
      button0_nodes.forEach(detach_dev);
      t1 = claim_space(footer_nodes);
      button1 = claim_element(footer_nodes, "BUTTON", { type: true, class: true });
      var button1_nodes = children(button1);
      t2 = claim_text(
        button1_nodes,
        /*buttonTextConfirm*/
        ctx[1]
      );
      button1_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", button0_class_value = "btn " + /*buttonNeutral*/
      ctx[3]);
      add_location(button0, file34, 209, 8, 7365);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "class", button1_class_value = "btn " + /*buttonPositive*/
      ctx[4]);
      add_location(button1, file34, 210, 8, 7470);
      attr_dev(footer, "class", footer_class_value = "modal-footer " + /*regionFooter*/
      ctx[7]);
      add_location(footer, file34, 208, 7, 7312);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      append_hydration_dev(footer, button0);
      append_hydration_dev(button0, t0);
      append_hydration_dev(footer, t1);
      append_hydration_dev(footer, button1);
      append_hydration_dev(button1, t2);
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*onClose*/
            ctx[26],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*onConfirm*/
            ctx[27],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextCancel*/
      1)
        set_data_dev(
          t0,
          /*buttonTextCancel*/
          ctx2[0]
        );
      if (dirty[0] & /*buttonNeutral*/
      8 && button0_class_value !== (button0_class_value = "btn " + /*buttonNeutral*/
      ctx2[3])) {
        attr_dev(button0, "class", button0_class_value);
      }
      if (dirty[0] & /*buttonTextConfirm*/
      2)
        set_data_dev(
          t2,
          /*buttonTextConfirm*/
          ctx2[1]
        );
      if (dirty[0] & /*buttonPositive*/
      16 && button1_class_value !== (button1_class_value = "btn " + /*buttonPositive*/
      ctx2[4])) {
        attr_dev(button1, "class", button1_class_value);
      }
      if (dirty[0] & /*regionFooter*/
      128 && footer_class_value !== (footer_class_value = "modal-footer " + /*regionFooter*/
      ctx2[7])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(footer);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_37.name,
    type: "if",
    source: "(207:50) ",
    ctx
  });
  return block;
}
function create_if_block_212(ctx) {
  let footer;
  let button;
  let t;
  let button_class_value;
  let footer_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      footer = element("footer");
      button = element("button");
      t = text(
        /*buttonTextCancel*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      button = claim_element(footer_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      t = claim_text(
        button_nodes,
        /*buttonTextCancel*/
        ctx[0]
      );
      button_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", button_class_value = "btn " + /*buttonNeutral*/
      ctx[3]);
      add_location(button, file34, 204, 8, 7106);
      attr_dev(footer, "class", footer_class_value = "modal-footer " + /*regionFooter*/
      ctx[7]);
      add_location(footer, file34, 203, 7, 7053);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, footer, anchor);
      append_hydration_dev(footer, button);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*onClose*/
          ctx[26],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*buttonTextCancel*/
      1)
        set_data_dev(
          t,
          /*buttonTextCancel*/
          ctx2[0]
        );
      if (dirty[0] & /*buttonNeutral*/
      8 && button_class_value !== (button_class_value = "btn " + /*buttonNeutral*/
      ctx2[3])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty[0] & /*regionFooter*/
      128 && footer_class_value !== (footer_class_value = "modal-footer " + /*regionFooter*/
      ctx2[7])) {
        attr_dev(footer, "class", footer_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(footer);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_212.name,
    type: "if",
    source: "(202:6) {#if $modalStore[0].type === 'alert'}",
    ctx
  });
  return block;
}
function create_key_block(ctx) {
  let div1;
  let div0;
  let current_block_type_index;
  let if_block;
  let div0_class_value;
  let div0_intro;
  let div0_outro;
  let div1_class_value;
  let focusTrap_action;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_114, create_else_block11];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$modalStore*/
      ctx2[14][0].type !== "component"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "modal-transition " + /*classesTransitionLayer*/
      ctx[21]);
      add_location(div0, file34, 173, 3, 5874);
      attr_dev(div1, "class", div1_class_value = "modal-backdrop " + /*classesBackdrop*/
      ctx[22] + " " + /*backdropOverflow*/
      ctx[18]);
      attr_dev(div1, "data-testid", "modal-backdrop");
      add_location(div1, file34, 162, 2, 5469);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "mousedown",
            /*onBackdropInteractionBegin*/
            ctx[24],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseup",
            /*onBackdropInteractionEnd*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchstart",
            /*touchstart_handler*/
            ctx[42],
            { passive: true },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchend",
            /*touchend_handler*/
            ctx[43],
            { passive: true },
            false,
            false,
            false
          ),
          action_destroyer(focusTrap_action = focusTrap.call(null, div1, true))
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
      if (!current || dirty[0] & /*classesTransitionLayer*/
      2097152 && div0_class_value !== (div0_class_value = "modal-transition " + /*classesTransitionLayer*/
      ctx[21])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*classesBackdrop, backdropOverflow*/
      4456448 && div1_class_value !== (div1_class_value = "modal-backdrop " + /*classesBackdrop*/
      ctx[22] + " " + /*backdropOverflow*/
      ctx[18])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      add_render_callback(() => {
        if (!current)
          return;
        if (div0_outro)
          div0_outro.end(1);
        div0_intro = create_in_transition(div0, dynamicTransition, {
          transition: (
            /*transitionIn*/
            ctx[9]
          ),
          params: (
            /*transitionInParams*/
            ctx[10]
          ),
          enabled: (
            /*transitions*/
            ctx[8]
          )
        });
        div0_intro.start();
      });
      add_render_callback(() => {
        if (!current)
          return;
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(
            div1,
            dynamicTransition,
            {
              transition: fade,
              params: { duration: 150 },
              enabled: (
                /*transitions*/
                ctx[8]
              )
            },
            true
          );
        div1_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      if (div0_intro)
        div0_intro.invalidate();
      div0_outro = create_out_transition(div0, dynamicTransition, {
        transition: (
          /*transitionOut*/
          ctx[11]
        ),
        params: (
          /*transitionOutParams*/
          ctx[12]
        ),
        enabled: (
          /*transitions*/
          ctx[8]
        )
      });
      if (!div1_transition)
        div1_transition = create_bidirectional_transition(
          div1,
          dynamicTransition,
          {
            transition: fade,
            params: { duration: 150 },
            enabled: (
              /*transitions*/
              ctx[8]
            )
          },
          false
        );
      div1_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if_blocks[current_block_type_index].d();
      if (detaching && div0_outro)
        div0_outro.end();
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_key_block.name,
    type: "key",
    source: "(159:1) {#key $modalStore}",
    ctx
  });
  return block;
}
function create_fragment35(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  add_render_callback(
    /*onwindowresize*/
    ctx[44]
  );
  let if_block = (
    /*$modalStore*/
    ctx[14].length > 0 && create_if_block27(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "keydown",
            /*onKeyDown*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "resize",
            /*onwindowresize*/
            ctx[44]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$modalStore*/
        ctx2[14].length > 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$modalStore*/
          16384) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block27(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBackdrop = "fixed top-0 left-0 right-0 bottom-0 bg-surface-backdrop-token p-4";
var cTransitionLayer = "w-full h-fit min-h-full overflow-y-auto flex justify-center";
var cModal = "block overflow-y-auto";
var cModalImage = "w-full h-auto";
function instance35($$self, $$props, $$invalidate) {
  let cPosition;
  let classesBackdrop;
  let classesTransitionLayer;
  let classesModal;
  let parent;
  let $modalStore;
  let $prefersReducedMotionStore;
  validate_store(prefersReducedMotionStore, "prefersReducedMotionStore");
  component_subscribe($$self, prefersReducedMotionStore, ($$value) => $$invalidate(49, $prefersReducedMotionStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, []);
  const dispatch = createEventDispatcher();
  let { components = {} } = $$props;
  let { position = "items-center" } = $$props;
  let { background = "bg-surface-100-800-token" } = $$props;
  let { width = "w-modal" } = $$props;
  let { height = "h-auto" } = $$props;
  let { padding = "p-4" } = $$props;
  let { spacing = "space-y-4" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { shadow = "shadow-xl" } = $$props;
  let { zIndex = "z-[999]" } = $$props;
  let { buttonNeutral = "variant-ghost-surface" } = $$props;
  let { buttonPositive = "variant-filled" } = $$props;
  let { buttonTextCancel = "Cancel" } = $$props;
  let { buttonTextConfirm = "Confirm" } = $$props;
  let { buttonTextSubmit = "Submit" } = $$props;
  let { regionBackdrop = "" } = $$props;
  let { regionHeader = "text-2xl font-bold" } = $$props;
  let { regionBody = "max-h-[200px] overflow-hidden" } = $$props;
  let { regionFooter = "flex justify-end space-x-2" } = $$props;
  let { transitions = !$prefersReducedMotionStore } = $$props;
  let { transitionIn = fly } = $$props;
  let { transitionInParams = { duration: 150, opacity: 0, x: 0, y: 100 } } = $$props;
  let { transitionOut = fly } = $$props;
  let { transitionOutParams = { duration: 150, opacity: 0, x: 0, y: 100 } } = $$props;
  let promptValue;
  const buttonTextDefaults = {
    buttonTextCancel,
    buttonTextConfirm,
    buttonTextSubmit
  };
  let currentComponent;
  let registeredInteractionWithBackdrop = false;
  let modalElement;
  let windowHeight;
  let backdropOverflow = "overflow-y-hidden";
  const modalStore = getModalStore();
  validate_store(modalStore, "modalStore");
  component_subscribe($$self, modalStore, (value) => $$invalidate(14, $modalStore = value));
  function handleModals(modals) {
    if (modals[0].type === "prompt")
      $$invalidate(15, promptValue = modals[0].value);
    $$invalidate(0, buttonTextCancel = modals[0].buttonTextCancel || buttonTextDefaults.buttonTextCancel);
    $$invalidate(1, buttonTextConfirm = modals[0].buttonTextConfirm || buttonTextDefaults.buttonTextConfirm);
    $$invalidate(2, buttonTextSubmit = modals[0].buttonTextSubmit || buttonTextDefaults.buttonTextSubmit);
    $$invalidate(16, currentComponent = typeof modals[0].component === "string" ? components[modals[0].component] : modals[0].component);
  }
  function onModalHeightChange(modal) {
    var _a;
    let modalHeight = modal == null ? void 0 : modal.clientHeight;
    if (!modalHeight)
      modalHeight = (_a = modal == null ? void 0 : modal.firstChild) == null ? void 0 : _a.clientHeight;
    if (!modalHeight)
      return;
    if (modalHeight > windowHeight) {
      $$invalidate(18, backdropOverflow = "overflow-y-auto");
    } else {
      $$invalidate(18, backdropOverflow = "overflow-y-hidden");
    }
  }
  function onBackdropInteractionBegin(event) {
    if (!(event.target instanceof Element))
      return;
    const classList = event.target.classList;
    if (classList.contains("modal-backdrop") || classList.contains("modal-transition")) {
      registeredInteractionWithBackdrop = true;
    }
  }
  function onBackdropInteractionEnd(event) {
    if (!(event.target instanceof Element))
      return;
    const classList = event.target.classList;
    if ((classList.contains("modal-backdrop") || classList.contains("modal-transition")) && registeredInteractionWithBackdrop) {
      if ($modalStore[0].response)
        $modalStore[0].response(void 0);
      modalStore.close();
      dispatch("backdrop", event);
    }
    registeredInteractionWithBackdrop = false;
  }
  function onClose() {
    if ($modalStore[0].response)
      $modalStore[0].response(false);
    modalStore.close();
  }
  function onConfirm() {
    if ($modalStore[0].response)
      $modalStore[0].response(true);
    modalStore.close();
  }
  function onPromptSubmit(event) {
    event.preventDefault();
    if ($modalStore[0].response) {
      if ($modalStore[0].valueAttr !== void 0 && "type" in $modalStore[0].valueAttr && $modalStore[0].valueAttr.type === "number")
        $modalStore[0].response(parseInt(promptValue));
      else
        $modalStore[0].response(promptValue);
    }
    modalStore.close();
  }
  function onKeyDown2(event) {
    if (!$modalStore.length)
      return;
    if (event.code === "Escape")
      onClose();
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function onwindowresize() {
    $$invalidate(17, windowHeight = window.innerHeight);
  }
  function input_input_handler() {
    promptValue = this.value;
    $$invalidate(15, promptValue);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modalElement = $$value;
      $$invalidate(13, modalElement);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modalElement = $$value;
      $$invalidate(13, modalElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(54, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("components" in $$new_props)
      $$invalidate(30, components = $$new_props.components);
    if ("position" in $$new_props)
      $$invalidate(31, position = $$new_props.position);
    if ("background" in $$new_props)
      $$invalidate(32, background = $$new_props.background);
    if ("width" in $$new_props)
      $$invalidate(33, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(34, height = $$new_props.height);
    if ("padding" in $$new_props)
      $$invalidate(35, padding = $$new_props.padding);
    if ("spacing" in $$new_props)
      $$invalidate(36, spacing = $$new_props.spacing);
    if ("rounded" in $$new_props)
      $$invalidate(37, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(38, shadow = $$new_props.shadow);
    if ("zIndex" in $$new_props)
      $$invalidate(39, zIndex = $$new_props.zIndex);
    if ("buttonNeutral" in $$new_props)
      $$invalidate(3, buttonNeutral = $$new_props.buttonNeutral);
    if ("buttonPositive" in $$new_props)
      $$invalidate(4, buttonPositive = $$new_props.buttonPositive);
    if ("buttonTextCancel" in $$new_props)
      $$invalidate(0, buttonTextCancel = $$new_props.buttonTextCancel);
    if ("buttonTextConfirm" in $$new_props)
      $$invalidate(1, buttonTextConfirm = $$new_props.buttonTextConfirm);
    if ("buttonTextSubmit" in $$new_props)
      $$invalidate(2, buttonTextSubmit = $$new_props.buttonTextSubmit);
    if ("regionBackdrop" in $$new_props)
      $$invalidate(40, regionBackdrop = $$new_props.regionBackdrop);
    if ("regionHeader" in $$new_props)
      $$invalidate(5, regionHeader = $$new_props.regionHeader);
    if ("regionBody" in $$new_props)
      $$invalidate(6, regionBody = $$new_props.regionBody);
    if ("regionFooter" in $$new_props)
      $$invalidate(7, regionFooter = $$new_props.regionFooter);
    if ("transitions" in $$new_props)
      $$invalidate(8, transitions = $$new_props.transitions);
    if ("transitionIn" in $$new_props)
      $$invalidate(9, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$new_props)
      $$invalidate(10, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$new_props)
      $$invalidate(11, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$new_props)
      $$invalidate(12, transitionOutParams = $$new_props.transitionOutParams);
  };
  $$self.$capture_state = () => ({
    fly,
    fade,
    prefersReducedMotionStore,
    dynamicTransition,
    createEventDispatcher,
    dispatch,
    focusTrap,
    getModalStore,
    components,
    position,
    background,
    width,
    height,
    padding,
    spacing,
    rounded,
    shadow,
    zIndex,
    buttonNeutral,
    buttonPositive,
    buttonTextCancel,
    buttonTextConfirm,
    buttonTextSubmit,
    regionBackdrop,
    regionHeader,
    regionBody,
    regionFooter,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    cBackdrop,
    cTransitionLayer,
    cModal,
    cModalImage,
    promptValue,
    buttonTextDefaults,
    currentComponent,
    registeredInteractionWithBackdrop,
    modalElement,
    windowHeight,
    backdropOverflow,
    modalStore,
    handleModals,
    onModalHeightChange,
    onBackdropInteractionBegin,
    onBackdropInteractionEnd,
    onClose,
    onConfirm,
    onPromptSubmit,
    onKeyDown: onKeyDown2,
    parent,
    classesModal,
    cPosition,
    classesTransitionLayer,
    classesBackdrop,
    $modalStore,
    $prefersReducedMotionStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(54, $$props = assign(assign({}, $$props), $$new_props));
    if ("components" in $$props)
      $$invalidate(30, components = $$new_props.components);
    if ("position" in $$props)
      $$invalidate(31, position = $$new_props.position);
    if ("background" in $$props)
      $$invalidate(32, background = $$new_props.background);
    if ("width" in $$props)
      $$invalidate(33, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(34, height = $$new_props.height);
    if ("padding" in $$props)
      $$invalidate(35, padding = $$new_props.padding);
    if ("spacing" in $$props)
      $$invalidate(36, spacing = $$new_props.spacing);
    if ("rounded" in $$props)
      $$invalidate(37, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(38, shadow = $$new_props.shadow);
    if ("zIndex" in $$props)
      $$invalidate(39, zIndex = $$new_props.zIndex);
    if ("buttonNeutral" in $$props)
      $$invalidate(3, buttonNeutral = $$new_props.buttonNeutral);
    if ("buttonPositive" in $$props)
      $$invalidate(4, buttonPositive = $$new_props.buttonPositive);
    if ("buttonTextCancel" in $$props)
      $$invalidate(0, buttonTextCancel = $$new_props.buttonTextCancel);
    if ("buttonTextConfirm" in $$props)
      $$invalidate(1, buttonTextConfirm = $$new_props.buttonTextConfirm);
    if ("buttonTextSubmit" in $$props)
      $$invalidate(2, buttonTextSubmit = $$new_props.buttonTextSubmit);
    if ("regionBackdrop" in $$props)
      $$invalidate(40, regionBackdrop = $$new_props.regionBackdrop);
    if ("regionHeader" in $$props)
      $$invalidate(5, regionHeader = $$new_props.regionHeader);
    if ("regionBody" in $$props)
      $$invalidate(6, regionBody = $$new_props.regionBody);
    if ("regionFooter" in $$props)
      $$invalidate(7, regionFooter = $$new_props.regionFooter);
    if ("transitions" in $$props)
      $$invalidate(8, transitions = $$new_props.transitions);
    if ("transitionIn" in $$props)
      $$invalidate(9, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$props)
      $$invalidate(10, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$props)
      $$invalidate(11, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$props)
      $$invalidate(12, transitionOutParams = $$new_props.transitionOutParams);
    if ("promptValue" in $$props)
      $$invalidate(15, promptValue = $$new_props.promptValue);
    if ("currentComponent" in $$props)
      $$invalidate(16, currentComponent = $$new_props.currentComponent);
    if ("registeredInteractionWithBackdrop" in $$props)
      registeredInteractionWithBackdrop = $$new_props.registeredInteractionWithBackdrop;
    if ("modalElement" in $$props)
      $$invalidate(13, modalElement = $$new_props.modalElement);
    if ("windowHeight" in $$props)
      $$invalidate(17, windowHeight = $$new_props.windowHeight);
    if ("backdropOverflow" in $$props)
      $$invalidate(18, backdropOverflow = $$new_props.backdropOverflow);
    if ("parent" in $$props)
      $$invalidate(19, parent = $$new_props.parent);
    if ("classesModal" in $$props)
      $$invalidate(20, classesModal = $$new_props.classesModal);
    if ("cPosition" in $$props)
      $$invalidate(41, cPosition = $$new_props.cPosition);
    if ("classesTransitionLayer" in $$props)
      $$invalidate(21, classesTransitionLayer = $$new_props.classesTransitionLayer);
    if ("classesBackdrop" in $$props)
      $$invalidate(22, classesBackdrop = $$new_props.classesBackdrop);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b, _c;
    if ($$self.$$.dirty[0] & /*$modalStore*/
    16384) {
      $:
        if ($modalStore.length)
          handleModals($modalStore);
    }
    if ($$self.$$.dirty[0] & /*modalElement*/
    8192) {
      $:
        onModalHeightChange(modalElement);
    }
    if ($$self.$$.dirty[0] & /*$modalStore*/
    16384 | $$self.$$.dirty[1] & /*position*/
    1) {
      $:
        $$invalidate(41, cPosition = ((_a = $modalStore[0]) == null ? void 0 : _a.position) ?? position);
    }
    $:
      $$invalidate(22, classesBackdrop = `${cBackdrop} ${regionBackdrop} ${zIndex} ${$$props.class ?? ""} ${((_b = $modalStore[0]) == null ? void 0 : _b.backdropClasses) ?? ""}`);
    if ($$self.$$.dirty[1] & /*cPosition*/
    1024) {
      $:
        $$invalidate(21, classesTransitionLayer = `${cTransitionLayer} ${cPosition ?? ""}`);
    }
    if ($$self.$$.dirty[0] & /*$modalStore*/
    16384 | $$self.$$.dirty[1] & /*background, width, height, padding, spacing, rounded, shadow*/
    254) {
      $:
        $$invalidate(20, classesModal = `${cModal} ${background} ${width} ${height} ${padding} ${spacing} ${rounded} ${shadow} ${((_c = $modalStore[0]) == null ? void 0 : _c.modalClasses) ?? ""}`);
    }
    if ($$self.$$.dirty[0] & /*buttonNeutral, buttonPositive, buttonTextCancel, buttonTextConfirm, buttonTextSubmit, regionHeader, regionBody, regionFooter*/
    255 | $$self.$$.dirty[1] & /*position, background, width, height, padding, spacing, rounded, shadow, regionBackdrop*/
    767) {
      $:
        $$invalidate(19, parent = {
          position,
          // ---
          background,
          width,
          height,
          padding,
          spacing,
          rounded,
          shadow,
          // ---
          buttonNeutral,
          buttonPositive,
          buttonTextCancel,
          buttonTextConfirm,
          buttonTextSubmit,
          // ---
          regionBackdrop,
          regionHeader,
          regionBody,
          regionFooter,
          // ---
          onClose
        });
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    buttonTextCancel,
    buttonTextConfirm,
    buttonTextSubmit,
    buttonNeutral,
    buttonPositive,
    regionHeader,
    regionBody,
    regionFooter,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    modalElement,
    $modalStore,
    promptValue,
    currentComponent,
    windowHeight,
    backdropOverflow,
    parent,
    classesModal,
    classesTransitionLayer,
    classesBackdrop,
    modalStore,
    onBackdropInteractionBegin,
    onBackdropInteractionEnd,
    onClose,
    onConfirm,
    onPromptSubmit,
    onKeyDown2,
    components,
    position,
    background,
    width,
    height,
    padding,
    spacing,
    rounded,
    shadow,
    zIndex,
    regionBackdrop,
    cPosition,
    touchstart_handler,
    touchend_handler,
    onwindowresize,
    input_input_handler,
    div_binding,
    div_binding_1
  ];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance35,
      create_fragment35,
      safe_not_equal,
      {
        components: 30,
        position: 31,
        background: 32,
        width: 33,
        height: 34,
        padding: 35,
        spacing: 36,
        rounded: 37,
        shadow: 38,
        zIndex: 39,
        buttonNeutral: 3,
        buttonPositive: 4,
        buttonTextCancel: 0,
        buttonTextConfirm: 1,
        buttonTextSubmit: 2,
        regionBackdrop: 40,
        regionHeader: 5,
        regionBody: 6,
        regionFooter: 7,
        transitions: 8,
        transitionIn: 9,
        transitionInParams: 10,
        transitionOut: 11,
        transitionOutParams: 12
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment35.name
    });
  }
  get components() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set components(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get position() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonNeutral() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonNeutral(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonPositive() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonPositive(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextCancel() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextCancel(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextConfirm() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextConfirm(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonTextSubmit() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonTextSubmit(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBackdrop() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBackdrop(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionHeader() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionHeader(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBody() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBody(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionFooter() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionFooter(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitions() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitions(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionIn() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionIn(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionInParams() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionInParams(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOut() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOut(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOutParams() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOutParams(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/@skeletonlabs/skeleton/dist/utilities/Drawer/Drawer.svelte
var { window: window_1 } = globals;
var file35 = "node_modules/@skeletonlabs/skeleton/dist/utilities/Drawer/Drawer.svelte";
function create_if_block28(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let div0_intro;
  let div0_outro;
  let div1_class_value;
  let focusTrap_action;
  let div1_intro;
  let div1_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[32].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[31],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        "data-testid": true,
        role: true,
        "aria-modal": true,
        "aria-labelledby": true,
        "aria-describedby": true
      });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "drawer " + /*classesDrawer*/
      ctx[8]);
      attr_dev(div0, "data-testid", "drawer");
      attr_dev(div0, "role", "dialog");
      attr_dev(div0, "aria-modal", "true");
      attr_dev(
        div0,
        "aria-labelledby",
        /*labelledby*/
        ctx[0]
      );
      attr_dev(
        div0,
        "aria-describedby",
        /*describedby*/
        ctx[1]
      );
      add_location(div0, file35, 158, 2, 5289);
      attr_dev(div1, "class", div1_class_value = "drawer-backdrop " + /*classesBackdrop*/
      ctx[9]);
      attr_dev(div1, "data-testid", "drawer-backdrop");
      add_location(div1, file35, 136, 1, 4732);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[36](div0);
      ctx[37](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "mousedown",
            /*onDrawerInteraction*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchstart",
            /*touchstart_handler*/
            ctx[33],
            { passive: true },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchend",
            /*touchend_handler*/
            ctx[34],
            { passive: true },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keypress",
            /*keypress_handler*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          action_destroyer(focusTrap_action = focusTrap.call(null, div1, true))
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[31],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[31]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[31],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*classesDrawer*/
      256 && div0_class_value !== (div0_class_value = "drawer " + /*classesDrawer*/
      ctx[8])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*labelledby*/
      1) {
        attr_dev(
          div0,
          "aria-labelledby",
          /*labelledby*/
          ctx[0]
        );
      }
      if (!current || dirty[0] & /*describedby*/
      2) {
        attr_dev(
          div0,
          "aria-describedby",
          /*describedby*/
          ctx[1]
        );
      }
      if (!current || dirty[0] & /*classesBackdrop*/
      512 && div1_class_value !== (div1_class_value = "drawer-backdrop " + /*classesBackdrop*/
      ctx[9])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div0_outro)
            div0_outro.end(1);
          div0_intro = create_in_transition(div0, dynamicTransition, {
            transition: fly,
            params: {
              x: (
                /*anim*/
                ctx[7].x
              ),
              y: (
                /*anim*/
                ctx[7].y
              ),
              duration: (
                /*duration*/
                ctx[2]
              ),
              opacity: (
                /*opacityTransition*/
                ctx[3] ? void 0 : 1
              )
            },
            enabled: (
              /*transitions*/
              ctx[4]
            )
          });
          div0_intro.start();
        });
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div1_outro)
            div1_outro.end(1);
          div1_intro = create_in_transition(div1, dynamicTransition, {
            transition: fade,
            params: { duration: (
              /*duration*/
              ctx[2]
            ) },
            enabled: (
              /*transitions*/
              ctx[4] && /*opacityTransition*/
              ctx[3]
            )
          });
          div1_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div0_intro)
        div0_intro.invalidate();
      if (local) {
        div0_outro = create_out_transition(div0, dynamicTransition, {
          transition: fly,
          params: {
            x: (
              /*anim*/
              ctx[7].x
            ),
            y: (
              /*anim*/
              ctx[7].y
            ),
            duration: (
              /*duration*/
              ctx[2]
            ),
            opacity: (
              /*opacityTransition*/
              ctx[3] ? void 0 : 1
            ),
            easing: cubicIn
          },
          enabled: (
            /*transitions*/
            ctx[4]
          )
        });
      }
      if (div1_intro)
        div1_intro.invalidate();
      if (local) {
        div1_outro = create_out_transition(div1, dynamicTransition, {
          transition: fade,
          params: { duration: (
            /*duration*/
            ctx[2]
          ) },
          enabled: (
            /*transitions*/
            ctx[4] && /*opacityTransition*/
            ctx[3]
          )
        });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[36](null);
      if (detaching && div0_outro)
        div0_outro.end();
      ctx[37](null);
      if (detaching && div1_outro)
        div1_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block28.name,
    type: "if",
    source: "(133:0) {#if $drawerStore.open === true}",
    ctx
  });
  return block;
}
function create_fragment36(ctx) {
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$drawerStore*/
    ctx[10].open === true && create_if_block28(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window_1,
          "keydown",
          /*onKeydownWindow*/
          ctx[13],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*$drawerStore*/
        ctx2[10].open === true
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$drawerStore*/
          1024) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block28(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBackdrop2 = "fixed top-0 left-0 right-0 bottom-0 flex";
var cDrawer = "overflow-y-auto transition-transform";
function instance36($$self, $$props, $$invalidate) {
  let classesPosition;
  let classesWidth;
  let classesHeight;
  let classesRounded;
  let classesBackdrop;
  let classesDrawer;
  let $drawerStore;
  let $prefersReducedMotionStore;
  validate_store(prefersReducedMotionStore, "prefersReducedMotionStore");
  component_subscribe($$self, prefersReducedMotionStore, ($$value) => $$invalidate(38, $prefersReducedMotionStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Drawer", slots, ["default"]);
  const dispatch = createEventDispatcher();
  let { position = "left" } = $$props;
  let { bgDrawer = "bg-surface-100-800-token" } = $$props;
  let { border = "" } = $$props;
  let { rounded = "" } = $$props;
  let { shadow = "shadow-xl" } = $$props;
  let { width = "" } = $$props;
  let { height = "" } = $$props;
  let { bgBackdrop = "bg-surface-backdrop-token" } = $$props;
  let { blur = "" } = $$props;
  let { padding = "" } = $$props;
  let { zIndex = "z-40" } = $$props;
  let { regionBackdrop = "" } = $$props;
  let { regionDrawer = "" } = $$props;
  let { labelledby = "" } = $$props;
  let { describedby = "" } = $$props;
  let { duration = 200 } = $$props;
  let { transitions = !$prefersReducedMotionStore } = $$props;
  let { opacityTransition = true } = $$props;
  const presets = {
    top: {
      alignment: "items-start",
      width: "w-full",
      height: "h-[50%]",
      rounded: "rounded-bl-container-token rounded-br-container-token"
    },
    bottom: {
      alignment: "items-end",
      width: "w-full",
      height: " h-[50%]",
      rounded: "rounded-tl-container-token rounded-tr-container-token"
    },
    left: {
      alignment: "justify-start",
      width: "w-[90%]",
      height: "h-full",
      rounded: "rounded-tr-container-token rounded-br-container-token"
    },
    right: {
      alignment: "justify-end",
      width: "w-[90%]",
      height: "h-full",
      rounded: "rounded-tl-container-token rounded-bl-container-token"
    }
  };
  let elemBackdrop;
  let elemDrawer;
  let anim = { x: 0, y: 0 };
  const drawerStore = getDrawerStore();
  validate_store(drawerStore, "drawerStore");
  component_subscribe($$self, drawerStore, (value) => $$invalidate(10, $drawerStore = value));
  const propDefaults = {
    position,
    bgBackdrop,
    blur,
    padding,
    bgDrawer,
    border,
    rounded,
    shadow,
    width,
    height,
    opacityTransition,
    regionBackdrop,
    regionDrawer,
    labelledby,
    describedby,
    duration
  };
  function applyPropSettings(settings) {
    $$invalidate(14, position = settings.position || propDefaults.position);
    $$invalidate(21, bgBackdrop = settings.bgBackdrop || propDefaults.bgBackdrop);
    $$invalidate(22, blur = settings.blur || propDefaults.blur);
    $$invalidate(23, padding = settings.padding || propDefaults.padding);
    $$invalidate(15, bgDrawer = settings.bgDrawer || propDefaults.bgDrawer);
    $$invalidate(16, border = settings.border || propDefaults.border);
    $$invalidate(17, rounded = settings.rounded || propDefaults.rounded);
    $$invalidate(18, shadow = settings.shadow || propDefaults.shadow);
    $$invalidate(19, width = settings.width || propDefaults.width);
    $$invalidate(20, height = settings.height || propDefaults.height);
    $$invalidate(24, regionBackdrop = settings.regionBackdrop || propDefaults.regionBackdrop);
    $$invalidate(25, regionDrawer = settings.regionDrawer || propDefaults.regionDrawer);
    $$invalidate(0, labelledby = settings.labelledby || propDefaults.labelledby);
    $$invalidate(1, describedby = settings.describedby || propDefaults.describedby);
    $$invalidate(3, opacityTransition = settings.opacityTransition || propDefaults.opacityTransition);
    $$invalidate(2, duration = settings.duration || propDefaults.duration);
  }
  function applyAnimationSettings() {
    if (!BROWSER)
      return;
    switch (position) {
      case "top":
        $$invalidate(7, anim = { x: 0, y: -window.innerWidth });
        break;
      case "bottom":
        $$invalidate(7, anim = { x: 0, y: window.innerWidth });
        break;
      case "left":
        $$invalidate(7, anim = { x: -window.innerHeight, y: 0 });
        break;
      case "right":
        $$invalidate(7, anim = { x: window.innerHeight, y: 0 });
        break;
      default:
        console.error("Error: unknown position property value.");
        break;
    }
  }
  function onDrawerInteraction(event) {
    if (event.target === elemBackdrop) {
      drawerStore.close();
      dispatch("backdrop", event);
    } else {
      dispatch("drawer", event);
    }
  }
  function onKeydownWindow(event) {
    if (!$drawerStore)
      return;
    if (event.code === "Escape")
      drawerStore.close();
  }
  drawerStore.subscribe((settings) => {
    if (settings.open !== true)
      return;
    applyPropSettings(settings);
    applyAnimationSettings();
  });
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemDrawer = $$value;
      $$invalidate(6, elemDrawer);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elemBackdrop = $$value;
      $$invalidate(5, elemBackdrop);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(44, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("position" in $$new_props)
      $$invalidate(14, position = $$new_props.position);
    if ("bgDrawer" in $$new_props)
      $$invalidate(15, bgDrawer = $$new_props.bgDrawer);
    if ("border" in $$new_props)
      $$invalidate(16, border = $$new_props.border);
    if ("rounded" in $$new_props)
      $$invalidate(17, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(18, shadow = $$new_props.shadow);
    if ("width" in $$new_props)
      $$invalidate(19, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(20, height = $$new_props.height);
    if ("bgBackdrop" in $$new_props)
      $$invalidate(21, bgBackdrop = $$new_props.bgBackdrop);
    if ("blur" in $$new_props)
      $$invalidate(22, blur = $$new_props.blur);
    if ("padding" in $$new_props)
      $$invalidate(23, padding = $$new_props.padding);
    if ("zIndex" in $$new_props)
      $$invalidate(26, zIndex = $$new_props.zIndex);
    if ("regionBackdrop" in $$new_props)
      $$invalidate(24, regionBackdrop = $$new_props.regionBackdrop);
    if ("regionDrawer" in $$new_props)
      $$invalidate(25, regionDrawer = $$new_props.regionDrawer);
    if ("labelledby" in $$new_props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("describedby" in $$new_props)
      $$invalidate(1, describedby = $$new_props.describedby);
    if ("duration" in $$new_props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("transitions" in $$new_props)
      $$invalidate(4, transitions = $$new_props.transitions);
    if ("opacityTransition" in $$new_props)
      $$invalidate(3, opacityTransition = $$new_props.opacityTransition);
    if ("$$scope" in $$new_props)
      $$invalidate(31, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    BROWSER,
    dispatch,
    prefersReducedMotionStore,
    focusTrap,
    getDrawerStore,
    fade,
    fly,
    dynamicTransition,
    cubicIn,
    position,
    bgDrawer,
    border,
    rounded,
    shadow,
    width,
    height,
    bgBackdrop,
    blur,
    padding,
    zIndex,
    regionBackdrop,
    regionDrawer,
    labelledby,
    describedby,
    duration,
    transitions,
    opacityTransition,
    presets,
    elemBackdrop,
    elemDrawer,
    anim,
    drawerStore,
    cBackdrop: cBackdrop2,
    cDrawer,
    propDefaults,
    applyPropSettings,
    applyAnimationSettings,
    onDrawerInteraction,
    onKeydownWindow,
    classesRounded,
    classesHeight,
    classesWidth,
    classesDrawer,
    classesPosition,
    classesBackdrop,
    $drawerStore,
    $prefersReducedMotionStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(44, $$props = assign(assign({}, $$props), $$new_props));
    if ("position" in $$props)
      $$invalidate(14, position = $$new_props.position);
    if ("bgDrawer" in $$props)
      $$invalidate(15, bgDrawer = $$new_props.bgDrawer);
    if ("border" in $$props)
      $$invalidate(16, border = $$new_props.border);
    if ("rounded" in $$props)
      $$invalidate(17, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(18, shadow = $$new_props.shadow);
    if ("width" in $$props)
      $$invalidate(19, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(20, height = $$new_props.height);
    if ("bgBackdrop" in $$props)
      $$invalidate(21, bgBackdrop = $$new_props.bgBackdrop);
    if ("blur" in $$props)
      $$invalidate(22, blur = $$new_props.blur);
    if ("padding" in $$props)
      $$invalidate(23, padding = $$new_props.padding);
    if ("zIndex" in $$props)
      $$invalidate(26, zIndex = $$new_props.zIndex);
    if ("regionBackdrop" in $$props)
      $$invalidate(24, regionBackdrop = $$new_props.regionBackdrop);
    if ("regionDrawer" in $$props)
      $$invalidate(25, regionDrawer = $$new_props.regionDrawer);
    if ("labelledby" in $$props)
      $$invalidate(0, labelledby = $$new_props.labelledby);
    if ("describedby" in $$props)
      $$invalidate(1, describedby = $$new_props.describedby);
    if ("duration" in $$props)
      $$invalidate(2, duration = $$new_props.duration);
    if ("transitions" in $$props)
      $$invalidate(4, transitions = $$new_props.transitions);
    if ("opacityTransition" in $$props)
      $$invalidate(3, opacityTransition = $$new_props.opacityTransition);
    if ("elemBackdrop" in $$props)
      $$invalidate(5, elemBackdrop = $$new_props.elemBackdrop);
    if ("elemDrawer" in $$props)
      $$invalidate(6, elemDrawer = $$new_props.elemDrawer);
    if ("anim" in $$props)
      $$invalidate(7, anim = $$new_props.anim);
    if ("classesRounded" in $$props)
      $$invalidate(27, classesRounded = $$new_props.classesRounded);
    if ("classesHeight" in $$props)
      $$invalidate(28, classesHeight = $$new_props.classesHeight);
    if ("classesWidth" in $$props)
      $$invalidate(29, classesWidth = $$new_props.classesWidth);
    if ("classesDrawer" in $$props)
      $$invalidate(8, classesDrawer = $$new_props.classesDrawer);
    if ("classesPosition" in $$props)
      $$invalidate(30, classesPosition = $$new_props.classesPosition);
    if ("classesBackdrop" in $$props)
      $$invalidate(9, classesBackdrop = $$new_props.classesBackdrop);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*position*/
    16384) {
      $:
        $$invalidate(30, classesPosition = presets[position].alignment);
    }
    if ($$self.$$.dirty[0] & /*width, position*/
    540672) {
      $:
        $$invalidate(29, classesWidth = width ? width : presets[position].width);
    }
    if ($$self.$$.dirty[0] & /*height, position*/
    1064960) {
      $:
        $$invalidate(28, classesHeight = height ? height : presets[position].height);
    }
    if ($$self.$$.dirty[0] & /*rounded, position*/
    147456) {
      $:
        $$invalidate(27, classesRounded = rounded ? rounded : presets[position].rounded);
    }
    $:
      $$invalidate(9, classesBackdrop = `${cBackdrop2} ${bgBackdrop} ${padding} ${blur} ${classesPosition} ${regionBackdrop} ${zIndex} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty[0] & /*bgDrawer, border, rounded, shadow, classesWidth, classesHeight, classesRounded, regionDrawer*/
    973570048) {
      $:
        $$invalidate(8, classesDrawer = `${cDrawer} ${bgDrawer} ${border} ${rounded} ${shadow} ${classesWidth} ${classesHeight} ${classesRounded} ${regionDrawer}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    labelledby,
    describedby,
    duration,
    opacityTransition,
    transitions,
    elemBackdrop,
    elemDrawer,
    anim,
    classesDrawer,
    classesBackdrop,
    $drawerStore,
    drawerStore,
    onDrawerInteraction,
    onKeydownWindow,
    position,
    bgDrawer,
    border,
    rounded,
    shadow,
    width,
    height,
    bgBackdrop,
    blur,
    padding,
    regionBackdrop,
    regionDrawer,
    zIndex,
    classesRounded,
    classesHeight,
    classesWidth,
    classesPosition,
    $$scope,
    slots,
    touchstart_handler,
    touchend_handler,
    keypress_handler,
    div0_binding,
    div1_binding
  ];
}
var Drawer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance36,
      create_fragment36,
      safe_not_equal,
      {
        position: 14,
        bgDrawer: 15,
        border: 16,
        rounded: 17,
        shadow: 18,
        width: 19,
        height: 20,
        bgBackdrop: 21,
        blur: 22,
        padding: 23,
        zIndex: 26,
        regionBackdrop: 24,
        regionDrawer: 25,
        labelledby: 0,
        describedby: 1,
        duration: 2,
        transitions: 4,
        opacityTransition: 3
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Drawer",
      options,
      id: create_fragment36.name
    });
  }
  get position() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgDrawer() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgDrawer(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get border() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set border(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgBackdrop() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgBackdrop(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set blur(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionBackdrop() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionBackdrop(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionDrawer() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionDrawer(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelledby() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelledby(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get describedby() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set describedby(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitions() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitions(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get opacityTransition() {
    throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set opacityTransition(value) {
    throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Drawer_default = Drawer;

// node_modules/@skeletonlabs/skeleton/dist/utilities/LightSwitch/LightSwitch.svelte
var file36 = "node_modules/@skeletonlabs/skeleton/dist/utilities/LightSwitch/LightSwitch.svelte";
function create_fragment37(ctx) {
  let html_tag;
  let raw_value = `<script nonce="%sveltekit.nonce%">(${setInitialClassState.toString()})();<\/script>`;
  let html_anchor;
  let t;
  let div1;
  let div0;
  let svg;
  let path;
  let path_d_value;
  let svg_class_value;
  let div0_class_value;
  let div1_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      t = space();
      div1 = element("div");
      div0 = element("div");
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector("svelte-gewkj4", document.head);
      html_tag = claim_html_tag(head_nodes, false);
      html_anchor = empty();
      head_nodes.forEach(detach_dev);
      t = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-label": true,
        "aria-checked": true,
        title: true,
        tabindex: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      svg = claim_svg_element(div0_nodes, "svg", { class: true, xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
      attr_dev(path, "d", path_d_value = /*$modeCurrent*/
      ctx[1] ? (
        /*svgPath*/
        ctx[5].sun
      ) : (
        /*svgPath*/
        ctx[5].moon
      ));
      add_location(path, file36, 74, 3, 3262);
      attr_dev(svg, "class", svg_class_value = "lightswitch-icon " + /*classesIcon*/
      ctx[2]);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 512 512");
      add_location(svg, file36, 73, 2, 3157);
      attr_dev(div0, "class", div0_class_value = "lightswitch-thumb " + /*classesThumb*/
      ctx[3]);
      add_location(div0, file36, 71, 1, 3093);
      attr_dev(div1, "class", div1_class_value = "lightswitch-track " + /*classesTrack*/
      ctx[4]);
      attr_dev(div1, "role", "switch");
      attr_dev(div1, "aria-label", "Light Switch");
      attr_dev(
        div1,
        "aria-checked",
        /*$modeCurrent*/
        ctx[1]
      );
      attr_dev(
        div1,
        "title",
        /*title*/
        ctx[0]
      );
      attr_dev(div1, "tabindex", "0");
      add_location(div1, file36, 56, 0, 2836);
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, document.head);
      append_hydration_dev(document.head, html_anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, svg);
      append_hydration_dev(svg, path);
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            /*onToggleHandler*/
            ctx[6],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "click",
            /*click_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(div1, "keydown", onKeyDown, false, false, false, false),
          listen_dev(
            div1,
            "keydown",
            /*keydown_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keyup",
            /*keyup_handler*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keypress",
            /*keypress_handler*/
            ctx[22],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$modeCurrent*/
      2 && path_d_value !== (path_d_value = /*$modeCurrent*/
      ctx2[1] ? (
        /*svgPath*/
        ctx2[5].sun
      ) : (
        /*svgPath*/
        ctx2[5].moon
      ))) {
        attr_dev(path, "d", path_d_value);
      }
      if (dirty & /*classesIcon*/
      4 && svg_class_value !== (svg_class_value = "lightswitch-icon " + /*classesIcon*/
      ctx2[2])) {
        attr_dev(svg, "class", svg_class_value);
      }
      if (dirty & /*classesThumb*/
      8 && div0_class_value !== (div0_class_value = "lightswitch-thumb " + /*classesThumb*/
      ctx2[3])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (dirty & /*classesTrack*/
      16 && div1_class_value !== (div1_class_value = "lightswitch-track " + /*classesTrack*/
      ctx2[4])) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (dirty & /*$modeCurrent*/
      2) {
        attr_dev(
          div1,
          "aria-checked",
          /*$modeCurrent*/
          ctx2[1]
        );
      }
      if (dirty & /*title*/
      1) {
        attr_dev(
          div1,
          "title",
          /*title*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        html_tag.d();
        detach_dev(t);
        detach_dev(div1);
      }
      detach_dev(html_anchor);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cTrack3 = "cursor-pointer";
var cThumb2 = "aspect-square scale-[0.8] flex justify-center items-center";
var cIcon = "w-[70%] aspect-square";
function onKeyDown(event) {
  if (["Enter", "Space"].includes(event.code)) {
    event.preventDefault();
    event.currentTarget.click();
  }
}
function instance37($$self, $$props, $$invalidate) {
  let trackBg;
  let thumbBg;
  let thumbPosition;
  let iconFill;
  let classesTrack;
  let classesThumb;
  let classesIcon;
  let $modeCurrent;
  validate_store(modeCurrent, "modeCurrent");
  component_subscribe($$self, modeCurrent, ($$value) => $$invalidate(1, $modeCurrent = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LightSwitch", slots, []);
  let { title = "Toggle light or dark mode." } = $$props;
  let { bgLight = "bg-surface-50" } = $$props;
  let { bgDark = "bg-surface-900" } = $$props;
  let { fillLight = "fill-surface-50" } = $$props;
  let { fillDark = "fill-surface-900" } = $$props;
  let { width = "w-12" } = $$props;
  let { height = "h-6" } = $$props;
  let { ring = "ring-[1px] ring-surface-500/30" } = $$props;
  let { rounded = "rounded-token" } = $$props;
  const cTransition = `transition-all duration-[200ms]`;
  const svgPath = {
    sun: "M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM352 256c0 53-43 96-96 96s-96-43-96-96s43-96 96-96s96 43 96 96zm32 0c0-70.7-57.3-128-128-128s-128 57.3-128 128s57.3 128 128 128s128-57.3 128-128z",
    moon: "M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"
  };
  function onToggleHandler() {
    set_store_value(modeCurrent, $modeCurrent = !$modeCurrent, $modeCurrent);
    setModeUserPrefers($modeCurrent);
    setModeCurrent($modeCurrent);
  }
  onMount(() => {
    if (!("modeCurrent" in localStorage)) {
      setModeCurrent(getModeOsPrefers());
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keyup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keypress_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("title" in $$new_props)
      $$invalidate(0, title = $$new_props.title);
    if ("bgLight" in $$new_props)
      $$invalidate(7, bgLight = $$new_props.bgLight);
    if ("bgDark" in $$new_props)
      $$invalidate(8, bgDark = $$new_props.bgDark);
    if ("fillLight" in $$new_props)
      $$invalidate(9, fillLight = $$new_props.fillLight);
    if ("fillDark" in $$new_props)
      $$invalidate(10, fillDark = $$new_props.fillDark);
    if ("width" in $$new_props)
      $$invalidate(11, width = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(12, height = $$new_props.height);
    if ("ring" in $$new_props)
      $$invalidate(13, ring = $$new_props.ring);
    if ("rounded" in $$new_props)
      $$invalidate(14, rounded = $$new_props.rounded);
  };
  $$self.$capture_state = () => ({
    onMount,
    modeCurrent,
    setModeUserPrefers,
    setModeCurrent,
    setInitialClassState,
    getModeOsPrefers,
    title,
    bgLight,
    bgDark,
    fillLight,
    fillDark,
    width,
    height,
    ring,
    rounded,
    cTransition,
    cTrack: cTrack3,
    cThumb: cThumb2,
    cIcon,
    svgPath,
    onToggleHandler,
    onKeyDown,
    iconFill,
    classesIcon,
    thumbPosition,
    thumbBg,
    classesThumb,
    trackBg,
    classesTrack,
    $modeCurrent
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
    if ("title" in $$props)
      $$invalidate(0, title = $$new_props.title);
    if ("bgLight" in $$props)
      $$invalidate(7, bgLight = $$new_props.bgLight);
    if ("bgDark" in $$props)
      $$invalidate(8, bgDark = $$new_props.bgDark);
    if ("fillLight" in $$props)
      $$invalidate(9, fillLight = $$new_props.fillLight);
    if ("fillDark" in $$props)
      $$invalidate(10, fillDark = $$new_props.fillDark);
    if ("width" in $$props)
      $$invalidate(11, width = $$new_props.width);
    if ("height" in $$props)
      $$invalidate(12, height = $$new_props.height);
    if ("ring" in $$props)
      $$invalidate(13, ring = $$new_props.ring);
    if ("rounded" in $$props)
      $$invalidate(14, rounded = $$new_props.rounded);
    if ("iconFill" in $$props)
      $$invalidate(15, iconFill = $$new_props.iconFill);
    if ("classesIcon" in $$props)
      $$invalidate(2, classesIcon = $$new_props.classesIcon);
    if ("thumbPosition" in $$props)
      $$invalidate(16, thumbPosition = $$new_props.thumbPosition);
    if ("thumbBg" in $$props)
      $$invalidate(17, thumbBg = $$new_props.thumbBg);
    if ("classesThumb" in $$props)
      $$invalidate(3, classesThumb = $$new_props.classesThumb);
    if ("trackBg" in $$props)
      $$invalidate(18, trackBg = $$new_props.trackBg);
    if ("classesTrack" in $$props)
      $$invalidate(4, classesTrack = $$new_props.classesTrack);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$modeCurrent, bgLight, bgDark*/
    386) {
      $:
        $$invalidate(18, trackBg = $modeCurrent === true ? bgLight : bgDark);
    }
    if ($$self.$$.dirty & /*$modeCurrent, bgDark, bgLight*/
    386) {
      $:
        $$invalidate(17, thumbBg = $modeCurrent === true ? bgDark : bgLight);
    }
    if ($$self.$$.dirty & /*$modeCurrent*/
    2) {
      $:
        $$invalidate(16, thumbPosition = $modeCurrent === true ? "translate-x-[100%]" : "");
    }
    if ($$self.$$.dirty & /*$modeCurrent, fillLight, fillDark*/
    1538) {
      $:
        $$invalidate(15, iconFill = $modeCurrent === true ? fillLight : fillDark);
    }
    $:
      $$invalidate(4, classesTrack = `${cTrack3} ${cTransition} ${width} ${height} ${ring} ${rounded} ${trackBg} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*height, rounded, thumbBg, thumbPosition*/
    217088) {
      $:
        $$invalidate(3, classesThumb = `${cThumb2} ${cTransition} ${height} ${rounded} ${thumbBg} ${thumbPosition}`);
    }
    if ($$self.$$.dirty & /*iconFill*/
    32768) {
      $:
        $$invalidate(2, classesIcon = `${cIcon} ${iconFill}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    title,
    $modeCurrent,
    classesIcon,
    classesThumb,
    classesTrack,
    svgPath,
    onToggleHandler,
    bgLight,
    bgDark,
    fillLight,
    fillDark,
    width,
    height,
    ring,
    rounded,
    iconFill,
    thumbPosition,
    thumbBg,
    trackBg,
    click_handler,
    keydown_handler,
    keyup_handler,
    keypress_handler
  ];
}
var LightSwitch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, {
      title: 0,
      bgLight: 7,
      bgDark: 8,
      fillLight: 9,
      fillDark: 10,
      width: 11,
      height: 12,
      ring: 13,
      rounded: 14
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LightSwitch",
      options,
      id: create_fragment37.name
    });
  }
  get title() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgLight() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgLight(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgDark() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgDark(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillLight() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillLight(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fillDark() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fillDark(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get height() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ring() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ring(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<LightSwitch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<LightSwitch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LightSwitch_default = LightSwitch;

// node_modules/@skeletonlabs/skeleton/dist/utilities/Toast/Toast.svelte
var file37 = "node_modules/@skeletonlabs/skeleton/dist/utilities/Toast/Toast.svelte";
function get_each_context10(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[36] = list[i];
  child_ctx[38] = i;
  return child_ctx;
}
function create_if_block29(ctx) {
  let div1;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div0_class_value;
  let div1_class_value;
  let current;
  let each_value = ensure_array_like_dev(
    /*filteredToasts*/
    ctx[11]
  );
  const get_key = (ctx2) => (
    /*t*/
    ctx2[36]
  );
  validate_each_keys(ctx, each_value, get_each_context10, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context10(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block10(key, child_ctx));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = "snackbar " + /*classesSnackbar*/
      ctx[13]);
      add_location(div0, file37, 105, 2, 3392);
      attr_dev(div1, "class", div1_class_value = "snackbar-wrapper " + /*classesWrapper*/
      ctx[14]);
      attr_dev(div1, "data-testid", "snackbar-wrapper");
      add_location(div1, file37, 103, 1, 3295);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*filteredToasts, transitionOut, animAxis, transitionOutParams, transitions, onMouseEnter, onMouseLeave, classesToast, background, buttonDismiss, toastStore, buttonDismissLabel, buttonAction, onAction*/
      499103) {
        each_value = ensure_array_like_dev(
          /*filteredToasts*/
          ctx2[11]
        );
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        validate_each_keys(ctx2, each_value, get_each_context10, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, fix_and_outro_and_destroy_block, create_each_block10, null, get_each_context10);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
      if (!current || dirty[0] & /*classesSnackbar*/
      8192 && div0_class_value !== (div0_class_value = "snackbar " + /*classesSnackbar*/
      ctx2[13])) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*classesWrapper*/
      16384 && div1_class_value !== (div1_class_value = "snackbar-wrapper " + /*classesWrapper*/
      ctx2[14])) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block29.name,
    type: "if",
    source: "(102:0) {#if $toastStore.length}",
    ctx
  });
  return block;
}
function create_if_block_115(ctx) {
  let div;
  let t_1;
  let div_class_value;
  let if_block0 = (
    /*t*/
    ctx[36].action && create_if_block_38(ctx)
  );
  let if_block1 = !/*t*/
  ctx[36].hideDismiss && create_if_block_213(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t_1 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0)
        if_block0.l(div_nodes);
      t_1 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "toast-actions " + cToastActions);
      add_location(div, file37, 128, 7, 4281);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_hydration_dev(div, t_1);
      if (if_block1)
        if_block1.m(div, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*t*/
        ctx2[36].action
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_38(ctx2);
          if_block0.c();
          if_block0.m(div, t_1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!/*t*/
      ctx2[36].hideDismiss) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_213(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_115.name,
    type: "if",
    source: "(128:6) {#if t.action || !t.hideDismiss}",
    ctx
  });
  return block;
}
function create_if_block_38(ctx) {
  let button;
  let html_tag;
  let raw_value = (
    /*t*/
    ctx[36].action.label + ""
  );
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[30](
        /*i*/
        ctx[38]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      html_tag = claim_html_tag(button_nodes, false);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(
        button,
        "class",
        /*buttonAction*/
        ctx[1]
      );
      add_location(button, file37, 129, 22, 4347);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      html_tag.m(raw_value, button);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*filteredToasts*/
      2048 && raw_value !== (raw_value = /*t*/
      ctx[36].action.label + ""))
        html_tag.p(raw_value);
      if (dirty[0] & /*buttonAction*/
      2) {
        attr_dev(
          button,
          "class",
          /*buttonAction*/
          ctx[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_38.name,
    type: "if",
    source: "(130:8) {#if t.action}",
    ctx
  });
  return block;
}
function create_if_block_213(ctx) {
  let button;
  let t_1;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[31](
        /*t*/
        ctx[36]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      t_1 = text(
        /*buttonDismissLabel*/
        ctx[3]
      );
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, "aria-label": true });
      var button_nodes = children(button);
      t_1 = claim_text(
        button_nodes,
        /*buttonDismissLabel*/
        ctx[3]
      );
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        button,
        "class",
        /*buttonDismiss*/
        ctx[2]
      );
      attr_dev(button, "aria-label", "Dismiss toast");
      add_location(button, file37, 130, 28, 4470);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t_1);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler_1, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*buttonDismissLabel*/
      8)
        set_data_dev(
          t_1,
          /*buttonDismissLabel*/
          ctx[3]
        );
      if (dirty[0] & /*buttonDismiss*/
      4) {
        attr_dev(
          button,
          "class",
          /*buttonDismiss*/
          ctx[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_213.name,
    type: "if",
    source: "(131:8) {#if !t.hideDismiss}",
    ctx
  });
  return block;
}
function create_each_block10(key_1, ctx) {
  let div2;
  let div1;
  let div0;
  let html_tag;
  let raw_value = (
    /*t*/
    ctx[36].message + ""
  );
  let t0;
  let div1_class_value;
  let t1;
  let div2_role_value;
  let div2_intro;
  let div2_outro;
  let rect;
  let stop_animation = noop;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*t*/
    (ctx[36].action || !/*t*/
    ctx[36].hideDismiss) && create_if_block_115(ctx)
  );
  function mouseenter_handler() {
    return (
      /*mouseenter_handler*/
      ctx[32](
        /*i*/
        ctx[38]
      )
    );
  }
  function mouseleave_handler() {
    return (
      /*mouseleave_handler*/
      ctx[33](
        /*i*/
        ctx[38]
      )
    );
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      html_tag = new HtmlTagHydration(false);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { role: true, "aria-live": true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true, "data-testid": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      html_tag = claim_html_tag(div0_nodes, false);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(div0, "class", "text-base");
      add_location(div0, file37, 126, 6, 4188);
      attr_dev(div1, "class", div1_class_value = "toast " + /*classesToast*/
      ctx[12] + " " + /*t*/
      (ctx[36].background ?? /*background*/
      ctx[0]) + " " + /*t*/
      (ctx[36].classes ?? ""));
      attr_dev(div1, "data-testid", "toast");
      add_location(div1, file37, 125, 5, 4080);
      attr_dev(div2, "role", div2_role_value = /*t*/
      ctx[36].hideDismiss ? "alert" : "alertdialog");
      attr_dev(div2, "aria-live", "polite");
      add_location(div2, file37, 107, 4, 3475);
      this.first = div2;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      html_tag.m(raw_value, div0);
      append_hydration_dev(div1, t0);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div2, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(div2, "mouseenter", mouseenter_handler, false, false, false, false),
          listen_dev(div2, "mouseleave", mouseleave_handler, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*filteredToasts*/
      2048) && raw_value !== (raw_value = /*t*/
      ctx[36].message + ""))
        html_tag.p(raw_value);
      if (
        /*t*/
        ctx[36].action || !/*t*/
        ctx[36].hideDismiss
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_115(ctx);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty[0] & /*classesToast, filteredToasts, background*/
      6145 && div1_class_value !== (div1_class_value = "toast " + /*classesToast*/
      ctx[12] + " " + /*t*/
      (ctx[36].background ?? /*background*/
      ctx[0]) + " " + /*t*/
      (ctx[36].classes ?? ""))) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*filteredToasts*/
      2048 && div2_role_value !== (div2_role_value = /*t*/
      ctx[36].hideDismiss ? "alert" : "alertdialog")) {
        attr_dev(div2, "role", div2_role_value);
      }
    },
    r: function measure() {
      rect = div2.getBoundingClientRect();
    },
    f: function fix() {
      fix_position(div2);
      stop_animation();
      add_transform(div2, rect);
    },
    a: function animate() {
      stop_animation();
      stop_animation = create_animation(div2, rect, flip, {
        duration: (
          /*transitions*/
          ctx[4] ? 250 : 0
        )
      });
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (div2_outro)
          div2_outro.end(1);
        div2_intro = create_in_transition(div2, dynamicTransition, {
          transition: (
            /*transitionIn*/
            ctx[5]
          ),
          params: {
            x: (
              /*animAxis*/
              ctx[10].x
            ),
            y: (
              /*animAxis*/
              ctx[10].y
            ),
            .../*transitionInParams*/
            ctx[6]
          },
          enabled: (
            /*transitions*/
            ctx[4]
          )
        });
        div2_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      if (div2_intro)
        div2_intro.invalidate();
      div2_outro = create_out_transition(div2, dynamicTransition, {
        transition: (
          /*transitionOut*/
          ctx[7]
        ),
        params: {
          x: (
            /*animAxis*/
            ctx[10].x
          ),
          y: (
            /*animAxis*/
            ctx[10].y
          ),
          .../*transitionOutParams*/
          ctx[8]
        },
        enabled: (
          /*transitions*/
          ctx[4]
        )
      });
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block)
        if_block.d();
      if (detaching && div2_outro)
        div2_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block10.name,
    type: "each",
    source: "(107:3) {#each filteredToasts as t, i (t)}",
    ctx
  });
  return block;
}
function create_fragment38(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$toastStore*/
    ctx[9].length && create_if_block29(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$toastStore*/
        ctx2[9].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$toastStore*/
          512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block29(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cWrapper4 = "flex fixed top-0 left-0 right-0 bottom-0 pointer-events-none";
var cSnackbar = "flex flex-col gap-y-2";
var cToast = "flex justify-between items-center pointer-events-auto";
var cToastActions = "flex items-center space-x-2";
function instance38($$self, $$props, $$invalidate) {
  let classesWrapper;
  let classesSnackbar;
  let classesToast;
  let filteredToasts;
  let $toastStore;
  let $prefersReducedMotionStore;
  validate_store(prefersReducedMotionStore, "prefersReducedMotionStore");
  component_subscribe($$self, prefersReducedMotionStore, ($$value) => $$invalidate(34, $prefersReducedMotionStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toast", slots, []);
  const toastStore = getToastStore();
  validate_store(toastStore, "toastStore");
  component_subscribe($$self, toastStore, (value) => $$invalidate(9, $toastStore = value));
  let { position = "b" } = $$props;
  let { max = 3 } = $$props;
  let { background = "variant-filled-secondary" } = $$props;
  let { width = "max-w-[640px]" } = $$props;
  let { color = "" } = $$props;
  let { padding = "p-4" } = $$props;
  let { spacing = "space-x-4" } = $$props;
  let { rounded = "rounded-container-token" } = $$props;
  let { shadow = "shadow-lg" } = $$props;
  let { zIndex = "z-[888]" } = $$props;
  let { buttonAction = "btn variant-filled" } = $$props;
  let { buttonDismiss = "btn-icon btn-icon-sm variant-filled" } = $$props;
  let { buttonDismissLabel = "" } = $$props;
  let { transitions = !$prefersReducedMotionStore } = $$props;
  let { transitionIn = fly } = $$props;
  let { transitionInParams = { duration: 250 } } = $$props;
  let { transitionOut = fly } = $$props;
  let { transitionOutParams = { duration: 250 } } = $$props;
  let cPosition;
  let cAlign;
  let animAxis = { x: 0, y: 0 };
  switch (position) {
    case "t":
      cPosition = "justify-center items-start";
      cAlign = "items-center";
      animAxis = { x: 0, y: -100 };
      break;
    case "b":
      cPosition = "justify-center items-end";
      cAlign = "items-center";
      animAxis = { x: 0, y: 100 };
      break;
    case "l":
      cPosition = "justify-start items-center";
      cAlign = "items-start";
      animAxis = { x: -100, y: 0 };
      break;
    case "r":
      cPosition = "justify-end items-center";
      cAlign = "items-end";
      animAxis = { x: 100, y: 0 };
      break;
    case "tl":
      cPosition = "justify-start items-start";
      cAlign = "items-start";
      animAxis = { x: -100, y: 0 };
      break;
    case "tr":
      cPosition = "justify-end items-start";
      cAlign = "items-end";
      animAxis = { x: 100, y: 0 };
      break;
    case "bl":
      cPosition = "justify-start items-end";
      cAlign = "items-start";
      animAxis = { x: -100, y: 0 };
      break;
    case "br":
      cPosition = "justify-end items-end";
      cAlign = "items-end";
      animAxis = { x: 100, y: 0 };
      break;
  }
  function onAction(index) {
    var _a, _b;
    (_b = (_a = $toastStore[index]) == null ? void 0 : _a.action) == null ? void 0 : _b.response();
    toastStore.close($toastStore[index].id);
  }
  function onMouseEnter(index) {
    var _a;
    if ((_a = $toastStore[index]) == null ? void 0 : _a.hoverable) {
      toastStore.freeze(index);
      $$invalidate(13, classesSnackbar += " scale-[105%]");
    }
  }
  function onMouseLeave(index) {
    var _a;
    if ((_a = $toastStore[index]) == null ? void 0 : _a.hoverable) {
      toastStore.unfreeze(index);
      $$invalidate(13, classesSnackbar = classesSnackbar.replace(" scale-[105%]", ""));
    }
  }
  const click_handler = (i) => onAction(i);
  const click_handler_1 = (t) => toastStore.close(t.id);
  const mouseenter_handler = (i) => onMouseEnter(i);
  const mouseleave_handler = (i) => onMouseLeave(i);
  $$self.$$set = ($$new_props) => {
    $$invalidate(35, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("position" in $$new_props)
      $$invalidate(19, position = $$new_props.position);
    if ("max" in $$new_props)
      $$invalidate(20, max = $$new_props.max);
    if ("background" in $$new_props)
      $$invalidate(0, background = $$new_props.background);
    if ("width" in $$new_props)
      $$invalidate(21, width = $$new_props.width);
    if ("color" in $$new_props)
      $$invalidate(22, color = $$new_props.color);
    if ("padding" in $$new_props)
      $$invalidate(23, padding = $$new_props.padding);
    if ("spacing" in $$new_props)
      $$invalidate(24, spacing = $$new_props.spacing);
    if ("rounded" in $$new_props)
      $$invalidate(25, rounded = $$new_props.rounded);
    if ("shadow" in $$new_props)
      $$invalidate(26, shadow = $$new_props.shadow);
    if ("zIndex" in $$new_props)
      $$invalidate(27, zIndex = $$new_props.zIndex);
    if ("buttonAction" in $$new_props)
      $$invalidate(1, buttonAction = $$new_props.buttonAction);
    if ("buttonDismiss" in $$new_props)
      $$invalidate(2, buttonDismiss = $$new_props.buttonDismiss);
    if ("buttonDismissLabel" in $$new_props)
      $$invalidate(3, buttonDismissLabel = $$new_props.buttonDismissLabel);
    if ("transitions" in $$new_props)
      $$invalidate(4, transitions = $$new_props.transitions);
    if ("transitionIn" in $$new_props)
      $$invalidate(5, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$new_props)
      $$invalidate(6, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$new_props)
      $$invalidate(7, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$new_props)
      $$invalidate(8, transitionOutParams = $$new_props.transitionOutParams);
  };
  $$self.$capture_state = () => ({
    fly,
    prefersReducedMotionStore,
    dynamicTransition,
    flip,
    getToastStore,
    toastStore,
    position,
    max,
    background,
    width,
    color,
    padding,
    spacing,
    rounded,
    shadow,
    zIndex,
    buttonAction,
    buttonDismiss,
    buttonDismissLabel,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    cWrapper: cWrapper4,
    cSnackbar,
    cToast,
    cToastActions,
    cPosition,
    cAlign,
    animAxis,
    onAction,
    onMouseEnter,
    onMouseLeave,
    filteredToasts,
    classesToast,
    classesSnackbar,
    classesWrapper,
    $toastStore,
    $prefersReducedMotionStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(35, $$props = assign(assign({}, $$props), $$new_props));
    if ("position" in $$props)
      $$invalidate(19, position = $$new_props.position);
    if ("max" in $$props)
      $$invalidate(20, max = $$new_props.max);
    if ("background" in $$props)
      $$invalidate(0, background = $$new_props.background);
    if ("width" in $$props)
      $$invalidate(21, width = $$new_props.width);
    if ("color" in $$props)
      $$invalidate(22, color = $$new_props.color);
    if ("padding" in $$props)
      $$invalidate(23, padding = $$new_props.padding);
    if ("spacing" in $$props)
      $$invalidate(24, spacing = $$new_props.spacing);
    if ("rounded" in $$props)
      $$invalidate(25, rounded = $$new_props.rounded);
    if ("shadow" in $$props)
      $$invalidate(26, shadow = $$new_props.shadow);
    if ("zIndex" in $$props)
      $$invalidate(27, zIndex = $$new_props.zIndex);
    if ("buttonAction" in $$props)
      $$invalidate(1, buttonAction = $$new_props.buttonAction);
    if ("buttonDismiss" in $$props)
      $$invalidate(2, buttonDismiss = $$new_props.buttonDismiss);
    if ("buttonDismissLabel" in $$props)
      $$invalidate(3, buttonDismissLabel = $$new_props.buttonDismissLabel);
    if ("transitions" in $$props)
      $$invalidate(4, transitions = $$new_props.transitions);
    if ("transitionIn" in $$props)
      $$invalidate(5, transitionIn = $$new_props.transitionIn);
    if ("transitionInParams" in $$props)
      $$invalidate(6, transitionInParams = $$new_props.transitionInParams);
    if ("transitionOut" in $$props)
      $$invalidate(7, transitionOut = $$new_props.transitionOut);
    if ("transitionOutParams" in $$props)
      $$invalidate(8, transitionOutParams = $$new_props.transitionOutParams);
    if ("cPosition" in $$props)
      $$invalidate(28, cPosition = $$new_props.cPosition);
    if ("cAlign" in $$props)
      $$invalidate(29, cAlign = $$new_props.cAlign);
    if ("animAxis" in $$props)
      $$invalidate(10, animAxis = $$new_props.animAxis);
    if ("filteredToasts" in $$props)
      $$invalidate(11, filteredToasts = $$new_props.filteredToasts);
    if ("classesToast" in $$props)
      $$invalidate(12, classesToast = $$new_props.classesToast);
    if ("classesSnackbar" in $$props)
      $$invalidate(13, classesSnackbar = $$new_props.classesSnackbar);
    if ("classesWrapper" in $$props)
      $$invalidate(14, classesWrapper = $$new_props.classesWrapper);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    $:
      $$invalidate(14, classesWrapper = `${cWrapper4} ${cPosition} ${zIndex} ${$$props.class || ""}`);
    if ($$self.$$.dirty[0] & /*cAlign, padding*/
    545259520) {
      $:
        $$invalidate(13, classesSnackbar = `${cSnackbar} ${cAlign} ${padding}`);
    }
    if ($$self.$$.dirty[0] & /*width, color, padding, spacing, rounded, shadow*/
    132120576) {
      $:
        $$invalidate(12, classesToast = `${cToast} ${width} ${color} ${padding} ${spacing} ${rounded} ${shadow}`);
    }
    if ($$self.$$.dirty[0] & /*$toastStore, max*/
    1049088) {
      $:
        $$invalidate(11, filteredToasts = Array.from($toastStore).slice(0, max));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    background,
    buttonAction,
    buttonDismiss,
    buttonDismissLabel,
    transitions,
    transitionIn,
    transitionInParams,
    transitionOut,
    transitionOutParams,
    $toastStore,
    animAxis,
    filteredToasts,
    classesToast,
    classesSnackbar,
    classesWrapper,
    toastStore,
    onAction,
    onMouseEnter,
    onMouseLeave,
    position,
    max,
    width,
    color,
    padding,
    spacing,
    rounded,
    shadow,
    zIndex,
    cPosition,
    cAlign,
    click_handler,
    click_handler_1,
    mouseenter_handler,
    mouseleave_handler
  ];
}
var Toast = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance38,
      create_fragment38,
      safe_not_equal,
      {
        position: 19,
        max: 20,
        background: 0,
        width: 21,
        color: 22,
        padding: 23,
        spacing: 24,
        rounded: 25,
        shadow: 26,
        zIndex: 27,
        buttonAction: 1,
        buttonDismiss: 2,
        buttonDismissLabel: 3,
        transitions: 4,
        transitionIn: 5,
        transitionInParams: 6,
        transitionOut: 7,
        transitionOutParams: 8
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toast",
      options,
      id: create_fragment38.name
    });
  }
  get position() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set position(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get spacing() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set spacing(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rounded() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rounded(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shadow() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shadow(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get zIndex() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set zIndex(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonAction() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonAction(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonDismiss() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonDismiss(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get buttonDismissLabel() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttonDismissLabel(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitions() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitions(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionIn() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionIn(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionInParams() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionInParams(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOut() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOut(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionOutParams() {
    throw new Error("<Toast>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionOutParams(value) {
    throw new Error("<Toast>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Toast_default = Toast;

// node_modules/@skeletonlabs/skeleton/dist/utilities/TableOfContents/TableOfContents.svelte
var file38 = "node_modules/@skeletonlabs/skeleton/dist/utilities/TableOfContents/TableOfContents.svelte";
function get_each_context11(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_if_block30(ctx) {
  let nav;
  let div;
  let t;
  let ul;
  let ul_class_value;
  let nav_class_value;
  let nav_transition;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  const default_slot_or_fallback = default_slot || fallback_block6(ctx);
  let each_value = ensure_array_like_dev(
    /*$tocStore*/
    ctx[9]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block11(get_each_context11(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      nav = element("nav");
      div = element("div");
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
      t = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      nav = claim_element(nodes, "NAV", { class: true, "data-testid": true });
      var nav_nodes = children(nav);
      div = claim_element(nav_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot_or_fallback)
        default_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      t = claim_space(nav_nodes);
      ul = claim_element(nav_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        div,
        "class",
        /*regionLead*/
        ctx[3]
      );
      add_location(div, file38, 35, 2, 999);
      attr_dev(ul, "class", ul_class_value = "toc-list " + /*classesList*/
      ctx[6]);
      add_location(ul, file38, 39, 2, 1085);
      attr_dev(nav, "class", nav_class_value = "toc " + /*classesBase*/
      ctx[7]);
      attr_dev(nav, "data-testid", "toc");
      add_location(nav, file38, 33, 1, 872);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, nav, anchor);
      append_hydration_dev(nav, div);
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(div, null);
      }
      append_hydration_dev(nav, t);
      append_hydration_dev(nav, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*regionLead*/
      8) {
        attr_dev(
          div,
          "class",
          /*regionLead*/
          ctx2[3]
        );
      }
      if (dirty & /*classesListItem, indentStyles, $tocStore, classesAnchor, reactiveActiveId, active, inactive*/
      823) {
        each_value = ensure_array_like_dev(
          /*$tocStore*/
          ctx2[9]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context11(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block11(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & /*classesList*/
      64 && ul_class_value !== (ul_class_value = "toc-list " + /*classesList*/
      ctx2[6])) {
        attr_dev(ul, "class", ul_class_value);
      }
      if (!current || dirty & /*classesBase*/
      128 && nav_class_value !== (nav_class_value = "toc " + /*classesBase*/
      ctx2[7])) {
        attr_dev(nav, "class", nav_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!nav_transition)
            nav_transition = create_bidirectional_transition(nav, fade, { duration: 100 }, true);
          nav_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot_or_fallback, local);
      if (local) {
        if (!nav_transition)
          nav_transition = create_bidirectional_transition(nav, fade, { duration: 100 }, false);
        nav_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(nav);
      }
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
      destroy_each(each_blocks, detaching);
      if (detaching && nav_transition)
        nav_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block30.name,
    type: "if",
    source: "(33:0) {#if $tocStore.length}",
    ctx
  });
  return block;
}
function fallback_block6(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Table of Contents");
    },
    l: function claim(nodes) {
      t = claim_text(nodes, "Table of Contents");
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block6.name,
    type: "fallback",
    source: "(37:9) Table of Contents",
    ctx
  });
  return block;
}
function create_each_block11(ctx) {
  let li;
  let a;
  let t0_value = (
    /*tocHeading*/
    ctx[19].text + ""
  );
  let t0;
  let a_href_value;
  let a_class_value;
  let t1;
  let li_class_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[17](
        /*tocHeading*/
        ctx[19]
      )
    );
  }
  const block = {
    c: function create() {
      li = element("li");
      a = element("a");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      a = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      t0 = claim_text(a_nodes, t0_value);
      a_nodes.forEach(detach_dev);
      t1 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(a, "href", a_href_value = "#" + /*tocHeading*/
      ctx[19].id);
      attr_dev(a, "class", a_class_value = "toc-anchor " + /*classesAnchor*/
      ctx[4] + " " + /*tocHeading*/
      (ctx[19].id === /*reactiveActiveId*/
      ctx[8] ? (
        /*active*/
        ctx[1]
      ) : (
        /*inactive*/
        ctx[0]
      )));
      add_location(a, file38, 42, 5, 1245);
      attr_dev(li, "class", li_class_value = "toc-list-item " + /*classesListItem*/
      ctx[5] + " " + /*indentStyles*/
      ctx[2][
        /*tocHeading*/
        ctx[19].element
      ]);
      add_location(li, file38, 41, 4, 1160);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, a);
      append_hydration_dev(a, t0);
      append_hydration_dev(li, t1);
      if (!mounted) {
        dispose = listen_dev(a, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$tocStore*/
      512 && t0_value !== (t0_value = /*tocHeading*/
      ctx[19].text + ""))
        set_data_dev(t0, t0_value);
      if (dirty & /*$tocStore*/
      512 && a_href_value !== (a_href_value = "#" + /*tocHeading*/
      ctx[19].id)) {
        attr_dev(a, "href", a_href_value);
      }
      if (dirty & /*classesAnchor, $tocStore, reactiveActiveId, active, inactive*/
      787 && a_class_value !== (a_class_value = "toc-anchor " + /*classesAnchor*/
      ctx[4] + " " + /*tocHeading*/
      (ctx[19].id === /*reactiveActiveId*/
      ctx[8] ? (
        /*active*/
        ctx[1]
      ) : (
        /*inactive*/
        ctx[0]
      )))) {
        attr_dev(a, "class", a_class_value);
      }
      if (dirty & /*classesListItem, indentStyles, $tocStore*/
      548 && li_class_value !== (li_class_value = "toc-list-item " + /*classesListItem*/
      ctx[5] + " " + /*indentStyles*/
      ctx[2][
        /*tocHeading*/
        ctx[19].element
      ])) {
        attr_dev(li, "class", li_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block11.name,
    type: "each",
    source: "(41:3) {#each $tocStore as tocHeading}",
    ctx
  });
  return block;
}
function create_fragment39(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$tocStore*/
    ctx[9].length && create_if_block30(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$tocStore*/
        ctx2[9].length
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$tocStore*/
          512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block30(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var cBase25 = "space-y-4";
var cList2 = "space-y-2";
var cListItem = "block";
var cAnchor = "";
function instance39($$self, $$props, $$invalidate) {
  let reactiveActiveId;
  let classesBase;
  let classesList;
  let classesListItem;
  let classesAnchor;
  let $tocActiveId;
  let $tocStore;
  validate_store(tocActiveId, "tocActiveId");
  component_subscribe($$self, tocActiveId, ($$value) => $$invalidate(14, $tocActiveId = $$value));
  validate_store(tocStore, "tocStore");
  component_subscribe($$self, tocStore, ($$value) => $$invalidate(9, $tocStore = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableOfContents", slots, ["default"]);
  let { inactive = "opacity-60 hover:opacity-100" } = $$props;
  let { active = "text-primary-500" } = $$props;
  let { activeId = "" } = $$props;
  let { indentStyles = {
    h2: "",
    h3: "ml-4",
    h4: "ml-8",
    h5: "ml-12",
    h6: "ml-16"
  } } = $$props;
  let { regionLead = "font-bold" } = $$props;
  let { regionList = "" } = $$props;
  let { regionListItem = "" } = $$props;
  let { regionAnchor = "" } = $$props;
  const click_handler = (tocHeading) => {
    $$invalidate(8, reactiveActiveId = tocHeading.id);
  };
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("inactive" in $$new_props)
      $$invalidate(0, inactive = $$new_props.inactive);
    if ("active" in $$new_props)
      $$invalidate(1, active = $$new_props.active);
    if ("activeId" in $$new_props)
      $$invalidate(10, activeId = $$new_props.activeId);
    if ("indentStyles" in $$new_props)
      $$invalidate(2, indentStyles = $$new_props.indentStyles);
    if ("regionLead" in $$new_props)
      $$invalidate(3, regionLead = $$new_props.regionLead);
    if ("regionList" in $$new_props)
      $$invalidate(11, regionList = $$new_props.regionList);
    if ("regionListItem" in $$new_props)
      $$invalidate(12, regionListItem = $$new_props.regionListItem);
    if ("regionAnchor" in $$new_props)
      $$invalidate(13, regionAnchor = $$new_props.regionAnchor);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    fade,
    tocStore,
    tocActiveId,
    inactive,
    active,
    activeId,
    indentStyles,
    regionLead,
    regionList,
    regionListItem,
    regionAnchor,
    cBase: cBase25,
    cList: cList2,
    cListItem,
    cAnchor,
    classesAnchor,
    classesListItem,
    classesList,
    classesBase,
    reactiveActiveId,
    $tocActiveId,
    $tocStore
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    if ("inactive" in $$props)
      $$invalidate(0, inactive = $$new_props.inactive);
    if ("active" in $$props)
      $$invalidate(1, active = $$new_props.active);
    if ("activeId" in $$props)
      $$invalidate(10, activeId = $$new_props.activeId);
    if ("indentStyles" in $$props)
      $$invalidate(2, indentStyles = $$new_props.indentStyles);
    if ("regionLead" in $$props)
      $$invalidate(3, regionLead = $$new_props.regionLead);
    if ("regionList" in $$props)
      $$invalidate(11, regionList = $$new_props.regionList);
    if ("regionListItem" in $$props)
      $$invalidate(12, regionListItem = $$new_props.regionListItem);
    if ("regionAnchor" in $$props)
      $$invalidate(13, regionAnchor = $$new_props.regionAnchor);
    if ("classesAnchor" in $$props)
      $$invalidate(4, classesAnchor = $$new_props.classesAnchor);
    if ("classesListItem" in $$props)
      $$invalidate(5, classesListItem = $$new_props.classesListItem);
    if ("classesList" in $$props)
      $$invalidate(6, classesList = $$new_props.classesList);
    if ("classesBase" in $$props)
      $$invalidate(7, classesBase = $$new_props.classesBase);
    if ("reactiveActiveId" in $$props)
      $$invalidate(8, reactiveActiveId = $$new_props.reactiveActiveId);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$tocActiveId, activeId*/
    17408) {
      $:
        $$invalidate(8, reactiveActiveId = $tocActiveId ? $tocActiveId : activeId.replace("#", ""));
    }
    $:
      $$invalidate(7, classesBase = `${cBase25} ${$$props.class ?? ""}`);
    if ($$self.$$.dirty & /*regionList*/
    2048) {
      $:
        $$invalidate(6, classesList = `${cList2} ${regionList}`);
    }
    if ($$self.$$.dirty & /*regionListItem*/
    4096) {
      $:
        $$invalidate(5, classesListItem = `${cListItem} ${regionListItem}`);
    }
    if ($$self.$$.dirty & /*regionAnchor*/
    8192) {
      $:
        $$invalidate(4, classesAnchor = `${cAnchor} ${regionAnchor}`);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    inactive,
    active,
    indentStyles,
    regionLead,
    classesAnchor,
    classesListItem,
    classesList,
    classesBase,
    reactiveActiveId,
    $tocStore,
    activeId,
    regionList,
    regionListItem,
    regionAnchor,
    $tocActiveId,
    $$scope,
    slots,
    click_handler
  ];
}
var TableOfContents = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {
      inactive: 0,
      active: 1,
      activeId: 10,
      indentStyles: 2,
      regionLead: 3,
      regionList: 11,
      regionListItem: 12,
      regionAnchor: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableOfContents",
      options,
      id: create_fragment39.name
    });
  }
  get inactive() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inactive(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeId() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeId(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indentStyles() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indentStyles(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionLead() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionLead(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionList() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionList(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionListItem() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionListItem(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get regionAnchor() {
    throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regionAnchor(value) {
    throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableOfContents_default = TableOfContents;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Apollo.svelte
var file39 = "node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Apollo.svelte";
function create_fragment40(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { values: true, result: true, in: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "values", "0.8 0.6 -0.4 0.1 0,\n					0 1.2 0.05 0 0,\n					0 -1 3 0.02 0,\n					0 0 0 50 0");
      attr_dev(feColorMatrix, "result", "final");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      add_location(feColorMatrix, file39, 3, 2, 235);
      attr_dev(filter2, "id", "Apollo");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file39, 2, 1, 113);
      attr_dev(svg, "id", "svg-filter-apollo");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file39, 1, 0, 40);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Apollo", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Apollo> was created with unknown prop '${key}'`);
  });
  return [];
}
var Apollo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Apollo",
      options,
      id: create_fragment40.name
    });
  }
};
var Apollo_default = Apollo;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/BlueNight.svelte
var file40 = "node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/BlueNight.svelte";
function create_fragment41(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { type: true, values: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "1.000 0.000 0.000 0.000 0.000 \n                    0.000 1.000 0.000 0.000 0.05 \n                    0.000 0.000 1.000 0.000 0.400 \n                    0.000 0.000 0.000 1.000 0.000");
      add_location(feColorMatrix, file40, 3, 2, 247);
      attr_dev(filter2, "id", "BlueNight");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file40, 2, 1, 122);
      attr_dev(svg, "id", "svg-filter-bluenight");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file40, 1, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BlueNight", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<BlueNight> was created with unknown prop '${key}'`);
  });
  return [];
}
var BlueNight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BlueNight",
      options,
      id: create_fragment41.name
    });
  }
};
var BlueNight_default = BlueNight;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Emerald.svelte
var file41 = "node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Emerald.svelte";
function create_fragment42(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  let feComponentTransfer;
  let feFuncR;
  let feFuncG;
  let feFuncB;
  let feFuncA;
  let feBlend;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      feComponentTransfer = svg_element("feComponentTransfer");
      feFuncR = svg_element("feFuncR");
      feFuncG = svg_element("feFuncG");
      feFuncB = svg_element("feFuncB");
      feFuncA = svg_element("feFuncA");
      feBlend = svg_element("feBlend");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        in: true,
        result: true,
        values: true
      });
      children(feColorMatrix).forEach(detach_dev);
      feComponentTransfer = claim_svg_element(filter_nodes, "feComponentTransfer", { in: true, result: true });
      var feComponentTransfer_nodes = children(feComponentTransfer);
      feFuncR = claim_svg_element(feComponentTransfer_nodes, "feFuncR", { type: true, tableValues: true });
      children(feFuncR).forEach(detach_dev);
      feFuncG = claim_svg_element(feComponentTransfer_nodes, "feFuncG", { type: true, tableValues: true });
      children(feFuncG).forEach(detach_dev);
      feFuncB = claim_svg_element(feComponentTransfer_nodes, "feFuncB", { type: true, tableValues: true });
      children(feFuncB).forEach(detach_dev);
      feFuncA = claim_svg_element(feComponentTransfer_nodes, "feFuncA", { type: true, tableValues: true });
      children(feFuncA).forEach(detach_dev);
      feComponentTransfer_nodes.forEach(detach_dev);
      feBlend = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix");
      attr_dev(feColorMatrix, "values", "\n            .16 .185 .129 0 0\n            .16 .185 .129 0 0\n            .16 .185 .129 0 0\n            0 0 0 0.33 0");
      add_location(feColorMatrix, file41, 4, 2, 273);
      attr_dev(feFuncR, "type", "table");
      attr_dev(feFuncR, "tableValues", "0.03 0.9");
      add_location(feFuncR, file41, 15, 3, 555);
      attr_dev(feFuncG, "type", "table");
      attr_dev(feFuncG, "tableValues", "0.57 1");
      add_location(feFuncG, file41, 16, 3, 606);
      attr_dev(feFuncB, "type", "table");
      attr_dev(feFuncB, "tableValues", "0.49 0.53");
      add_location(feFuncB, file41, 17, 3, 655);
      attr_dev(feFuncA, "type", "table");
      attr_dev(feFuncA, "tableValues", "0 1");
      add_location(feFuncA, file41, 18, 3, 707);
      attr_dev(feComponentTransfer, "in", "colormatrix");
      attr_dev(feComponentTransfer, "result", "componentTransfer");
      add_location(feComponentTransfer, file41, 14, 2, 486);
      attr_dev(feBlend, "mode", "normal");
      attr_dev(feBlend, "in", "componentTransfer");
      attr_dev(feBlend, "in2", "SourceGraphic");
      attr_dev(feBlend, "result", "blend");
      add_location(feBlend, file41, 20, 2, 777);
      attr_dev(filter2, "id", "Emerald");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file41, 2, 1, 116);
      attr_dev(svg, "id", "svg-filter-emerald");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file41, 1, 0, 42);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
      append_hydration_dev(filter2, feComponentTransfer);
      append_hydration_dev(feComponentTransfer, feFuncR);
      append_hydration_dev(feComponentTransfer, feFuncG);
      append_hydration_dev(feComponentTransfer, feFuncB);
      append_hydration_dev(feComponentTransfer, feFuncA);
      append_hydration_dev(filter2, feBlend);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Emerald", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Emerald> was created with unknown prop '${key}'`);
  });
  return [];
}
var Emerald = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Emerald",
      options,
      id: create_fragment42.name
    });
  }
};
var Emerald_default = Emerald;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/GreenFall.svelte
var file42 = "node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/GreenFall.svelte";
function create_fragment43(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        values: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "0.5 -0.4 0.3332 0 0\n					0 0.4 0.3 0 0\n					0 0 0.5 0 0\n					0 0 0 500 -20");
      attr_dev(feColorMatrix, "x", "0%");
      attr_dev(feColorMatrix, "y", "0%");
      attr_dev(feColorMatrix, "width", "100%");
      attr_dev(feColorMatrix, "height", "100%");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix");
      add_location(feColorMatrix, file42, 12, 2, 315);
      attr_dev(filter2, "id", "GreenFall");
      attr_dev(filter2, "x", "-20%");
      attr_dev(filter2, "y", "-20%");
      attr_dev(filter2, "width", "140%");
      attr_dev(filter2, "height", "140%");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "linearRGB");
      add_location(filter2, file42, 2, 1, 122);
      attr_dev(svg, "id", "svg-filter-greenfall");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file42, 1, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GreenFall", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GreenFall> was created with unknown prop '${key}'`);
  });
  return [];
}
var GreenFall = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GreenFall",
      options,
      id: create_fragment43.name
    });
  }
};
var GreenFall_default = GreenFall;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Noir.svelte
var file43 = "node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Noir.svelte";
function create_fragment44(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  let feBlend0;
  let feBlend1;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      feBlend0 = svg_element("feBlend");
      feBlend1 = svg_element("feBlend");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        values: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix).forEach(detach_dev);
      feBlend0 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend0).forEach(detach_dev);
      feBlend1 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend1).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "saturate");
      attr_dev(feColorMatrix, "values", "0");
      attr_dev(feColorMatrix, "x", "0%");
      attr_dev(feColorMatrix, "y", "0%");
      attr_dev(feColorMatrix, "width", "100%");
      attr_dev(feColorMatrix, "height", "100%");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix1");
      add_location(feColorMatrix, file43, 12, 2, 295);
      attr_dev(feBlend0, "mode", "lighten");
      attr_dev(feBlend0, "x", "0%");
      attr_dev(feBlend0, "y", "0%");
      attr_dev(feBlend0, "width", "100%");
      attr_dev(feBlend0, "height", "100%");
      attr_dev(feBlend0, "in", "colormatrix1");
      attr_dev(feBlend0, "in2", "colormatrix1");
      attr_dev(feBlend0, "result", "blend");
      add_location(feBlend0, file43, 13, 2, 424);
      attr_dev(feBlend1, "mode", "multiply");
      attr_dev(feBlend1, "x", "0%");
      attr_dev(feBlend1, "y", "0%");
      attr_dev(feBlend1, "width", "100%");
      attr_dev(feBlend1, "height", "100%");
      attr_dev(feBlend1, "in", "colormatrix1");
      attr_dev(feBlend1, "in2", "diffuseLighting");
      attr_dev(feBlend1, "result", "blend1");
      add_location(feBlend1, file43, 14, 2, 546);
      attr_dev(filter2, "id", "Noir");
      attr_dev(filter2, "x", "-20%");
      attr_dev(filter2, "y", "-20%");
      attr_dev(filter2, "width", "140%");
      attr_dev(filter2, "height", "140%");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "linearRGB");
      add_location(filter2, file43, 2, 1, 107);
      attr_dev(svg, "id", "svg-filter-noir");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file43, 1, 0, 36);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
      append_hydration_dev(filter2, feBlend0);
      append_hydration_dev(filter2, feBlend1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Noir", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Noir> was created with unknown prop '${key}'`);
  });
  return [];
}
var Noir = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Noir",
      options,
      id: create_fragment44.name
    });
  }
};
var Noir_default = Noir;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/NoirLight.svelte
var file44 = "node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/NoirLight.svelte";
function create_fragment45(ctx) {
  let svg;
  let filter2;
  let feColorMatrix0;
  let feBlend0;
  let feBlend1;
  let feColorMatrix1;
  let feBlend2;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix0 = svg_element("feColorMatrix");
      feBlend0 = svg_element("feBlend");
      feBlend1 = svg_element("feBlend");
      feColorMatrix1 = svg_element("feColorMatrix");
      feBlend2 = svg_element("feBlend");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        x: true,
        y: true,
        width: true,
        height: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix0 = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        values: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix0).forEach(detach_dev);
      feBlend0 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend0).forEach(detach_dev);
      feBlend1 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend1).forEach(detach_dev);
      feColorMatrix1 = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        result: true
      });
      children(feColorMatrix1).forEach(detach_dev);
      feBlend2 = claim_svg_element(filter_nodes, "feBlend", {
        mode: true,
        x: true,
        y: true,
        width: true,
        height: true,
        in: true,
        in2: true,
        result: true
      });
      children(feBlend2).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix0, "type", "saturate");
      attr_dev(feColorMatrix0, "values", "0");
      attr_dev(feColorMatrix0, "x", "0%");
      attr_dev(feColorMatrix0, "y", "0%");
      attr_dev(feColorMatrix0, "width", "100%");
      attr_dev(feColorMatrix0, "height", "100%");
      attr_dev(feColorMatrix0, "in", "SourceGraphic");
      attr_dev(feColorMatrix0, "result", "colormatrix2");
      add_location(feColorMatrix0, file44, 12, 2, 315);
      attr_dev(feBlend0, "mode", "saturation");
      attr_dev(feBlend0, "x", "0%");
      attr_dev(feBlend0, "y", "0%");
      attr_dev(feBlend0, "width", "100%");
      attr_dev(feBlend0, "height", "100%");
      attr_dev(feBlend0, "in", "SourceGraphic");
      attr_dev(feBlend0, "in2", "colormatrix2");
      attr_dev(feBlend0, "result", "blend2");
      add_location(feBlend0, file44, 13, 2, 444);
      attr_dev(feBlend1, "mode", "screen");
      attr_dev(feBlend1, "x", "0%");
      attr_dev(feBlend1, "y", "0%");
      attr_dev(feBlend1, "width", "100%");
      attr_dev(feBlend1, "height", "100%");
      attr_dev(feBlend1, "in", "colormatrix2");
      attr_dev(feBlend1, "in2", "blend2");
      attr_dev(feBlend1, "result", "blend3");
      add_location(feBlend1, file44, 14, 2, 571);
      attr_dev(feColorMatrix1, "type", "luminanceToAlpha");
      attr_dev(feColorMatrix1, "x", "0%");
      attr_dev(feColorMatrix1, "y", "0%");
      attr_dev(feColorMatrix1, "width", "100%");
      attr_dev(feColorMatrix1, "height", "100%");
      attr_dev(feColorMatrix1, "in", "blend3");
      attr_dev(feColorMatrix1, "result", "colormatrix3");
      add_location(feColorMatrix1, file44, 15, 2, 687);
      attr_dev(feBlend2, "mode", "exclusion");
      attr_dev(feBlend2, "x", "0%");
      attr_dev(feBlend2, "y", "0%");
      attr_dev(feBlend2, "width", "100%");
      attr_dev(feBlend2, "height", "100%");
      attr_dev(feBlend2, "in", "blend3");
      attr_dev(feBlend2, "in2", "colormatrix3");
      attr_dev(feBlend2, "result", "blend5");
      add_location(feBlend2, file44, 16, 2, 806);
      attr_dev(filter2, "id", "NoirLight");
      attr_dev(filter2, "x", "-20%");
      attr_dev(filter2, "y", "-20%");
      attr_dev(filter2, "width", "140%");
      attr_dev(filter2, "height", "140%");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "linearRGB");
      add_location(filter2, file44, 2, 1, 122);
      attr_dev(svg, "id", "svg-filter-noirlight");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file44, 1, 0, 46);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix0);
      append_hydration_dev(filter2, feBlend0);
      append_hydration_dev(filter2, feBlend1);
      append_hydration_dev(filter2, feColorMatrix1);
      append_hydration_dev(filter2, feBlend2);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NoirLight", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NoirLight> was created with unknown prop '${key}'`);
  });
  return [];
}
var NoirLight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NoirLight",
      options,
      id: create_fragment45.name
    });
  }
};
var NoirLight_default = NoirLight;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Rustic.svelte
var file45 = "node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Rustic.svelte";
function create_fragment46(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", {
        type: true,
        in: true,
        result: true,
        values: true
      });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "in", "SourceGraphic");
      attr_dev(feColorMatrix, "result", "colormatrix");
      attr_dev(feColorMatrix, "values", "0.39215686274509803 0.39215686274509803 0.39215686274509803  0 0 \n					0.3333333333333333 0.3333333333333333 0.3333333333333333  0 0 \n					0.30980392156862746 0.30980392156862746 0.30980392156862746  0 0  \n					0 0 0 1 0");
      add_location(feColorMatrix, file45, 3, 2, 235);
      attr_dev(filter2, "id", "Rustic");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file45, 2, 1, 113);
      attr_dev(svg, "id", "svg-filter-rustic");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file45, 1, 0, 40);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Rustic", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Rustic> was created with unknown prop '${key}'`);
  });
  return [];
}
var Rustic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Rustic",
      options,
      id: create_fragment46.name
    });
  }
};
var Rustic_default = Rustic;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Summer84.svelte
var file46 = "node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/Summer84.svelte";
function create_fragment47(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { type: true, values: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "1.300 0.200 0.000 0.000 0.000 \n					0.300 0.600 0.200 0.000 0.000 \n					0.200 1.000 0.200 0.000 0.000 \n					0.000 0.000 0.000 1.000 0.000");
      add_location(feColorMatrix, file46, 3, 2, 243);
      attr_dev(filter2, "id", "Summer84");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file46, 2, 1, 119);
      attr_dev(svg, "id", "svg-filter-summer84");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file46, 1, 0, 44);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Summer84", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Summer84> was created with unknown prop '${key}'`);
  });
  return [];
}
var Summer84 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Summer84",
      options,
      id: create_fragment47.name
    });
  }
};
var Summer84_default = Summer84;

// node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/XPro.svelte
var file47 = "node_modules/@skeletonlabs/skeleton/dist/actions/Filters/svg-filters/XPro.svelte";
function create_fragment48(ctx) {
  let svg;
  let filter2;
  let feColorMatrix;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      filter2 = svg_element("filter");
      feColorMatrix = svg_element("feColorMatrix");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { id: true, class: true });
      var svg_nodes = children(svg);
      filter2 = claim_svg_element(svg_nodes, "filter", {
        id: true,
        filterUnits: true,
        primitiveUnits: true,
        "color-interpolation-filters": true
      });
      var filter_nodes = children(filter2);
      feColorMatrix = claim_svg_element(filter_nodes, "feColorMatrix", { type: true, values: true });
      children(feColorMatrix).forEach(detach_dev);
      filter_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(feColorMatrix, "type", "matrix");
      attr_dev(feColorMatrix, "values", "1.70 -0.20 0.00 0.00 0.00 \n                    0.10 0.800 0.30 0.00 0.00 \n                    0.20 0.300 0.50 0.00 0.00 \n                    0.00 0.00 0.00 1.00 0.00");
      add_location(feColorMatrix, file47, 3, 2, 227);
      attr_dev(filter2, "id", "XPro");
      attr_dev(filter2, "filterUnits", "objectBoundingBox");
      attr_dev(filter2, "primitiveUnits", "userSpaceOnUse");
      attr_dev(filter2, "color-interpolation-filters", "sRGB");
      add_location(filter2, file47, 2, 1, 107);
      attr_dev(svg, "id", "svg-filter-xpro");
      attr_dev(svg, "class", "filter absolute -left-full w-0 h-0");
      add_location(svg, file47, 1, 0, 36);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, filter2);
      append_hydration_dev(filter2, feColorMatrix);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("XPro", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<XPro> was created with unknown prop '${key}'`);
  });
  return [];
}
var XPro = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment48, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XPro",
      options,
      id: create_fragment48.name
    });
  }
};
var XPro_default = XPro;
export {
  Accordion_default as Accordion,
  AccordionItem_default as AccordionItem,
  Apollo_default as Apollo,
  AppBar_default as AppBar,
  AppRail_default as AppRail,
  AppRailAnchor_default as AppRailAnchor,
  AppRailTile_default as AppRailTile,
  AppShell_default as AppShell,
  Autocomplete_default as Autocomplete,
  Avatar_default as Avatar,
  BlueNight_default as BlueNight,
  CodeBlock_default as CodeBlock,
  ConicGradient_default as ConicGradient,
  Drawer_default as Drawer,
  Emerald_default as Emerald,
  FileButton_default as FileButton,
  FileDropzone_default as FileDropzone,
  GreenFall_default as GreenFall,
  InputChip_default as InputChip,
  LightSwitch_default as LightSwitch,
  ListBox_default as ListBox,
  ListBoxItem_default as ListBoxItem,
  Modal_default as Modal,
  Noir_default as Noir,
  NoirLight_default as NoirLight,
  Paginator_default as Paginator,
  ProgressBar_default as ProgressBar,
  ProgressRadial_default as ProgressRadial,
  RadioGroup_default as RadioGroup,
  RadioItem_default as RadioItem,
  RangeSlider_default as RangeSlider,
  Ratings_default as Ratings,
  RecursiveTreeView_default as RecursiveTreeView,
  RecursiveTreeViewItem_default as RecursiveTreeViewItem,
  Rustic_default as Rustic,
  SlideToggle_default as SlideToggle,
  Step_default as Step,
  Stepper_default as Stepper,
  Summer84_default as Summer84,
  Tab_default as Tab,
  TabAnchor_default as TabAnchor,
  TabGroup_default as TabGroup,
  Table_default as Table,
  TableOfContents_default as TableOfContents,
  Toast_default as Toast,
  TreeView_default as TreeView,
  TreeViewItem_default as TreeViewItem,
  XPro_default as XPro,
  autoModeWatcher,
  clipboard,
  filter,
  focusTrap,
  getDrawerStore,
  getModalStore,
  getModeAutoPrefers,
  getModeOsPrefers,
  getModeUserPrefers,
  getToastStore,
  initializeStores,
  localStorageStore,
  modeCurrent,
  modeOsPrefers,
  modeUserPrefers,
  popup,
  prefersReducedMotionStore,
  setInitialClassState,
  setModeCurrent,
  setModeUserPrefers,
  storeHighlightJs,
  storePopup,
  tableMapperValues,
  tableSourceMapper,
  tableSourceValues,
  tocCrawler,
  tocStore
};
//# sourceMappingURL=@skeletonlabs_skeleton.js.map
